var tipuesearch = {"pages":[{"title":" Fortran-lang/stdlib ","text":"Fortran-lang/stdlib Fortran stdlib API Documentation Goals and Motivation Scope Code of Conduct License Warning This API documentation for the Fortran-lang/stdlib is a work in progress Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran stdlib API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation The Fortran Standard, as published by the ISO (https://wg5-fortran.org/), does\nnot have a Standard Library. The goal of this project is to provide a community\ndriven and agreed upon de facto \"standard\" library for Fortran, called a\nFortran Standard Library ( stdlib ). We have a rigorous process how stdlib is\ndeveloped as documented in our Workflow . stdlib is both a\nspecification and a reference implementation. We are cooperating with the\nFortran Standards Committee (e.g., the effort started at the J3\ncommittee repository) and the plan is to continue working with the Committee in\nthe future (such as in the step 5. in the Workflow document), so\nthat if the Committee wants to standardize some feature already available in stdlib , it would\nbase it on stdlib 's implementation. Scope The goal of the Fortran Standard Library is to achieve the following general scope: Utilities (containers, strings, files, OS/environment integration, unit\n  testing & assertions, logging,  ...) Algorithms (searching and sorting, merging, ...) Mathematics (linear algebra, sparse matrices, special functions, fast Fourier\n  transform, random numbers, statistics, ordinary differential equations,\n  numerical integration, optimization, ...) Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Please read first this Code of Conduct License The stdlib source code and related files and documentation are distributed under the MIT license . Developer Info fortran-lang/stdlib contributors","tags":"home","loc":"index.html"},{"title":"stdlib_bitsets_64.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_bitsets_64.fypp~~EfferentGraph sourcefile~stdlib_bitsets_64.fypp stdlib_bitsets_64.fypp sourcefile~stdlib_bitsets.fypp stdlib_bitsets.fypp sourcefile~stdlib_bitsets_64.fypp->sourcefile~stdlib_bitsets.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_bitsets.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_bitsets_64 Source Code stdlib_bitsets_64.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_bitsets ) stdlib_bitsets_64 implicit none contains elemental module function all_64 ( self ) result ( all ) !     Returns .TRUE. if all bits in SELF are 1, .FALSE. otherwise. logical :: all class ( bitset_64 ), intent ( in ) :: self intrinsic :: btest integer ( bits_kind ) :: pos do pos = 0 , self % num_bits - 1 if ( . not . btest ( self % block , pos ) ) then all = . false . return end if end do all = . true . end function all_64 elemental module subroutine and_64 ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise AND of the original bits in SET1 !     and SET2. It is required that SET1 have the same number of bits as !     SET2 otherwise the result is undefined. ! type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 !         The set2 extent includes the entire extent of set1. !         The (zeroed) region past the end of set1 is unaffected by !         the iand. set1 % block = iand ( set1 % block , & set2 % block ) end subroutine and_64 elemental module subroutine and_not_64 ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise and of the original bits in SET1 !     with the bitwise negation of SET2.  SET1 and SET2 must have the same !     number of bits otherwise the result is undefined. ! type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 !     The not with iand means that the zero'ed regions past the end of each set !     do not interact with the in set regions set1 % block = iand ( set1 % block , not ( set2 % block ) ) end subroutine and_not_64 elemental module function any_64 ( self ) result ( any ) !     Returns .TRUE. if any bit in SELF is 1, .FALSE. otherwise. logical :: any class ( bitset_64 ), intent ( in ) :: self if ( self % block /= 0 ) then any = . true . return else any = . false . end if end function any_64 pure module subroutine assign_64 ( set1 , set2 ) !     Used to define assignment for bitset_64 type ( bitset_64 ), intent ( out ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 set1 % num_bits = set2 % num_bits set1 % block = set2 % block end subroutine assign_64 # : for k1 in INT_KINDS module subroutine assign_log$ { k1 }$_ 64 ( self , logical_vector ) !     Used to define assignment from an array of type logical for bitset_64 type ( bitset_64 ), intent ( out ) :: self logical ( ${ k1 }$ ), intent ( in ) :: logical_vector (:) integer ( bits_kind ) :: log_size integer ( bits_kind ) :: index log_size = size ( logical_vector , kind = bits_kind ) if ( log_size > 64 ) then error stop module_name // ' % ' // 'ASSIGNMENT' // \" has \" // & \"SIZE(LOGICAL_VECTOR) > 64 with assignment to a BITSET_64.\" end if self % num_bits = log_size self % block = 0 do index = 0 , log_size - 1 if ( logical_vector ( index + 1 ) ) then self % block = ibset ( self % block , index ) end if end do end subroutine assign_log$ { k1 }$_ 64 pure module subroutine log ${ k1 }$_ assign_64 ( logical_vector , set ) !     Used to define assignment to an array of type logical for bitset_64 logical ( ${ k1 }$ ), intent ( out ), allocatable :: logical_vector (:) type ( bitset_64 ), intent ( in ) :: set integer ( bits_kind ) :: index allocate ( logical_vector ( set % num_bits ) ) do index = 0 , set % num_bits - 1 if ( set % value ( index ) == 1 ) then logical_vector ( index + 1 ) = . true . else logical_vector ( index + 1 ) = . false . end if end do end subroutine log ${ k1 }$_ assign_64 # : endfor elemental module function bit_count_64 ( self ) result ( bit_count ) !     Returns the number of non-zero bits in SELF. integer ( bits_kind ) :: bit_count class ( bitset_64 ), intent ( in ) :: self integer ( bits_kind ) :: pos bit_count = 0 do pos = 0 , self % num_bits - 1 if ( btest ( self % block , pos ) ) bit_count = bit_count + 1 end do end function bit_count_64 elemental module subroutine clear_bit_64 ( self , pos ) ! !     Sets to zero the POS position in SELF. If POS is less than zero or !     greater than BITS(SELF)-1 it is ignored. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos if ( pos < 0 . OR . ( pos > self % num_bits - 1 ) ) & return self % block = ibclr ( self % block , pos ) end subroutine clear_bit_64 pure module subroutine clear_range_64 ( self , start_pos , stop_pos ) ! !     Sets to zero all bits from the START_POS to STOP_POS positions in SELF. !     If STOP_POS < START_POS then no bits are modified. Positions outside !     the range 0 to BITS(SELF)-1 are ignored. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: true_first , true_last true_first = max ( 0_bits_kind , start_pos ) true_last = min ( self % num_bits - 1 , stop_pos ) if ( true_last < true_first ) return call mvbits ( all_zeros , & true_first , & true_last - true_first + 1 , & self % block , & true_first ) end subroutine clear_range_64 elemental module function eqv_64 ( set1 , set2 ) result ( eqv ) ! !     Returns .TRUE. if all bits in SET1 and SET2 have the same value, !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: eqv type ( bitset_64 ), intent ( in ) :: set1 , set2 eqv = set1 % block == set2 % block end function eqv_64 module subroutine extract_64 ( new , old , start_pos , stop_pos , status ) !    Creates a new bitset, NEW, from a range, START_POS to STOP_POS, in bitset !    OLD. If START_POS is greater than STOP_POS the new bitset is empty. !    If START_POS is less than zero or STOP_POS is greater than BITS(OLD)-1 !    then if STATUS is present it has the value INDEX_INVALID_ERROR, !    otherwise processing stops with an informative message. type ( bitset_64 ), intent ( out ) :: new type ( bitset_64 ), intent ( in ) :: old integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer , intent ( out ), optional :: status integer ( bits_kind ) :: bits , i , k character ( * ), parameter :: procedure = 'EXTRACT' if ( start_pos < 0 ) then call error_handler ( 'had a START_POS less than 0.' , & index_invalid_error , status , & module_name , procedure ) return end if if ( stop_pos >= old % num_bits ) then call error_handler ( 'had a STOP_POS greater than BITS(OLD)-1.' , & index_invalid_error , status , & module_name , procedure ) return end if bits = stop_pos - start_pos + 1 if ( bits <= 0 ) then new % num_bits = 0 new % block = 0 return else new % num_bits = bits do i = 0 , bits - 1 k = start_pos + i if ( btest ( old % block , k ) ) & new % block = ibset ( new % block , i ) end do end if if ( present ( status ) ) status = success end subroutine extract_64 elemental module subroutine flip_bit_64 ( self , pos ) ! !     Flips the value at the POS position in SELF, provided the position is !     valid. If POS is less than 0 or greater than BITS(SELF)-1, no value is !     changed. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos if ( pos < 0 . OR . pos > self % num_bits - 1 ) return if ( btest ( self % block , pos ) ) then self % block = ibclr ( self % block , pos ) else self % block = ibset ( self % block , pos ) end if end subroutine flip_bit_64 pure module subroutine flip_range_64 ( self , start_pos , stop_pos ) ! !     Flips all valid bits from the START_POS to the STOP_POS positions in !     SELF. If STOP_POS < START_POS no bits are flipped. Positions less than !     0 or greater than BITS(SELF)-1 are ignored. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: end_bit , start_bit start_bit = max ( 0_bits_kind , start_pos ) end_bit = min ( stop_pos , self % num_bits - 1 ) call mvbits ( not ( self % block ), & start_bit , & end_bit - start_bit + 1 , & self % block , & start_bit ) end subroutine flip_range_64 module subroutine from_string_64 ( self , string , status ) !     Initializes the bitset `self` treating `string` as a binary literal !     `status` may have the values: !         `success` - if no problems were found, !         `alloc_fault` - if allocation of the bitset failed !         `char_string_too_large_error` - if `string` was too large, or !         `char_string_invalid_error` - if string had an invalid character. class ( bitset_64 ), intent ( out ) :: self character ( * ), intent ( in ) :: string integer , intent ( out ), optional :: status character ( * ), parameter :: procedure = 'FROM_STRING' integer ( int64 ) :: bit integer ( int64 ) :: bits character ( 1 ) :: char bits = len ( string , kind = int64 ) if ( bits > 64 ) then call error_handler ( 'STRING was too long for a ' // & 'BITSET_64 SELF.' , & char_string_too_large_error , status , & module_name , procedure ) return end if self % num_bits = bits do bit = 1 , bits char = string ( bit : bit ) if ( char == '0' ) then call self % clear ( int ( bits - bit , kind = bits_kind ) ) else if ( char == '1' ) then call self % set ( int ( bits - bit , kind = bits_kind ) ) else call error_handler ( 'STRING had a character other than ' // & '0 or 1.' , & char_string_invalid_error , status , & module_name , procedure ) return end if end do if ( present ( status ) ) status = success end subroutine from_string_64 elemental module function ge_64 ( set1 , set2 ) result ( ge ) ! !     Returns .TRUE. if the bits in SET1 and SET2 are the same or the !     highest order different bit is set to 1 in SET1 and to 0 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: ge type ( bitset_64 ), intent ( in ) :: set1 , set2 ge = bge ( set1 % block , set2 % block ) end function ge_64 elemental module function gt_64 ( set1 , set2 ) result ( gt ) ! !     Returns .TRUE. if the bits in SET1 and SET2 differ and the !     highest order different bit is set to 1 in SET1 and to 0 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: gt type ( bitset_64 ), intent ( in ) :: set1 , set2 gt = bgt ( set1 % block , set2 % block ) end function gt_64 module subroutine init_zero_64 ( self , bits , status ) ! !  Creates the bitset, `self`, of size `bits`, with all bits initialized to !  zero. `bits` must be non-negative.  If an error occurs and `status` is !  absent then processing stops with an informative stop code. `status` !  will have one of the values: !  * `success` -  if no problems were found, !  * `array_size_invalid_error` - if `bits` is either negative or larger !    than 64 with `self` of class `bitset_64`, or !  * `alloc_fault` - if memory allocation failed ! class ( bitset_64 ), intent ( out ) :: self integer ( bits_kind ), intent ( in ) :: bits integer , intent ( out ), optional :: status character ( * ), parameter :: procedure = \"INIT\" if ( bits < 0 ) then call error_handler ( 'BITS had a negative value.' , & array_size_invalid_error , status , & module_name , procedure ) return end if if ( bits > 64 ) then call error_handler ( 'BITS had a value greater than 64.' , & array_size_invalid_error , status , & module_name , procedure ) return end if self % num_bits = bits self % block = all_zeros if ( present ( status ) ) status = success end subroutine init_zero_64 module subroutine input_64 ( self , unit , status ) ! ! Reads the components of the bitset, `self`, from the unformatted I/O ! unit, `unit`, assuming that the components were written using `output`. ! If an error occurs and `status` is absent then processing stops with ! an informative stop code. `status` has one of the values: ! * `success` - if no problem was found ! * `alloc_fault` - if it failed during allocation of memory for `self`, or ! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative !   or greater than 64 for a `bitset_64` input. ! * `read_failure` - if it failed during the reads from `unit` ! class ( bitset_64 ), intent ( out ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status integer ( bits_kind ) :: bits integer :: ierr character ( len = 120 ) :: message character ( * ), parameter :: procedure = 'INPUT' integer :: stat read ( unit , iostat = ierr , iomsg = message ) bits if ( ierr /= 0 ) then call error_handler ( 'Failure on a READ statement for UNIT.' , & read_failure , status , module_name , procedure ) return end if if ( bits < 0 ) then call error_handler ( 'BITS in UNIT had a negative value.' , & array_size_invalid_error , status , & module_name , procedure ) return end if if ( bits > 64 ) then call error_handler ( 'BITS in UNIT had a value greater than 64.' , & array_size_invalid_error , status , & module_name , procedure ) return end if call self % init ( bits , stat ) if ( stat /= success ) then call error_handler ( 'Allocation failure for SELF.' , & alloc_fault , status , module_name , procedure ) return end if if ( bits < 1 ) return read ( unit , iostat = ierr , iomsg = message ) self % block if ( ierr /= 0 ) then call error_handler ( 'Failure on a READ statement for UNIT.' , & read_failure , status , module_name , procedure ) return end if if ( present ( status ) ) status = success end subroutine input_64 elemental module function le_64 ( set1 , set2 ) result ( le ) ! !     Returns .TRUE. if the bits in SET1 and SET2 are the same or the !     highest order different bit is set to 0 in SET1 and to 1 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: le type ( bitset_64 ), intent ( in ) :: set1 , set2 le = ble ( set1 % block , set2 % block ) end function le_64 elemental module function lt_64 ( set1 , set2 ) result ( lt ) ! !     Returns .TRUE. if the bits in SET1 and SET2 differ and the !     highest order different bit is set to 0 in SET1 and to 1 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: lt type ( bitset_64 ), intent ( in ) :: set1 , set2 lt = blt ( set1 % block , set2 % block ) end function lt_64 elemental module function neqv_64 ( set1 , set2 ) result ( neqv ) ! !     Returns .TRUE. if all bits in SET1 and SET2 have the same value, !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: neqv type ( bitset_64 ), intent ( in ) :: set1 , set2 neqv = set1 % block /= set2 % block end function neqv_64 elemental module function none_64 ( self ) result ( none ) ! !     Returns .TRUE. if none of the bits in SELF have the value 1. ! logical :: none class ( bitset_64 ), intent ( in ) :: self none = . true . if ( self % block /= 0 ) then none = . false . return end if end function none_64 elemental module subroutine not_64 ( self ) ! !     Sets the bits in SELF to their logical complement ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ) :: bit if ( self % num_bits == 0 ) return do bit = 0 , self % num_bits - 1 if ( btest ( self % block , bit ) ) then self % block = ibclr ( self % block , bit ) else self % block = ibset ( self % block , bit ) end if end do end subroutine not_64 elemental module subroutine or_64 ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise OR of the original bits in SET1 !     and SET2. If SET1 has fewer bits than SET2 then the additional bits !     in SET2 are ignored. If SET1 has more bits than SET2, then the !     absent SET2 bits are treated as if present with zero value. ! type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 if ( set1 % num_bits >= set2 % num_bits ) then set1 % block = ior ( set1 % block , & set2 % block ) else !         The set1 extent ends before set2 => set2 bits must not affect bits in !         set1 beyond its extent => set those bits to zero while keeping proper !         values of other bits in set2 set1 % block = & ior ( set1 % block , & ibits ( set2 % block , & 0 , & set1 % num_bits ) ) end if end subroutine or_64 module subroutine output_64 ( self , unit , status ) ! !     Writes the components of the bitset, SELF, to the unformatted I/O !     unit, UNIT, in a unformatted sequence compatible with INPUT. If !     STATUS is absent an error results in an error stop with an !     informative stop code. If STATUS is present it has the default !     value of SUCCESS, or the value WRITE_FAILURE if the write failed. ! class ( bitset_64 ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status integer :: ierr character ( len = 120 ) :: message character ( * ), parameter :: procedure = \"OUTPUT\" write ( unit , iostat = ierr , iomsg = message ) self % num_bits if ( ierr /= 0 ) go to 999 if ( self % num_bits < 1 ) return write ( unit , iostat = ierr , iomsg = message ) self % block if ( ierr /= 0 ) go to 999 return 999 call error_handler ( 'Failure on a WRITE statement for UNIT.' , & write_failure , status , module_name , procedure ) end subroutine output_64 module subroutine read_bitset_string_64 ( self , string , status ) ! !     Uses the bitset literal in the default character `string`, to define !     the bitset, `self`. The literal may be preceded by an an arbitrary !     sequence of blank characters. If `status` is absent an error results !     in an error stop with an informative stop code. If `status` !     is present it has one of the values !     * `success` - if no problems occurred, !     * `alloc_fault` - if allocation of memory for SELF failed, !     * `array_size_invalid_error - if `bits(self)` in `string` is greater !       than 64 for a `bitset_64`, !     * `char_string_invalid_error` - if the bitset literal has an invalid !       character, !     * `char_string_too_small_error - if the string ends before all the bits !       are read. !     * `integer_overflow_error` - if the bitset literal has a `bits(self)` !       value too large to be represented, ! class ( bitset_64 ), intent ( out ) :: self character ( len =* ), intent ( in ) :: string integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , bits integer ( bits_kind ) :: digits , pos character ( * ), parameter :: procedure = \"READ_BITSET\" integer :: stat pos = 1 find_start : do pos = 1 , len ( string ) if ( string ( pos : pos ) /= ' ' ) exit end do find_start if ( pos > len ( string ) - 8 ) go to 999 if ( string ( pos : pos ) /= 's' . AND . string ( pos : pos ) /= 'S' ) go to 999 pos = pos + 1 bits = 0 digits = 0 do select case ( iachar ( string ( pos : pos ) ) ) case ( ia0 : ia9 ) digits = digits + 1 if ( digits == max_digits . AND . bits > overflow_bits ) & go to 996 if ( digits > max_digits ) go to 996 bits = bits * 10 + iachar ( string ( pos : pos ) ) - ia0 if ( bits < 0 ) go to 996 case ( iachar ( 'b' ), iachar ( 'B' )) exit case default go to 999 end select pos = pos + 1 end do if ( bits > 64 ) then call error_handler ( 'BITS in STRING was greater than 64.' , & char_string_too_large_error , status , & module_name , procedure ) return end if if ( bits + pos > len ( string ) ) then call error_handler ( 'STRING was too small for the number of ' // & 'bits specified by STRING.' , & char_string_too_small_error , status , & module_name , procedure ) return end if call self % init ( bits , stat ) if ( stat /= success ) then call error_handler ( 'There was an allocation fault for SELF.' , & alloc_fault , status , module_name , procedure ) return end if pos = pos + 1 bit = bits - 1 do if ( string ( pos : pos ) == '0' ) then call self % clear ( bit ) ! this may not be needed else if ( string ( pos : pos ) == '1' ) then call self % set ( bit ) else go to 999 end if pos = pos + 1 bit = bit - 1 if ( bit < 0 ) exit end do if ( present ( status ) ) status = success return 996 call error_handler ( 'There was an integer overflow in reading' // & 'size of bitset literal from UNIT' , & integer_overflow_error , status , & module_name , procedure ) return 999 call error_handler ( 'There was an invalid character in STRING' , & char_string_invalid_error , status , & module_name , procedure ) end subroutine read_bitset_string_64 module subroutine read_bitset_unit_64 ( self , unit , advance , status ) ! !     Uses the bitset literal at the current position in the formatted !     file with I/O unit, `unit`, to define the bitset, `self`. The literal !     may be preceded by an arbitrary sequence of blank characters. !     If `advance` is present it must be either 'YES' or 'NO'. If absent !     it has the default value of 'YES' to determine whether advancing !     I/O occurs. If `status` is absent an error results in an error stop !     with an informative stop code. If `status` is present it has one of !     the values: !     * `success` - if no problem occurred, !     * `alloc_fault` - if allocation of `self` failed, !     * `array_size_invalid_error` - if `bits(self)` in the bitset literal !       is greater than 64 for a `bitset_64`. !     * `char_string_invalid_error` - if the read of the bitset literal found !       an invalid character, !     * `eof_failure` - if a `read` statement reaches an end-of-file before !       completing the read of the bitset literal, !     * `integer_overflow_error` - if the bitset literal has a `bits(self)` !       value too large to be represented, !     * `read_failure` - if a `read` statement fails, ! class ( bitset_64 ), intent ( out ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , bits , digits integer :: ierr character ( len = 128 ) :: message character ( * ), parameter :: procedure = \"READ_BITSET\" character ( len = 1 ) :: char do read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char select case ( char ) case ( ' ' ) cycle case ( 's' , 'S' ) exit case default go to 999 end select end do bits = 0 digits = 0 do read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 998 , & end = 999 , & iostat = ierr , & iomsg = message ) char if ( char == 'b' . or . char == 'B' ) exit select case ( char ) case ( '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ) digits = digits + 1 if ( digits == max_digits . AND . bits > overflow_bits ) & go to 996 if ( digits > max_digits ) go to 996 bits = 10 * bits + iachar ( char ) - iachar ( '0' ) if ( bits < 0 ) go to 996 case default go to 999 end select end do if ( bits < 0 . OR . digits == 0 . OR . digits > max_digits ) go to 999 if ( bits > 64 ) then call error_handler ( 'BITS in UNIT was greater than 64.' , & array_size_invalid_error , status , & module_name , procedure ) return end if call self % init ( bits ) do bit = 1 , bits - 1 read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char if ( char == '0' ) then call self % clear ( bits - bit ) else if ( char == '1' ) then call self % set ( bits - bit ) else go to 999 end if end do if ( present ( advance ) ) then read ( unit , & advance = advance , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char else read ( unit , & advance = 'YES' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char end if if ( char == '0' ) then call self % clear ( bits - bit ) else if ( char == '1' ) then call self % set ( bits - bit ) else go to 999 end if if ( present ( status ) ) status = success return 996 call error_handler ( 'Integer overflow in reading size of ' // & 'bitset literal from UNIT.' , & read_failure , status , module_name , procedure ) return 997 call error_handler ( 'Failure on read of UNIT.' , & read_failure , status , module_name , procedure ) return 998 call error_handler ( 'End of File of UNIT before finishing a ' // & 'bitset literal.' , & eof_failure , status , module_name , procedure ) return 999 call error_handler ( 'Invalid character in bitset literal in UNIT ' , & char_string_invalid_error , status , & module_name , procedure ) end subroutine read_bitset_unit_64 elemental module subroutine set_bit_64 ( self , pos ) ! !     Sets the value at the POS position in SELF, provided the position is !     valid. If the position is less than 0 or greater than BITS(SELF)-1 !     then SELF is unchanged. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos integer ( block_kind ) :: dummy if ( pos < 0 . OR . pos > self % num_bits - 1 ) return dummy = ibset ( self % block , pos ) self % block = dummy end subroutine set_bit_64 pure module subroutine set_range_64 ( self , start_pos , stop_pos ) ! !     Sets all valid bits to 1 from the START_POS to the STOP_POS positions !     in SELF. If STOP_POA < START_POS no bits are changed. Positions outside !     the range 0 to BITS(SELF)-1 are ignored. ! class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: end_bit , start_bit start_bit = max ( 0_bits_kind , start_pos ) end_bit = min ( stop_pos , self % num_bits - 1 ) if ( end_bit < start_bit ) return !         FIRST and LAST are in the same block call mvbits ( all_ones , & start_bit , & end_bit - start_bit + 1 , & self % block , & start_bit ) end subroutine set_range_64 elemental module function test_64 ( self , pos ) result ( test ) ! !     Returns .TRUE. if the POS position is set, .FALSE. otherwise. If POS !     is negative or greater than BITS(SELF) - 1 the result is .FALSE.. ! logical :: test class ( bitset_64 ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos if ( pos < 0 . or . pos >= self % num_bits ) then test = . false . else test = btest ( self % block , pos ) end if end function test_64 module subroutine to_string_64 ( self , string , status ) ! !     Represents the value of SELF as a binary literal in STRING !     Status may have the values SUCCESS or ALLOC_FAULT ! class ( bitset_64 ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status character ( * ), parameter :: procedure = 'TO_STRING' integer :: bit , bit_count , pos , stat bit_count = self % num_bits allocate ( character ( len = bit_count ) :: string , stat = stat ) if ( stat > 0 ) then call error_handler ( 'There was an allocation fault for STRING.' , & alloc_fault , status , module_name , procedure ) return end if do bit = 0 , bit_count - 1 pos = bit_count - bit if ( btest ( self % block , bit ) ) then string ( pos : pos ) = '1' else string ( pos : pos ) = '0' end if end do if ( present ( status ) ) status = success end subroutine to_string_64 elemental module function value_64 ( self , pos ) result ( value ) ! !     Returns 1 if the POS position is set, 0 otherwise. If POS is negative !     or greater than BITS(SELF) - 1 the result is 0. ! integer :: value class ( bitset_64 ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos if ( pos < 0 . or . pos >= self % num_bits ) then value = 0 else if ( btest ( self % block , pos ) ) then value = 1 else value = 0 end if end if end function value_64 module subroutine write_bitset_string_64 ( self , string , status ) ! !     Writes a bitset literal to the allocatable default character STRING, !     representing the individual bit values in the bitset_t, SELF. !     If STATUS is absent an error results in an error stop with an !     informative stop code. If STATUS is present it has the default !     value of SUCCESS, or the value ALLOC_FAULT if allocation of !     the output string failed. ! class ( bitset_64 ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , & bit_count , & count_digits , & pos integer :: stat character ( * ), parameter :: procedure = 'WRITE_BITSET' bit_count = bits ( self ) call digit_count ( self % num_bits , count_digits ) allocate ( character ( len = count_digits + bit_count + 2 ) :: string , stat = stat ) if ( stat > 0 ) then call error_handler ( 'There was an allocation fault for STRING.' , & alloc_fault , status , module_name , procedure ) return end if write ( string , \"('S', i0)\" ) self % num_bits string ( count_digits + 2 : count_digits + 2 ) = \"B\" do bit = 0 , bit_count - 1 pos = count_digits + 2 + bit_count - bit if ( btest ( self % block , bit ) ) then string ( pos : pos ) = '1' else string ( pos : pos ) = '0' end if end do if ( present ( status ) ) status = success contains subroutine digit_count ( bits , digits ) integer ( bits_kind ), intent ( in ) :: bits integer ( bits_kind ), intent ( out ) :: digits integer ( bits_kind ) :: factor factor = bits if ( factor <= 0 ) then digits = 1 return end if do digits = 1 , 127 factor = factor / 10 if ( factor == 0 ) return end do end subroutine digit_count end subroutine write_bitset_string_64 module subroutine write_bitset_unit_64 ( self , unit , advance , status ) ! !     Writes a bitset literal to the I/O unit, UNIT, representing the !     individual bit values in the bitset_t, SELF. By default or if !     ADVANCE is present with the value 'YES', advancing output is used. !     If ADVANCE is present with the value 'NO', then the current record !     is not advanced by the write. If STATUS is absent an error results !     in an error stop with an informative stop code. If STATUS is !     present it has the default value of SUCCESS, the value !     ALLOC_FAULT if allocation of the output string failed, or !     WRITE_FAILURE if the WRITE statement outputting the literal failed. ! class ( bitset_64 ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status integer :: ierr character (:), allocatable :: string character ( len = 120 ) :: message character ( * ), parameter :: procedure = \"WRITE_BITSET\" call self % write_bitset ( string , status ) if ( present ( status ) ) then if ( status /= success ) return end if if ( present ( advance ) ) then write ( unit , & FMT = '(A)' , & advance = advance , & iostat = ierr , & iomsg = message ) & string else write ( unit , & FMT = '(A)' , & advance = 'YES' , & iostat = ierr , & iomsg = message ) & string end if if ( ierr /= 0 ) then call error_handler ( 'Failure on a WRITE statement for UNIT.' , & write_failure , status , module_name , procedure ) return endif end subroutine write_bitset_unit_64 elemental module subroutine xor_64 ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise XOR of the original bits in SET1 !     and SET2. SET1 and SET2 must have the same number of bits otherwise !     the result is undefined. ! type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 set1 % block = ieor ( set1 % block , & set2 % block ) end subroutine xor_64 end submodule stdlib_bitsets_64","tags":"","loc":"sourcefile/stdlib_bitsets_64.fypp.html"},{"title":"stdlib_stats_corr.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_corr.fypp~~EfferentGraph sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_corr Source Code stdlib_stats_corr.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_corr use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_linalg , only : diag use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_corr.fypp.html"},{"title":"stdlib_stats_cov.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_cov.fypp~~EfferentGraph sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_cov Source Code stdlib_stats_cov.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_cov use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_cov.fypp.html"},{"title":"common.fypp – Fortran-lang/stdlib","text":"Contents Source Code common.fypp Source Code #:mute #! Real kinds to be considered during templating #:set REAL_KINDS = [\"sp\", \"dp\", \"qp\"] #! Real types to be considered during templating #:set REAL_TYPES = [\"real({})\".format(k) for k in REAL_KINDS] #! Collected (kind, type) tuples for real types #:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES)) #! Complex kinds to be considered during templating #:set CMPLX_KINDS = [\"sp\", \"dp\", \"qp\"] #! Complex types to be considered during templating #:set CMPLX_TYPES = [\"complex({})\".format(k) for k in CMPLX_KINDS] #! Collected (kind, type) tuples for complex types #:set CMPLX_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES)) #! Integer kinds to be considered during templating #:set INT_KINDS = [\"int8\", \"int16\", \"int32\", \"int64\"] #! Integer types to be considered during templating #:set INT_TYPES = [\"integer({})\".format(k) for k in INT_KINDS] #! Collected (kind, type) tuples for integer types #:set INT_KINDS_TYPES = list(zip(INT_KINDS, INT_TYPES)) #! Logical kinds to be considered during templating #:set LOG_KINDS = [\"lk\", \"c_bool\"] #! Logical types to be considered during templating #:set LOG_TYPES = [\"logical({})\".format(k) for k in LOG_KINDS] #! Collected (kind, type) tuples for logical types #:set LOG_KINDS_TYPES = list(zip(LOG_KINDS, LOG_TYPES)) #! Derived type string_type #:set STRING_KINDS = [\"string_type\"] #! String types to be considered during templating #:set STRING_TYPES = [\"type({})\".format(k) for k in STRING_KINDS] #! Collected (kind, type) tuples for string derived types #:set STRING_KINDS_TYPES = list(zip(STRING_KINDS, STRING_TYPES)) #! Whether Fortran 90 compatible code should be generated #:set VERSION90 = defined('VERSION90') #! Ranks to be generated when templates are created #:if not defined('MAXRANK') # : if VERSION90 # : set MAXRANK = 7 # : else # : set MAXRANK = 15 # : endif #:endif #! Generates an array rank suffix. #! #! Args: #!     rank (int): Rank of the variable #! #! Returns: #!     Array rank suffix string (e.g. (:,:) if rank = 2) #! #:def ranksuffix(rank) #{if rank > 0}#(${\":\" + \",:\" * (rank - 1)}$)#{endif}# #:enddef #! Joins stripped lines with given character string #! #! Args: #!   txt (str): Text to process #!   joinstr (str): String to use as connector #!   prefix (str): String to add as prefix before the joined text #!   suffix (str): String to add as suffix after the joined text #! #! Returns: #!   Lines stripped and joined with the given string. #! #:def join_lines(txt, joinstr, prefix=\"\", suffix=\"\") ${ prefix + joinstr . join ([ line . strip () for line in txt . split ( \"\\n\" )]) + suffix }$ #:enddef #! Brace enclosed, comma separated Fortran expressions for a reduced shape. #! #! Rank of the original variable will be reduced by one. The routine generates #! for each dimension a Fortan expression using merge(), which calculates the #! size of the array for that dimension. #! #! Args: #!   varname (str): Name of the variable to be used as origin #!   origrank (int): Rank of the original variable #!   idim (int): Index of the reduced dimension #! #! Returns: #!   Shape expression enclosed in braces, so that it can be used as suffix to #!   define array shapes in declarations. #! #:def reduced_shape(varname, origrank, idim) # : assert origrank > 0 # : if origrank > 1 # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , origrank ) merge ( size ( ${ varname }$ , ${ i }$ ), size ( ${ varname }$ , ${ i + 1 }$ ), mask = ${ i }$ < ${ idim }$ ) # : endfor # : endcall # : endif #:enddef #! Generates a routine name from a generic name, rank, type and kind #! #! Args: #!   gname (str): Generic name #!   rank (integer): Rank if exist #!   type (str): Type of the input #!   kind (str): kind of inputs variable #!   suffix (str): other identifier (could be used for output type/kind) #! #! Returns: #!   A string with a new name #! #:def rname(gname, rank, type, kind, suffix='') $ : \"{0}_{1}_{2}{3}_{2}{3}\" . format ( gname , rank , type [ 0 ], kind ) if suffix == '' else \"{0}_{1}_{2}{3}_{4}\" . format ( gname , rank , type [ 0 ], kind , suffix ) #:enddef #! Generates an array rank suffix for subarrays reducing the dimension #! #! Args: #!   rank (int): Rank of the original variable #!   selectors (array): Dimension and name of the variable(s) #! #! Returns: #!   Array rank suffix string enclosed in braces #! #! E.g., #!   select_subarray(5 , [(4, 'i'), (5, 'j')])}$ #!   -> (:, :, :, i, j) #! #:def select_subarray(rank, selectors) # : assert rank > 0 # : set seldict = dict ( selectors ) # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , rank + 1 ) $ : seldict . get ( i , \":\" ) # : endfor # : endcall #:enddef #:endmute","tags":"","loc":"sourcefile/common.fypp.html"},{"title":"stdlib_stats_moment.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment.fypp~~EfferentGraph sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment Source Code stdlib_stats_moment.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , dim ), ${ k1 }$ ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , dim ), dp ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment.fypp.html"},{"title":"stdlib_linalg.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg.fypp~~EfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_linalg.fypp~~AfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_linalg_outer_product.fypp stdlib_linalg_outer_product.fypp sourcefile~stdlib_linalg_outer_product.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_linalg Source Code stdlib_linalg.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES module stdlib_linalg !!Provides a support for various linear algebra procedures !! ([Specification](../page/specs/stdlib_linalg.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private public :: diag public :: eye public :: trace public :: outer_product interface diag !! version: experimental !! !! Creates a diagonal array or extract the diagonal elements of an array !! ([Specification](../page/specs/stdlib_linalg.html#description)) ! ! Vector to matrix ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor ! ! Matrix to vector ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end interface ! Matrix trace interface trace !! version: experimental !! !! Computes the trace of a matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_2)) # : for k1 , t1 in RCI_KINDS_TYPES module procedure trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface ! Outer product (of two vectors) interface outer_product !! version: experimental !! !! Computes the outer product of two vectors, returning a rank-2 array !! ([Specification](../page/specs/stdlib_linalg.html#description_3)) # : for k1 , t1 in RCI_KINDS_TYPES pure module function outer_product_$ { t1 [ 0 ] }{ k1 }$ ( u , v ) result ( res ) ${ t1 }$ , intent ( in ) :: u (:), v (:) ${ t1 }$ :: res ( size ( u ), size ( v )) end function outer_product_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface outer_product contains function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye # : for k1 , t1 in RCI_KINDS_TYPES function trace_$ { t1 [ 0 ] }{ k1 }$ ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res integer :: i res = 0 do i = 1 , minval ( shape ( A )) res = res + A ( i , i ) end do end function trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end module","tags":"","loc":"sourcefile/stdlib_linalg.fypp.html"},{"title":"stdlib_string_type.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_string_type.fypp~~EfferentGraph sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_string_type.fypp~~AfferentGraph sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_strings.f90 stdlib_strings.f90 sourcefile~stdlib_strings.f90->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_sorting_ord_sort.fypp stdlib_sorting_ord_sort.fypp sourcefile~stdlib_sorting_ord_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort_index.fypp stdlib_sorting_sort_index.fypp sourcefile~stdlib_sorting_sort_index.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort.fypp stdlib_sorting_sort.fypp sourcefile~stdlib_sorting_sort.fypp->sourcefile~stdlib_sorting.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_string_type Source Code stdlib_string_type.fypp Source Code ! SPDX-Identifier: MIT #:include \"common.fypp\" !> Implementation of a string type to hold an arbitrary sequence of characters. !> !> This module provides string type compatible with all Fortran instrinsic character !> procedures as well as overloaded operators for working with character variables. !> !> A string type can be easily constructed by creating a new instance from a !> character variable or literal by invoking its constructor or by assigning it !> to a string type. Generally, the string type behaves similar to a deferred !> length character in most regards but adds memory access safety. !> !> The specification of this module is available [here](../page/specs/stdlib_string_type.html). module stdlib_string_type use stdlib_ascii , only : to_lower_ => to_lower , to_upper_ => to_upper , & & to_title_ => to_title , to_sentence_ => to_sentence , reverse_ => reverse , to_string use stdlib_kinds , only : int8 , int16 , int32 , int64 , lk , c_bool implicit none private public :: string_type public :: len , len_trim , trim , index , scan , verify , repeat , adjustr , adjustl public :: lgt , lge , llt , lle , char , ichar , iachar public :: to_lower , to_upper , to_title , to_sentence , reverse public :: assignment ( = ) public :: operator ( > ), operator ( >= ), operator ( < ), operator ( <= ) public :: operator ( == ), operator ( /= ), operator ( // ) public :: write ( formatted ), write ( unformatted ) public :: read ( formatted ), read ( unformatted ) integer , parameter :: long = selected_int_kind ( 18 ) !> String type holding an arbitrary sequence of characters. type :: string_type ! Use the sequence statement below as a hack to prevent extending this type. ! It is not used for storage association. sequence private character ( len = :), allocatable :: raw end type string_type !> Constructor for new string instances interface string_type module procedure :: new_string # : for kind in INT_KINDS module procedure :: new_string_from_integer_$ { kind }$ # : endfor # : for kind in LOG_KINDS module procedure :: new_string_from_logical_$ { kind }$ # : endfor end interface string_type !> Returns the length of the character sequence represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface len module procedure :: len_string end interface len !> Returns the length of the character sequence without trailing spaces !> represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface len_trim module procedure :: len_trim_string end interface len_trim !> Returns the character sequence hold by the string without trailing spaces. !> !> This method is elemental and returns a scalar character value. interface trim module procedure :: trim_string end interface trim !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustl module procedure :: adjustl_string end interface adjustl !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustr module procedure :: adjustr_string end interface adjustr !> Repeats the character sequence hold by the string by the number of !> specified copies. !> !> This method is elemental and returns a scalar character value. interface repeat module procedure :: repeat_string end interface repeat !> Returns the lowercase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> lowercase character sequence interface to_lower module procedure :: to_lower_string end interface to_lower !> Returns the uppercase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> uppercase character sequence interface to_upper module procedure :: to_upper_string end interface to_upper !> Returns the titlecase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> titlecase character sequence interface to_title module procedure :: to_title_string end interface to_title !> Returns the sentencecase version of the character sequence hold by the input string !> !> This method is elemental and returns a new string_type instance which holds this !> sentencecase character sequence interface to_sentence module procedure :: to_sentence_string end interface to_sentence !> Reverses the character sequence hold by the input string !> !> This method is elemental and returns a new string_type instance which holds this !> reverse character sequence interface reverse module procedure :: reverse_string end interface reverse !> Return the character sequence represented by the string. !> !> This method is elemental and returns a scalar character value. interface char module procedure :: char_string module procedure :: char_string_pos module procedure :: char_string_range end interface char !> Character-to-integer conversion function. !> !> This method is elemental and returns a default integer scalar value. interface ichar module procedure :: ichar_string end interface ichar !> Code in ASCII collating sequence. !> !> This method is elemental and returns a default integer scalar value. interface iachar module procedure :: iachar_string end interface iachar !> Position of a *substring* within a *string*. !> !> Returns the position of the start of the leftmost or rightmost occurrence !> of string *substring* in *string*, counting from one. If *substring* is not !> present in *string*, zero is returned. !> !> This method is elemental and returns a default integer scalar value. interface index module procedure :: index_string_string module procedure :: index_string_char module procedure :: index_char_string end interface index !> Scan a *string* for the presence of a *set* of characters. Scans a *string* for !> any of the characters in a *set* of characters. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is in *set*. If *back* is *true*, !> the rightmost position is returned. If no character of *set* is found in !> *string*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface scan module procedure :: scan_string_string module procedure :: scan_string_char module procedure :: scan_char_string end interface scan !> Scan a string for the absence of a set of characters. Verifies that all !> the characters in string belong to the set of characters in set. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is not in *set*. If *back* is *true*, !> the rightmost position is returned. If all characters of *string* are found !> in *set*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface verify module procedure :: verify_string_string module procedure :: verify_string_char module procedure :: verify_char_string end interface verify !> Lexically compare the order of two character sequences being greater, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lgt module procedure :: lgt_string_string module procedure :: lgt_string_char module procedure :: lgt_char_string end interface lgt !> Lexically compare the order of two character sequences being less, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface llt module procedure :: llt_string_string module procedure :: llt_string_char module procedure :: llt_char_string end interface llt !> Lexically compare the order of two character sequences being greater equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lge module procedure :: lge_string_string module procedure :: lge_string_char module procedure :: lge_char_string end interface lge !> Lexically compare the order of two character sequences being less equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lle module procedure :: lle_string_string module procedure :: lle_string_char module procedure :: lle_char_string end interface lle !> Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_string_char end interface assignment ( = ) !> Compare two character sequences for being greater, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( > ) module procedure :: gt_string_string module procedure :: gt_string_char module procedure :: gt_char_string end interface operator ( > ) !> Compare two character sequences for being less, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( < ) module procedure :: lt_string_string module procedure :: lt_string_char module procedure :: lt_char_string end interface operator ( < ) !> Compare two character sequences for being greater than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( >= ) module procedure :: ge_string_string module procedure :: ge_string_char module procedure :: ge_char_string end interface operator ( >= ) !> Compare two character sequences for being less than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( <= ) module procedure :: le_string_string module procedure :: le_string_char module procedure :: le_char_string end interface operator ( <= ) !> Compare two character sequences for equality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( == ) module procedure :: eq_string_string module procedure :: eq_string_char module procedure :: eq_char_string end interface operator ( == ) !> Compare two character sequences for inequality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( /= ) module procedure :: ne_string_string module procedure :: ne_string_char module procedure :: ne_char_string end interface operator ( /= ) !> Concatenate two character sequences, the left-hand side, the right-hand side !> or both character sequences can be represented by a string. !> !> This operator is elemental and returns a scalar character value. interface operator ( // ) module procedure :: concat_string_string module procedure :: concat_string_char module procedure :: concat_char_string end interface operator ( // ) !> Write the character sequence hold by the string to a connected formatted !> unit. interface write ( formatted ) module procedure :: write_formatted end interface !> Write the character sequence hold by the string to a connected unformatted !> unit. interface write ( unformatted ) module procedure :: write_unformatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( formatted ) module procedure :: read_formatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( unformatted ) module procedure :: read_unformatted end interface contains !> Constructor for new string instances from a scalar character value. elemental function new_string ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( string_type ) :: new if ( present ( string )) then new % raw = string end if end function new_string # : for kind in INT_KINDS !> Constructor for new string instances from an integer of kind ${kind}$. elemental function new_string_from_integer_$ { kind }$ ( val ) result ( new ) integer ( ${ kind }$ ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_integer_$ { kind }$ # : endfor # : for kind in LOG_KINDS !> Constructor for new string instances from a logical of kind ${kind}$. elemental function new_string_from_logical_$ { kind }$ ( val ) result ( new ) logical ( ${ kind }$ ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_logical_$ { kind }$ # : endfor !> Assign a character sequence to a string. elemental subroutine assign_string_char ( lhs , rhs ) type ( string_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs lhs % raw = rhs end subroutine assign_string_char !> Returns the length of the character sequence represented by the string. elemental function len_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length if ( allocated ( string % raw )) then length = len ( string % raw ) else length = 0 end if end function len_string !> Returns the length of the character sequence without trailing spaces !> represented by the string. elemental function len_trim_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length length = merge ( len_trim ( string % raw ), 0 , allocated ( string % raw )) end function len_trim_string !> Character-to-integer conversion function. elemental function ichar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . len ( string ) > 0 ) then ich = ichar ( string % raw ( 1 : 1 )) else ich = 0 end if end function ichar_string !> Code in ASCII collating sequence. elemental function iachar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . len ( string ) > 0 ) then ich = iachar ( string % raw ( 1 : 1 )) else ich = 0 end if end function iachar_string !> Return the character sequence represented by the string. pure function char_string ( string ) result ( character_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: character_string character_string = maybe ( string ) end function char_string !> Return the character sequence represented by the string. elemental function char_string_pos ( string , pos ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: pos character ( len = 1 ) :: character_string character_string = merge ( string % raw ( pos : pos ), ' ' , allocated ( string % raw )) end function char_string_pos !> Return the character sequence represented by the string. pure function char_string_range ( string , start , last ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: last character ( len = last - start + 1 ) :: character_string character_string = merge ( string % raw ( int ( start , long ): int ( last , long )), & repeat ( ' ' , int ( len ( character_string ), long )), allocated ( string % raw )) end function char_string_range !> Returns the character sequence hold by the string without trailing spaces. elemental function trim_string ( string ) result ( trimmed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: trimmed_string trimmed_string = trim ( maybe ( string )) end function trim_string !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustl_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustl ( maybe ( string )) end function adjustl_string !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustr_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustr ( maybe ( string )) end function adjustr_string !> Repeats the character sequence hold by the string by the number of !> specified copies. elemental function repeat_string ( string , ncopies ) result ( repeated_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( string_type ) :: repeated_string repeated_string = repeat ( maybe ( string ), ncopies ) end function repeat_string !> Convert the character sequence hold by the input string to lower case elemental function to_lower_string ( string ) result ( lowercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: lowercase_string lowercase_string % raw = to_lower_ ( maybe ( string )) end function to_lower_string !> Convert the character sequence hold by the input string to upper case elemental function to_upper_string ( string ) result ( uppercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: uppercase_string uppercase_string % raw = to_upper_ ( maybe ( string )) end function to_upper_string !> Convert the character sequence hold by the input string to title case elemental function to_title_string ( string ) result ( titlecase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: titlecase_string titlecase_string % raw = to_title_ ( maybe ( string )) end function to_title_string !> Convert the character sequence hold by the input string to sentence case elemental function to_sentence_string ( string ) result ( sentence_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: sentence_string sentence_string % raw = to_sentence_ ( maybe ( string )) end function to_sentence_string !> Reverse the character sequence hold by the input string elemental function reverse_string ( string ) result ( reversed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: reversed_string reversed_string % raw = reverse_ ( maybe ( string )) end function reverse_string !> Position of a sequence of character within a character sequence. !> In this version both character sequences are represented by a string. elemental function index_string_string ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = index ( maybe ( string ), maybe ( substring ), back ) else pos = index ( maybe ( string ), maybe ( substring ), . false .) end if end function index_string_string !> Position of a sequence of character within a character sequence. !> In this version the main character sequence is represented by a string. elemental function index_string_char ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = index ( maybe ( string ), substring , back ) else pos = index ( maybe ( string ), substring , . false .) end if end function index_string_char !> Position of a sequence of character within a character sequence. !> In this version the sub character sequence is represented by a string. elemental function index_char_string ( string , substring , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = index ( string , maybe ( substring ), back ) else pos = index ( string , maybe ( substring ), . false .) end if end function index_char_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version both the character sequence and the character set are !> represented by a string. elemental function scan_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = scan ( maybe ( string ), maybe ( set ), back ) else pos = scan ( maybe ( string ), maybe ( set ), . false .) end if end function scan_string_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version the character sequences is represented by a string. elemental function scan_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = scan ( maybe ( string ), set , back ) else pos = scan ( maybe ( string ), set , . false .) end if end function scan_string_char !> Scan a character sequence for any of the characters in a set of characters. !> In this version the set of characters is represented by a string. elemental function scan_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = scan ( string , maybe ( set ), back ) else pos = scan ( string , maybe ( set ), . false .) end if end function scan_char_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version both the character sequence and !> the character set are represented by a string. elemental function verify_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = verify ( maybe ( string ), maybe ( set ), back ) else pos = verify ( maybe ( string ), maybe ( set ), . false .) end if end function verify_string_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the character sequences is !> represented by a string. elemental function verify_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = verify ( maybe ( string ), set , back ) else pos = verify ( maybe ( string ), set , . false .) end if end function verify_string_char !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the set of characters is !> represented by a string. elemental function verify_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos if ( present ( back )) then pos = verify ( string , maybe ( set ), back ) else pos = verify ( string , maybe ( set ), . false .) end if end function verify_char_string !> Compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function gt_string_string ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > maybe ( rhs ) end function gt_string_string !> Compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function gt_string_char ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > rhs end function gt_string_char !> Compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function gt_char_string ( lhs , rhs ) result ( is_gt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = lhs > maybe ( rhs ) end function gt_char_string !> Compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function lt_string_string ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_string !> Compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function lt_string_char ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_char !> Compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function lt_char_string ( lhs , rhs ) result ( is_lt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_char_string !> Compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function ge_string_string ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_string !> Compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function ge_string_char ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_char !> Compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function ge_char_string ( lhs , rhs ) result ( is_ge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_char_string !> Compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function le_string_string ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_string !> Compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function le_string_char ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_char !> Compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function le_char_string ( lhs , rhs ) result ( is_le ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_char_string !> Compare two character sequences for equality. !> In this version both character sequences are by a string. elemental function eq_string_string ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_string_string !> Compare two character sequences for equality. !> In this version the left-hand side character sequences is by a string. elemental function eq_string_char ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_string_char !> Compare two character sequences for equality. !> In this version the right-hand side character sequences is by a string. elemental function eq_char_string ( lhs , rhs ) result ( is_eq ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_char_string !> Compare two character sequences for inequality. !> In this version both character sequences are by a string. elemental function ne_string_string ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_string !> Compare two character sequences for inequality. !> In this version the left-hand side character sequences is by a string. elemental function ne_string_char ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_char !> Compare two character sequences for inequality. !> In this version the right-hand side character sequences is by a string. elemental function ne_char_string ( lhs , rhs ) result ( is_ne ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_char_string !> Lexically compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function lgt_string_string ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), maybe ( rhs )) end function lgt_string_string !> Lexically compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function lgt_string_char ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), rhs ) end function lgt_string_char !> Lexically compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function lgt_char_string ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( lhs , maybe ( rhs )) end function lgt_char_string !> Lexically compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function llt_string_string ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), maybe ( rhs )) end function llt_string_string !> Lexically compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function llt_string_char ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), rhs ) end function llt_string_char !> Lexically compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function llt_char_string ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( lhs , maybe ( rhs )) end function llt_char_string !> Lexically compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function lge_string_string ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), maybe ( rhs )) end function lge_string_string !> Lexically compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function lge_string_char ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), rhs ) end function lge_string_char !> Lexically compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function lge_char_string ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( lhs , maybe ( rhs )) end function lge_char_string !> Lexically compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function lle_string_string ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), maybe ( rhs )) end function lle_string_string !> Lexically compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function lle_string_char ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), rhs ) end function lle_string_char !> Lexically compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function lle_char_string ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( lhs , maybe ( rhs )) end function lle_char_string !> Concatenate two character sequences. !> In this version both character sequences are by a string. elemental function concat_string_string ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( rhs ) // maybe ( lhs ) end function concat_string_string !> Concatenate two character sequences. !> In this version the left-hand side character sequences is by a string. elemental function concat_string_char ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( lhs ) // rhs end function concat_string_char !> Concatenate two character sequences. !> In this version the right-hand side character sequences is by a string. elemental function concat_char_string ( lhs , rhs ) result ( string ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = lhs // maybe ( rhs ) end function concat_char_string !> Write the character sequence hold by the string to a connected unformatted !> unit. subroutine write_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg write ( unit , iostat = iostat , iomsg = iomsg ) int ( len ( string ), long ) if ( iostat == 0 ) then write ( unit , iostat = iostat , iomsg = iomsg ) maybe ( string ) end if end subroutine write_unformatted !> Write the character sequence hold by the string to a connected formatted !> unit. subroutine write_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg select case ( iotype ) case ( \"LISTDIRECTED\" ) write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist output\" case default ! DT* select case ( size ( v_list )) case ( 0 ) ! DT write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case default error stop \"[Fatal] This implementation does not support v_list formatters\" end select end select end subroutine write_formatted !> Read a character sequence from a connected unformatted unit into the string. subroutine read_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: buffer integer ( long ) :: chunk read ( unit , iostat = iostat , iomsg = iomsg ) chunk if ( iostat == 0 ) then allocate ( character ( len = chunk ) :: buffer ) read ( unit , iostat = iostat , iomsg = iomsg ) buffer string % raw = buffer end if end subroutine read_unformatted !> Read a character sequence from a connected formatted unit into the string. subroutine read_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: line call unused_dummy_argument ( v_list ) select case ( iotype ) case ( \"LISTDIRECTED\" ) call read_line ( unit , line , iostat , iomsg ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist input\" case default ! DT* error stop \"[Fatal] This implementation does not support dt formatters\" end select string % raw = line contains !> Internal routine to read a whole record from a formatted unit subroutine read_line ( unit , line , iostat , iomsg ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: buffer_size = 512 character ( len = buffer_size ) :: buffer integer :: chunk line = '' do read ( unit , '(a)' , iostat = iostat , iomsg = iomsg , size = chunk , advance = 'no' ) & buffer if ( iostat > 0 ) exit line = line // buffer (: chunk ) if ( iostat < 0 ) exit end do if ( is_iostat_eor ( iostat )) then iostat = 0 end if end subroutine read_line end subroutine read_formatted !> Do nothing but mark an unused dummy argument as such to acknowledge compile !> time warning like: !> !>   Warning: Unused dummy argument ‘dummy’ at (1) [-Wunused-dummy-argument] !> !> We deeply trust in the compiler to inline and optimize this piece of code away. elemental subroutine unused_dummy_argument ( dummy ) class ( * ), intent ( in ) :: dummy associate ( dummy => dummy ); end associate end subroutine unused_dummy_argument !> Safely return the character sequences represented by the string pure function maybe ( string ) result ( maybe_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: maybe_string if ( allocated ( string % raw )) then maybe_string = string % raw else maybe_string = '' end if end function maybe end module stdlib_string_type","tags":"","loc":"sourcefile/stdlib_string_type.fypp.html"},{"title":"stdlib_stats_distribution_PRNG.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_distribution_prng.fypp~~EfferentGraph sourcefile~stdlib_stats_distribution_prng.fypp stdlib_stats_distribution_PRNG.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_stats_distribution_PRNG Source Code stdlib_stats_distribution_PRNG.fypp Source Code #:include \"common.fypp\" module stdlib_stats_distribution_PRNG use stdlib_kinds , only : int8 , int16 , int32 , int64 use stdlib_error , only : error_stop implicit none private integer , parameter :: MAX_INT_BIT_SIZE = bit_size ( 1_int64 ) integer ( int64 ) :: st ( 4 ) ! internal states for xoshiro256ss function integer ( int64 ) :: si = 614872703977525537_int64 ! default seed value logical :: seed_initialized = . false . public :: random_seed public :: dist_rand interface dist_rand !! Version experimental !! !! Generation of random integers with different kinds !! ([Specification](../page/specs/stdlib_stats_distribution_PRNG.html# !! description)) # : for k1 , t1 in INT_KINDS_TYPES module procedure dist_rand_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface dist_rand interface random_seed !! Version experimental !! !! Set seed value for random number generator !! ([Specification](../page/specs/stdlib_stats_distribution_PRNG.html# !! description)) !! # : for k1 , t1 in INT_KINDS_TYPES module procedure random_distribution_seed_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface random_seed contains # : for k1 , t1 in INT_KINDS_TYPES function dist_rand_$ { t1 [ 0 ] }{ k1 }$ ( n ) result ( res ) !! Random integer generation for various kinds !! result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind !! Result will be operated by bitwise operators to generate desired integer !! and real pseudorandom numbers !! ${ t1 }$ , intent ( in ) :: n ${ t1 }$ :: res integer :: k k = MAX_INT_BIT_SIZE - bit_size ( n ) if ( k < 0 ) call error_stop ( \"Error(dist_rand): Integer bit size is\" & // \" greater than 64bit\" ) res = shiftr ( xoshiro256ss ( ), k ) end function dist_rand_$ { t1 [ 0 ] }{ k1 }$ # : endfor function xoshiro256ss ( ) result ( res ) ! Generate random 64-bit integers ! Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org) ! http://prng.di.unimi.it/xoshiro256starstar.c ! ! This is xoshiro256** 1.0, one of our all-purpose, rock-solid ! generators. It has excellent (sub-ns) speed, a state (256 bits) that is ! large enough for any parallel application, and it passes all tests we ! are aware of. ! ! The state must be seeded so that it is not everywhere zero. If you have ! a 64-bit seed, we suggest to seed a splitmix64 generator and use its ! output to fill st. ! ! Fortran 90 version translated from C by Jim-215-Fisher ! integer ( int64 ) :: res , t if (. not . seed_initialized ) call random_distribution_seed_iint64 ( si , t ) res = rol64 ( st ( 2 ) * 5 , 7 ) * 9 t = shiftl ( st ( 2 ), 17 ) st ( 3 ) = ieor ( st ( 3 ), st ( 1 )) st ( 4 ) = ieor ( st ( 4 ), st ( 2 )) st ( 2 ) = ieor ( st ( 2 ), st ( 3 )) st ( 1 ) = ieor ( st ( 1 ), st ( 4 )) st ( 3 ) = ieor ( st ( 3 ), t ) st ( 4 ) = rol64 ( st ( 4 ), 45 ) end function xoshiro256ss pure function rol64 ( x , k ) result ( res ) integer ( int64 ), intent ( in ) :: x integer , intent ( in ) :: k integer ( int64 ) :: t1 , t2 , res t1 = shiftr ( x , ( 64 - k )) t2 = shiftl ( x , k ) res = ior ( t1 , t2 ) end function rol64 function splitmix64 ( s ) result ( res ) ! Written in 2015 by Sebastiano Vigna (vigna@acm.org) ! This is a fixed-increment version of Java 8's SplittableRandom ! generator. ! See http://dx.doi.org/10.1145/2714064.2660195 and ! http://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html ! ! It is a very fast generator passing BigCrush, and it can be useful if ! for some reason you absolutely want 64 bits of state. ! ! Fortran 90 translated from C by Jim-215-Fisher ! integer ( int64 ) :: res integer ( int64 ), intent ( in ), optional :: s integer ( int64 ) :: int01 = - 7046029254386353131_int64 , & int02 = - 4658895280553007687_int64 , & int03 = - 7723592293110705685_int64 ! Values are converted from C unsigned integer of 0x9e3779b97f4a7c15, ! 0xbf58476d1ce4e5b9, 0x94d049bb133111eb if ( present ( s )) si = s res = si si = res + int01 res = ieor ( res , shiftr ( res , 30 )) * int02 res = ieor ( res , shiftr ( res , 27 )) * int03 res = ieor ( res , shiftr ( res , 31 )) end function splitmix64 # : for k1 , t1 in INT_KINDS_TYPES subroutine random_distribution_seed_$ { t1 [ 0 ] }{ k1 }$ ( put , get ) !! Set seed value for random number generator !! ${ t1 }$ , intent ( in ) :: put ${ t1 }$ , intent ( out ) :: get integer ( int64 ) :: tmp integer :: i tmp = splitmix64 ( int ( put , kind = int64 )) do i = 1 , 10 tmp = splitmix64 ( ) end do do i = 1 , 4 tmp = splitmix64 ( ) st ( i ) = tmp end do get = int ( tmp , kind = ${ k1 }$ ) seed_initialized = . true . end subroutine random_distribution_seed_$ { t1 [ 0 ] }{ k1 }$ # : endfor end module stdlib_stats_distribution_PRNG","tags":"","loc":"sourcefile/stdlib_stats_distribution_prng.fypp.html"},{"title":"stdlib_specialfunctions.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_specialfunctions.f90~~EfferentGraph sourcefile~stdlib_specialfunctions.f90 stdlib_specialfunctions.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_specialfunctions.f90->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_specialfunctions.f90~~AfferentGraph sourcefile~stdlib_specialfunctions.f90 stdlib_specialfunctions.f90 sourcefile~stdlib_specialfunctions_legendre.f90 stdlib_specialfunctions_legendre.f90 sourcefile~stdlib_specialfunctions_legendre.f90->sourcefile~stdlib_specialfunctions.f90 sourcefile~stdlib_quadrature_gauss.f90 stdlib_quadrature_gauss.f90 sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_specialfunctions.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_specialfunctions Source Code stdlib_specialfunctions.f90 Source Code module stdlib_specialfunctions use stdlib_kinds , only : sp , dp , qp implicit none private public :: legendre public :: dlegendre interface legendre !! version: experimental !! !! Legendre polynomial pure elemental module function legendre_fp64 ( n , x ) result ( leg ) integer , intent ( in ) :: n real ( dp ), intent ( in ) :: x real ( dp ) :: leg end function end interface interface dlegendre !! version: experimental !! !! First derivative Legendre polynomial pure elemental module function dlegendre_fp64 ( n , x ) result ( dleg ) integer , intent ( in ) :: n real ( dp ), intent ( in ) :: x real ( dp ) :: dleg end function end interface end module stdlib_specialfunctions","tags":"","loc":"sourcefile/stdlib_specialfunctions.f90.html"},{"title":"stdlib_stats_moment_all.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment_all.fypp~~EfferentGraph sourcefile~stdlib_stats_moment_all.fypp stdlib_stats_moment_all.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment_all Source Code stdlib_stats_moment_all.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment_all use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res real ( ${ k1 }$ ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), ${ k1 }$ ) if ( present ( center )) then res = sum (( x - center ) ** order ) / n else res = sum (( x - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res real ( dp ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), dp ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order ) / n else res = sum (( real ( x , dp ) - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res real ( ${ k1 }$ ) :: n n = real ( count ( mask , kind = int64 ), ${ k1 }$ ) if ( present ( center )) then res = sum (( x - center ) ** order , mask ) / n else res = sum (( x - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res real ( dp ) :: n n = real ( count ( mask , kind = int64 ), dp ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order , mask ) / n else res = sum (( real ( x , dp ) - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment_all.fypp.html"},{"title":"stdlib_math_logspace.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_math_logspace.fypp~~EfferentGraph sourcefile~stdlib_math_logspace.fypp stdlib_math_logspace.fypp sourcefile~stdlib_math.fypp stdlib_math.fypp sourcefile~stdlib_math_logspace.fypp->sourcefile~stdlib_math.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_math.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_math_logspace Source Code stdlib_math_logspace.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_math ) stdlib_math_logspace implicit none contains # !========================================================= # !=     logspace(start, end)                              = # !========================================================= # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"default\" ) module procedure ${ RName }$ res = logspace ( start , end , DEFAULT_LOGSPACE_LENGTH , real ( DEFAULT_LOGSPACE_BASE , ${ k1 }$ )) end procedure # : endfor # ! Integer support # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"default\" ) module procedure ${ RName }$ res = logspace ( start , end , DEFAULT_LOGSPACE_LENGTH , DEFAULT_LOGSPACE_BASE ) end procedure # !========================================================= # !=     logspace(start, end, n)                           = # !========================================================= # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n\" ) module procedure ${ RName }$ res = logspace ( start , end , n , real ( DEFAULT_LOGSPACE_BASE , ${ k1 }$ )) end procedure # : endfor # ! Integer support # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n\" ) module procedure ${ RName }$ res = logspace ( start , end , n , DEFAULT_LOGSPACE_BASE ) end procedure # !========================================================= # !=     logspace(start, end, n, base)                     = # !========================================================= # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_rbase\" ) module procedure ${ RName }$ ${ t1 }$ :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_cbase\" ) module procedure ${ RName }$ ${ t1 }$ :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_ibase\" ) module procedure ${ RName }$ ${ t1 }$ :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure # : endfor # ! Integer support: ! Generate logarithmically spaced sequence from ${k1}$ base to the powers ! of ${k1}$ start and end. [base&#94;start, ... , base&#94;end] ! RName = ${RName}$ # : for k1 in REAL_KINDS # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_r\" + str ( k1 ) + \"base\" ) module procedure ${ RName }$ integer :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_c\" + str ( k1 ) + \"base\" ) module procedure ${ RName }$ integer :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure # : endfor # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_ibase\" ) module procedure ${ RName }$ integer :: exponents ( n ) exponents = linspace ( start , end , n ) res = base ** exponents end procedure end submodule","tags":"","loc":"sourcefile/stdlib_math_logspace.fypp.html"},{"title":"stdlib_bitsets.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_bitsets.fypp~~EfferentGraph sourcefile~stdlib_bitsets.fypp stdlib_bitsets.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_bitsets.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_bitsets.fypp~~AfferentGraph sourcefile~stdlib_bitsets.fypp stdlib_bitsets.fypp sourcefile~stdlib_bitsets_64.fypp stdlib_bitsets_64.fypp sourcefile~stdlib_bitsets_64.fypp->sourcefile~stdlib_bitsets.fypp sourcefile~stdlib_bitsets_large.fypp stdlib_bitsets_large.fypp sourcefile~stdlib_bitsets_large.fypp->sourcefile~stdlib_bitsets.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_bitsets Source Code stdlib_bitsets.fypp Source Code #:include \"common.fypp\" module stdlib_bitsets !! Implements zero based bitsets of size up to `huge(0_int32)`. !! The current code uses 64 bit integers to store the bits and uses all 64 bits. !! The code assumes two's complement integers, and treats negative integers as !! having the sign bit set. !!([Specification](../page/specs/stdlib_bitsets.html)) use :: stdlib_kinds , only : & bits_kind => int32 , & ! If changed change also max_digits, and block_kind => int64 , & ! overflow_bits int8 , & int16 , & int32 , & int64 use , intrinsic :: & iso_fortran_env , only : & error_unit implicit none private integer ( bits_kind ), parameter :: & block_size = bit_size ( 0_block_kind ) public :: max_digits , overflow_bits integer , parameter :: & max_digits = 10 ! bits_kind == int32 !        max_digits = 19 ! bits_kind == int64 integer ( bits_kind ), parameter :: & overflow_bits = 2_bits_kind ** 30 / 5 ! bits_kind == int32 !        overflow_bits = 2_bits_kind**62/5 ! bits_kind == int64 integer ( block_kind ), parameter :: all_zeros = 0_block_kind integer ( block_kind ), parameter :: all_ones = not ( all_zeros ) character ( * ), parameter :: module_name = \"STDLIB_BITSETS\" integer , parameter :: & ia0 = iachar ( '0' ), & ia9 = iachar ( '9' ) integer , parameter , public :: success = 0 !! Error flag indicating no errors integer , parameter , public :: alloc_fault = 1 !! Error flag indicating a memory allocation failure integer , parameter , public :: array_size_invalid_error = 2 !! Error flag indicating an invalid bits value integer , parameter , public :: char_string_invalid_error = 3 !! Error flag indicating an invalid character string integer , parameter , public :: char_string_too_large_error = 4 !! Error flag indicating a too large character string integer , parameter , public :: char_string_too_small_error = 5 !! Error flag indicating a too small character string integer , parameter , public :: eof_failure = 6 !! Error flag indicating unexpected End-of-File on a READ integer , parameter , public :: index_invalid_error = 7 !! Error flag indicating an invalid index integer , parameter , public :: integer_overflow_error = 8 !! Error flag indicating integer overflow integer , parameter , public :: read_failure = 9 !! Error flag indicating failure of a READ statement integer , parameter , public :: write_failure = 10 !! Error flag indicating a failure on a WRITE statement public :: bits_kind ! Public constant public :: & bitset_type , & bitset_large , & bitset_64 ! Public types public :: & assignment ( = ), & and , & and_not , & bits , & extract , & operator ( == ), & operator ( /= ), & operator ( > ), & operator ( >= ), & operator ( < ), & operator ( <= ), & or , & xor !! Public procedures public :: error_handler type , abstract :: bitset_type !! version: experimental !! !! Parent type for bitset_64 and bitset_large ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( bits_kind ) :: num_bits contains procedure ( all_abstract ), deferred , pass ( self ) :: all procedure ( any_abstract ), deferred , pass ( self ) :: any procedure ( bit_count_abstract ), deferred , pass ( self ) :: bit_count procedure , pass ( self ) :: bits procedure ( clear_bit_abstract ), deferred , pass ( self ) :: clear_bit procedure ( clear_range_abstract ), deferred , pass ( self ) :: clear_range generic :: clear => clear_bit , clear_range procedure ( flip_bit_abstract ), deferred , pass ( self ) :: flip_bit procedure ( flip_range_abstract ), deferred , pass ( self ) :: flip_range generic :: flip => flip_bit , flip_range procedure ( from_string_abstract ), deferred , pass ( self ) :: from_string procedure ( init_zero_abstract ), deferred , pass ( self ) :: init_zero generic :: init => init_zero procedure ( input_abstract ), deferred , pass ( self ) :: input procedure ( none_abstract ), deferred , pass ( self ) :: none procedure ( not_abstract ), deferred , pass ( self ) :: not procedure ( output_abstract ), deferred , pass ( self ) :: output procedure ( read_bitset_string_abstract ), deferred , pass ( self ) :: & read_bitset_string procedure ( read_bitset_unit_abstract ), deferred , pass ( self ) :: & read_bitset_unit generic :: read_bitset => read_bitset_string , read_bitset_unit procedure ( set_bit_abstract ), deferred , pass ( self ) :: set_bit procedure ( set_range_abstract ), deferred , pass ( self ) :: set_range generic :: set => set_bit , set_range procedure ( test_abstract ), deferred , pass ( self ) :: test procedure ( to_string_abstract ), deferred , pass ( self ) :: to_string procedure ( value_abstract ), deferred , pass ( self ) :: value procedure ( write_bitset_string_abstract ), deferred , pass ( self ) :: & write_bitset_string procedure ( write_bitset_unit_abstract ), deferred , pass ( self ) :: & write_bitset_unit generic :: write_bitset => write_bitset_string , write_bitset_unit end type bitset_type abstract interface elemental function all_abstract ( self ) result ( all ) !! Version: experimental !! !! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise. !! !!#### Example !! !!```fortran !!    program demo_all !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_all = '111111111111111111111111111111111' !!        type(bitset_64) :: set0 !!        call set0 % from_string( bits_all ) !!        if ( bits(set0) /= 33 ) then !!            error stop \"FROM_STRING failed to interpret \" // & !!                'BITS_ALL's size properly.\" !!        else if ( .not. set0 % all() ) then !!            error stop \"FROM_STRING failed to interpret\" // & !!                \"BITS_ALL's value properly.\" !!        else !!            write(*,*) \"FROM_STRING transferred BITS_ALL properly\" // & !!                \" into set0.\" !!        end if !!    end program demo_all !!``` import :: bitset_type logical :: all class ( bitset_type ), intent ( in ) :: self end function all_abstract elemental function any_abstract ( self ) result ( any ) !! Version: experimental !! !! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise. !! !!#### Example !! !!```fortran !!    program demo_any !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_0 = '0000000000000000000' !!        type(bitset_64) :: set0 !!        call set0 % from_string( bits_0 ) !!        if ( .not. set0 % any() ) then !!            write(*,*) \"FROM_STRING interpreted \" // & !!                \"BITS_0's value properly.\" !!        end if !!        call set0 % set(5) !!        if ( set0 % any() ) then !!            write(*,*) \"ANY interpreted SET0's value properly.\" !!        end if !!    end program demo_any !!``` import :: bitset_type logical :: any class ( bitset_type ), intent ( in ) :: self end function any_abstract elemental function bit_count_abstract ( self ) result ( bit_count ) !! Version: experimental !! !! Returns the number of non-zero bits in `self`. !! !!#### Example !! !!```fortran !!    program demo_bit_count !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_0 = '0000000000000000000' !!        type(bitset_64) :: set0 !!        call set0 % from_string( bits_0 ) !!        if ( set0 % bit_count() == 0 ) then !!            write(*,*) \"FROM_STRING interpreted \" // & !!                \"BITS_0's value properly.\" !!        end if !!        call set0 % set(5) !!        if ( set0 % bit_count() == 1 ) then !!            write(*,*) \"BIT_COUNT interpreted SET0's value properly.\" !!        end if !!    end program demo_bit_count !!``` import :: bitset_type , bits_kind integer ( bits_kind ) :: bit_count class ( bitset_type ), intent ( in ) :: self end function bit_count_abstract elemental subroutine clear_bit_abstract ( self , pos ) !! Version: experimental !! !! Sets to zero the `pos` position in `self`. If `pos` is less than zero or !! greater than `bits(self)-1` it is ignored. !! !!#### Example !! !!```fortran !!    program demo_clear !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        call set0 % not() !!        if ( set0 % all() ) write(*,*) 'SET0 is properly initialized.' !!        call set0 % clear(165) !!        if ( .not. set0 % test(165) ) write(*,*) 'Bit 165 is cleared.' !!        call set0 % clear(0,164) !!        if ( set0 % none() ) write(*,*) 'All bits are cleared.' !!    end program demo_clear !!``` import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine clear_bit_abstract pure subroutine clear_range_abstract ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `set`. !! If `stop_pos < start_pos` then no bits are modified. Positions outside !! the range 0 to `bits(self)-1` are ignored. import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine clear_range_abstract elemental subroutine flip_bit_abstract ( self , pos ) !! Version: experimental !! !! Flips the value at the `pos` position in `self`, provided the position is !! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is !! changed. !! !!#### Example !! !!```fortran !!    program demo_flip !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        if ( set0 % none() ) write(*,*) 'SET0 is properly initialized.' !!        call set0 % flip(165) !!        if ( set0 % test(165) ) write(*,*) 'Bit 165 is flipped.' !!        call set0 % flip(0,164) !!        if ( set0 % all() ) write(*,*) 'All bits are flipped.' !!    end program demo_flip !!``` import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine flip_bit_abstract pure subroutine flip_range_abstract ( self , start_pos , stop_pos ) !! Version: experimental !! !! Flips all valid bits from the `start_pos` to the `stop_pos` positions in !! `self`. If `stop_pos < start_pos` no bits are flipped. Positions less than !! 0 or greater than `bits(self)-1` are ignored. import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine flip_range_abstract subroutine from_string_abstract ( self , string , status ) !! Version: experimental !! !! Initializes the bitset `self` treating `string` as a binary literal !! `status` may have the values: !! * `success` - if no problems were found, !! * `alloc_fault` - if allocation of the bitset failed !! * `char_string_too_large_error` - if `string` was too large, or !! * `char_string_invalid_error` - if string had an invalid character. !! !!#### Example !! !!```fortran !!    program demo_from_string !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_all = '111111111111111111111111111111111' !!        type(bitset_64) :: set0 !!        call set0 % from_string( bits_all ) !!        if ( bits(set0) /= 33 ) then !!            error stop \"FROM_STRING failed to interpret \" // & !!                'BITS_ALL's size properly.\" !!        else if ( .not. set0 % all() ) then !!            error stop \"FROM_STRING failed to interpret\" // & !!                \"BITS_ALL's value properly.\" !!        else !!            write(*,*) \"FROM_STRING transferred BITS_ALL properly\" // & !!                \" into set0.\" !!        end if !!    end program demo_from_string !!``` import :: bitset_type class ( bitset_type ), intent ( out ) :: self character ( * ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine from_string_abstract subroutine init_zero_abstract ( self , bits , status ) !! Creates the bitset, `self`, of size `bits`, with all bits initialized to !! zero. `bits` must be non-negative.  If an error occurs and `status` is !! absent then processing stops with an informative stop code. `status` !! will have one of the values; !! * `success` -  if no problems were found, !! * `alloc_fault` - if memory allocation failed !! * `array_size_invalid_error` - if `bits` is either negative or larger !!   than 64 with `self` of class `bitset_64`, or !! !!#### Example !! !!```fortran !!    program demo_init !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        if ( set0 % bits() == 166 ) & !!            write(*,*) `SET0 has the proper size.' !!        if ( set0 % none() ) write(*,*) 'SET0 is properly initialized.' !!    end program demo_init !!``` import :: bitset_type , bits_kind class ( bitset_type ), intent ( out ) :: self integer ( bits_kind ), intent ( in ) :: bits integer , intent ( out ), optional :: status end subroutine init_zero_abstract subroutine input_abstract ( self , unit , status ) !! Version: experimental !! !! Reads the components of the bitset, `self`, from the unformatted I/O !! unit, `unit`, assuming that the components were written using `output`. !! If an error occurs and `status` is absent then processing stops with !! an informative stop code. `status` has one of the values: !! * `success` - if no problem was found !! * `alloc_fault` - if it failed allocating memory for `self`, or !! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative !!   or greater than 64 for a `bitset_64` input. !! * `read_failure` - if it failed during the reads from `unit` !! !!#### Example !! !!```fortran !!    program demo_input !!        character(*), parameter :: & !!            bits_0   = '000000000000000000000000000000000', & !!            bits_1   = '000000000000000000000000000000001', & !!            bits_33  = '100000000000000000000000000000000' !!        integer :: unit !!        type(bitset_64) :: set0, set1, set2, set3, set4, set5 !!        call set0 % from_string( bits_0 ) !!        call set1 % from_string( bits_1 ) !!        call set2 % from_string( bits_33 ) !!        open( newunit=unit, file='test.bin', status='replace', & !!            form='unformatted', action='write' ) !!        call set2 % output(unit) !!        call set1 % output(unit) !!        call set0 % output(unit) !!        close( unit ) !!        open( newunit=unit, file='test.bin', status='old', & !!            form='unformatted', action='read' ) !!        call set5 % input(unit) !!        call set4 % input(unit) !!        call set3 % input(unit) !!        close( unit ) !!        if ( set3 /= set0 .or. set4 /= set1 .or. set5 /= set2 ) then !!            error stop 'Transfer to and from units using ' // & !!                ' output and input failed.' !!        else !!            write(*,*) 'Transfer to and from units using ' // & !!                'output and input succeeded.' !!        end if !!    end program demo_input !!``` import :: bitset_type class ( bitset_type ), intent ( out ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine input_abstract elemental function none_abstract ( self ) result ( none ) !! Version: experimental !! !! Returns `.true.` if none of the bits in `self` have the value 1. !! !!#### Example !! !!```fortran !!    program demo_none !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_0 = '0000000000000000000' !!        type(bitset_large) :: set0 !!        call set0 % from_string( bits_0 ) !!        if ( set0 % none() ) then !!            write(*,*) \"FROM_STRING interpreted \" // & !!                \"BITS_0's value properly.\" !!        end if !!        call set0 % set(5) !!        if ( .not. set0 % none() ) then !!            write(*,*) \"NONE interpreted SET0's value properly.\" !!        end if !!    end program demo_none !!``` import :: bitset_type logical :: none class ( bitset_type ), intent ( in ) :: self end function none_abstract elemental subroutine not_abstract ( self ) !! Version: experimental !! !! Sets the bits in `self` to their logical complement !! !!#### Example !! !!```fortran !!    program demo_not !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init( 155 ) !!        if ( set0 % none() ) then !!            write(*,*) \"FROM_STRING interpreted \" // & !!                \"BITS_0's value properly.\" !!        end if !!        call set0 % not() !!        if ( set0 % all() ) then !!            write(*,*) \"ALL interpreted SET0's value properly.\" !!        end if !!    end program demo_not !!``` import :: bitset_type class ( bitset_type ), intent ( inout ) :: self end subroutine not_abstract subroutine output_abstract ( self , unit , status ) !! Version: experimental !! !! Writes the components of the bitset, `self`, to the unformatted I/O !! unit, `unit`, in a unformatted sequence compatible with `input`. If !! `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success`, or the value `write_failure` if the write failed. !! !!#### Example !! !!```fortran !!    program demo_output !!        character(*), parameter :: & !!            bits_0   = '000000000000000000000000000000000', & !!            bits_1   = '000000000000000000000000000000001', & !!            bits_33  = '100000000000000000000000000000000' !!        integer :: unit !!        type(bitset_64) :: set0, set1, set2, set3, set4, set5 !!        call set0 % from_string( bits_0 ) !!        call set1 % from_string( bits_1 ) !!        call set2 % from_string( bits_33 ) !!        open( newunit=unit, file='test.bin', status='replace', & !!            form='unformatted', action='write' ) !!        call set2 % output(unit) !!        call set1 % output(unit) !!        call set0 % output(unit) !!        close( unit ) !!        open( newunit=unit, file='test.bin', status='old', & !!            form='unformatted', action='read' ) !!        call set5 % input(unit) !!        call set4 % input(unit) !!        call set3 % input(unit) !!        close( unit ) !!        if ( set3 /= set0 .or. set4 /= set1 .or. set5 /= set2 ) then !!            error stop 'Transfer to and from units using ' // & !!                ' output and input failed.' !!        else !!            write(*,*) 'Transfer to and from units using ' // & !!                'output and input succeeded.' !!        end if !!    end program demo_output !!``` import :: bitset_type class ( bitset_type ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine output_abstract subroutine read_bitset_string_abstract ( self , string , status ) !! Version: experimental !! !! Uses the bitset literal in the default character `string`, to define !! the bitset, `self`. The literal may be preceded by an an arbitrary !! sequence of blank characters. If `status` is absent an error results !! in an error stop with an informative stop code. If `status` !! is present it has one of the values !! * `success` - if no problems occurred, !! * `alloc_fault` - if allocation of memory for SELF failed, !! * `array_size_invalid_error - if `bits(self)` in `string` is greater !!   than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the bitset literal has an invalid !!   character, !! * `char_string_too_small_error - if the string ends before all the bits !!   are read. !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, !! !!#### Example !! !!```fortran !!    program demo_read_bitset !!        character(*), parameter :: & !!            bits_0   = 'S33B000000000000000000000000000000000', & !!            bits_1   = 'S33B000000000000000000000000000000001', & !!            bits_33  = 'S33B100000000000000000000000000000000' !!        character(:), allocatable :: test_0, test_1, test_2 !!        integer :: unit !!        type(bitset_64) :: set0, set1, set2, set3, set4, set5 !!        call set0 % read_bitset( bits_0, status ) !!        call set1 % read_bitset( bits_1, status ) !!        call set2 % read_bitset( bits_2, status ) !!        call set0 % write_bitset( test_0, status ) !!        call set1 % write_bitset( test_1, status ) !!        call set2 % write_bitset( test_2, status ) !!        if ( bits_0 == test_0 .and. bits_1 == test_1 .and. & !!            bits_2 == test_2 ) then !!            write(*,*) 'READ_BITSET to WRITE_BITSET strings worked.' !!        end if !!        open( newunit=unit, file='test.txt', status='replace', & !!            form='formatted', action='write' ) !!        call set2 % write_bitset(unit, advance='no') !!        call set1 % write_bitset(unit, advance='no') !!        call set0 % write_bitset(unit) !!        close( unit ) !!        open( newunit=unit, file='test.txt', status='old', & !!            form='formatted', action='read' ) !!        call set3 % read_bitset(unit, advance='no') !!        call set4 % read_bitset(unit, advance='no') !!        call set5 % read_bitset(unit) !!        if ( set3 == set0 .and. set4 == set1 .and. set5 == set2 ) then !!            write(*,*) WRITE_BITSET to READ_BITSET through unit worked.' !!        end if !!    end program demo_read_bitset !!``` import :: bitset_type class ( bitset_type ), intent ( out ) :: self character ( len =* ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine read_bitset_string_abstract subroutine read_bitset_unit_abstract ( self , unit , advance , status ) !! Version: experimental !! !! Uses the bitset literal at the current position in the formatted !! file with I/O unit, `unit`, to define the bitset, `self`. The literal !! may be preceded by an an arbitrary sequence of blank characters. !! If `advance` is present it must be either 'YES' or 'NO'. If absent !! it has the default value of 'YES' to determine whether advancing !! I/O occurs. If `status` is absent an error results in an error stop !! with an informative stop code. If `status` is present it has one of !! the values: !! * `success` - if no problem occurred, !! * `alloc_fault` - if allocation of `self` failed, !! * `array_size_invalid_error` - if `bits(self)` in the bitset literal !!   is greater than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the read of the bitset literal found !!   an invalid character, !! * `eof_failure` - if a `read` statement reached an end-of-file before !!   completing the read of the bitset literal, !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, !! * `read_failure` - if a `read` statement fails, ! import :: bitset_type class ( bitset_type ), intent ( out ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine read_bitset_unit_abstract elemental subroutine set_bit_abstract ( self , pos ) !! Version: experimental !! !! Sets the value at the `pos` position in `self`, provided the position is !! valid. If the position is less than 0 or greater than `bits(self)-1` !! then `self` is unchanged. !! !!#### Example !! !!```fortran !!    program demo_set !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        if ( set0 % none() ) write(*,*) 'SET0 is properly initialized.' !!        call set0 % set(165) !!        if ( set0 % test(165) ) write(*,*) 'Bit 165 is set.' !!        call set0 % set(0,164) !!        if ( set0 % all() ) write(*,*) 'All bits are set.' !!    end program demo_set !!``` import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine set_bit_abstract pure subroutine set_range_abstract ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions !! in `self`. If `stop_pos < start_pos` no bits are changed. Positions outside !! the range 0 to `bits(self)-1` are ignored. import :: bitset_type , bits_kind class ( bitset_type ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine set_range_abstract elemental function test_abstract ( self , pos ) result ( test ) !! Version: experimental !! !! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos` !! is negative or greater than `bits(self) - 1` the result is `.false.`. !! !!#### Example !! !!```fortran !!    program demo_test !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        call set0 % not() !!        if ( set0 % all() ) write(*,*) 'SET0 is properly initialized.' !!        call set0 % clear(165) !!        if ( .not. set0 % test(165) ) write(*,*) 'Bit 165 is cleared.' !!        call set0 % set(165) !!        if ( set0 % test(165) ) write(*,*) 'Bit 165 is set.' !!    end program demo_test !!``` import :: bitset_type , bits_kind logical :: test class ( bitset_type ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function test_abstract subroutine to_string_abstract ( self , string , status ) !! Version: experimental !! !! Represents the value of `self` as a binary literal in `string` !! Status may have the values `success` or `alloc_fault`. !! !!#### Example !! !!```fortran !!    program demo_to_string !!        use stdlib_bitsets !!        character(*), parameter :: & !!            bits_all = '111111111111111111111111111111111' !!        type(bitset_64) :: set0 !!        character(:), allocatable :: new_string !!        call set0 % init(33) !!        call set0 % not() !!        call set0 % to_string( new_string ) !!        if ( new_string == bits_all ) then !!            write(*,*) \"TO_STRING transferred BITS0 properly\" // & !!                \" into NEW_STRING.\" !!        end if !!    end program demo_to_string !!``` import :: bitset_type class ( bitset_type ), intent ( in ) :: self character (:), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine to_string_abstract elemental function value_abstract ( self , pos ) result ( value ) !! Version: experimental !! !! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative !! or greater than `bits(set) - 1` the result is 0. !! !!#### Example !! !!```fortran !!    program demo_value !!        use stdlib_bitsets !!        type(bitset_large) :: set0 !!        call set0 % init(166) !!        call set0 % not() !!        if ( set0 % all() ) write(*,*) 'SET0 is properly initialized.' !!        call set0 % clear(165) !!        if ( set0 % value(165) == 0 ) write(*,*) 'Bit 165 is cleared.' !!        call set0 % set(165) !!        if ( set0 % value(165) == 1 ) write(*,*) 'Bit 165 is set.' !!    end program demo_value !!``` import :: bitset_type , bits_kind integer :: value class ( bitset_type ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function value_abstract subroutine write_bitset_string_abstract ( self , string , status ) !! Version: experimental !! !! Writes a bitset literal to the allocatable default character `string`, !! representing the individual bit values in the `bitset_type`, `self`. !! If `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success`, or the value `alloc_fault` if allocation of !! the output string failed. !! !!#### Example !! !!```fortran !!    program demo_write_bitset !!        character(*), parameter :: & !!            bits_0   = 'S33B000000000000000000000000000000000', & !!            bits_1   = 'S33B000000000000000000000000000000001', & !!            bits_33  = 'S33B100000000000000000000000000000000' !!        character(:), allocatable :: test_0, test_1, test_2 !!        integer :: unit !!        type(bitset_64) :: set0, set1, set2, set3, set4, set5 !!        call set0 % read_bitset( bits_0, status ) !!        call set1 % read_bitset( bits_1, status ) !!        call set2 % read_bitset( bits_2, status ) !!        call set0 % write_bitset( test_0, status ) !!        call set1 % write_bitset( test_1, status ) !!        call set2 % write_bitset( test_2, status ) !!        if ( bits_0 == test_0 .and. bits_1 == test_1 .and. & !!            bits_2 == test_2 ) then !!            write(*,*) 'READ_BITSET to WRITE_BITSET strings worked.' !!        end if !!        open( newunit=unit, file='test.txt', status='replace', & !!            form='formatted', action='write' ) !!        call set2 % write_bitset(unit, advance='no') !!        call set1 % write_bitset(unit, advance='no') !!        call set0 % write_bitset(unit) !!        close( unit ) !!        open( newunit=unit, file='test.txt', status='old', & !!            form='formatted', action='read' ) !!        call set3 % read_bitset(unit, advance='no') !!        call set4 % read_bitset(unit, advance='no') !!        call set5 % read_bitset(unit) !!        if ( set3 == set0 .and. set4 == set1 .and. set5 == set2 ) then !!            write(*,*) WRITE_BITSET to READ_BITSET through unit worked.' !!        end if !!    end program demo_write_bitset !!``` import :: bitset_type class ( bitset_type ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine write_bitset_string_abstract subroutine write_bitset_unit_abstract ( self , unit , advance , & status ) !! Version: experimental !! !! Writes a bitset literal to the I/O unit, `unit`, representing the !! individual bit values in the `bitset_t`, `self`. If an error occurs then !! processing stops with a message to `error_unit`. By default or if !! `advance` is present with the value 'YES', advancing output is used. !! If `advance` is present with the value 'NO', then the current record !! is not advanced by the write. If `status` is absent, an error results !! in an error stop with an informative stop code. If `status` is !! present it has the default value of `success`, the value !! `alloc_fault` if allocation of the output string failed, !! `write_failure` if the `write` statement outputting the literal failed. import :: bitset_type class ( bitset_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine write_bitset_unit_abstract end interface type , extends ( bitset_type ) :: bitset_large !! Version: experimental !! !! Type for bitsets with more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( block_kind ), private , allocatable :: blocks (:) contains procedure , pass ( self ) :: all => all_large procedure , pass ( self ) :: any => any_large procedure , pass ( self ) :: bit_count => bit_count_large procedure , pass ( self ) :: clear_bit => clear_bit_large procedure , pass ( self ) :: clear_range => clear_range_large procedure , pass ( self ) :: flip_bit => flip_bit_large procedure , pass ( self ) :: flip_range => flip_range_large procedure , pass ( self ) :: from_string => from_string_large procedure , pass ( self ) :: init_zero => init_zero_large procedure , pass ( self ) :: input => input_large procedure , pass ( self ) :: none => none_large procedure , pass ( self ) :: not => not_large procedure , pass ( self ) :: output => output_large procedure , pass ( self ) :: & read_bitset_string => read_bitset_string_large procedure , pass ( self ) :: read_bitset_unit => read_bitset_unit_large procedure , pass ( self ) :: set_bit => set_bit_large procedure , pass ( self ) :: set_range => set_range_large procedure , pass ( self ) :: test => test_large procedure , pass ( self ) :: to_string => to_string_large procedure , pass ( self ) :: value => value_large procedure , pass ( self ) :: & write_bitset_string => write_bitset_string_large procedure , pass ( self ) :: write_bitset_unit => write_bitset_unit_large end type bitset_large interface elemental module function all_large ( self ) result ( all ) !! Version: experimental !! !! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise. logical :: all class ( bitset_large ), intent ( in ) :: self end function all_large elemental module function any_large ( self ) result ( any ) !! Version: experimental !! !! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise. logical :: any class ( bitset_large ), intent ( in ) :: self end function any_large elemental module function bit_count_large ( self ) result ( bit_count ) !! Version: experimental !! !! Returns the number of non-zero bits in `self`. integer ( bits_kind ) :: bit_count class ( bitset_large ), intent ( in ) :: self end function bit_count_large elemental module subroutine clear_bit_large ( self , pos ) !! Version: experimental !! !! Sets to zero the bit at `pos` position in `self`. If `pos` is less than !! zero or greater than `bits(self)-1` it is ignored. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine clear_bit_large pure module subroutine clear_range_large ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `self`. !! If `stop_pos < start_pos` then no bits are modified. Positions outside !! the range 0 to `bits(set)-1` are ignored. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine clear_range_large elemental module subroutine flip_bit_large ( self , pos ) !! Version: experimental !! !! Flips the bit value at the `pos` position in `self`, provided the position is !! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is !! changed. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine flip_bit_large pure module subroutine flip_range_large ( self , start_pos , stop_pos ) !! Version: experimental !! !! Flips all valid bits from the `start_pos` to the `stop_pos` positions in !! `self`. If `stop_pos < start_pos` no bits are flipped. Positions less than !! 0 or greater than `bits(self)-1` are ignored. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine flip_range_large module subroutine from_string_large ( self , string , status ) !! Version: experimental !! !! Initializes the bitset `self` treating `string` as a binary literal !! `status` may have the values: !! * `success` - if no problems were found, !! * `alloc_fault` - if allocation of the bitset failed !! * `char_string_too_large_error` - if `string` was too large, or !! * `char_string_invalid_error` - if string had an invalid character. class ( bitset_large ), intent ( out ) :: self character ( * ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine from_string_large module subroutine init_zero_large ( self , bits , status ) !! Version: experimental !! !! Creates the bitset, `self`, of size `bits`, with all bits initialized to !! zero. `bits` must be non-negative.  If an error occurs and `status` is !! absent then processing stops with an informative stop code. `status` !! will have one of the values; !! * `success` -  if no problems were found, !! * `alloc_fault` - if memory allocation failed !! * `array_size_invalid_error` - if `bits` is either negative or larger !!   than 64 with `self` of class `bitset_64`, or class ( bitset_large ), intent ( out ) :: self integer ( bits_kind ), intent ( in ) :: bits integer , intent ( out ), optional :: status end subroutine init_zero_large module subroutine input_large ( self , unit , status ) !! Version: experimental !! !! Reads the components of the bitset, `self`, from the unformatted I/O !! unit, `unit`, assuming that the components were written using `output`. !! If an error occurs and `status` is absent then processing stops with !! an informative stop code. `status` has one of the values: !! * `success` - if no problem was found !! * `alloc_fault` - if it failed allocating memory for `self`, or !! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative !!   or greater than 64 for a `bitset_64` input. !! * `read_failure` - if it failed during the reads from `unit` class ( bitset_large ), intent ( out ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine input_large elemental module function none_large ( self ) result ( none ) !! Version: experimental !! !! Returns `.true.` if none of the bits in `self` have the value 1. logical :: none class ( bitset_large ), intent ( in ) :: self end function none_large elemental module subroutine not_large ( self ) !! Version: experimental !! !! Sets the bits in `self` to their logical complement class ( bitset_large ), intent ( inout ) :: self end subroutine not_large module subroutine output_large ( self , unit , status ) !! Version: experimental !! !! Writes the components of the bitset, `self`, to the unformatted I/O !! unit, `unit`, in a unformatted sequence compatible with `input`. If !! `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success`, or the value `write_failure` if the write failed. class ( bitset_large ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine output_large module subroutine read_bitset_string_large ( self , string , status ) !! Version: experimental !! !! Uses the bitset literal in the default character `string`, to define !! the bitset, `self`. The literal may be preceded by an an arbitrary !! sequence of blank characters. If `status` is absent an error results !! in an error stop with an informative stop code. If `status` !! is present it has one of the values !! * `success` - if no problems occurred, !! * `alloc_fault` - if allocation of memory for SELF failed, !! * `array_size_invalid_error - if `bits(self)` in `string` is greater !!   than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the bitset literal has an invalid !!   character, !! * `char_string_too_small_error - if the string ends before all the bits !!   are read. !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, class ( bitset_large ), intent ( out ) :: self character ( len =* ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine read_bitset_string_large module subroutine read_bitset_unit_large ( self , unit , advance , status ) !! Version: experimental !! !! Uses the bitset literal at the current position in the formatted !! file with I/O unit, `unit`, to define the bitset, `self`. The literal !! may be preceded by an an arbitrary sequence of blank characters. !! If `advance` is present it must be either 'YES' or 'NO'. If absent !! it has the default value of 'YES' to determine whether advancing !! I/O occurs. If `status` is absent an error results in an error stop !! with an informative stop code. If `status` is present it has one of !! the values: !! * `success` - if no problem occurred, !! * `alloc_fault` - if allocation of `self` failed, !! * `array_size_invalid_error` - if `bits(self)` in the bitset literal !!   is greater than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the read of the bitset literal found !!   an invalid character, !! * `eof_failure` - if a `read` statement reached an end-of-file before !!   completing the read of the bitset literal, !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, !! * `read_failure` - if a `read` statement fails, class ( bitset_large ), intent ( out ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine read_bitset_unit_large elemental module subroutine set_bit_large ( self , pos ) !! Version: experimental !! !! Sets the value at the `pos` position in `self`, provided the position is !! valid. If the position is less than 0 or greater than `bits(self)-1` !! then `self` is unchanged. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine set_bit_large pure module subroutine set_range_large ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions !! in `self`. If `stop_pos < start_pos` no bits are changed. Positions outside !! the range 0 to `bits(self)-1` are ignored. class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine set_range_large elemental module function test_large ( self , pos ) result ( test ) !! Version: experimental !! !! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos` !! is negative or greater than `bits(self) - 1` the result is `.false.`. logical :: test class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function test_large module subroutine to_string_large ( self , string , status ) !! Version: experimental !! !! Represents the value of `self` as a binary literal in `string` !! Status may have the values `success` or `alloc_fault`. class ( bitset_large ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine to_string_large elemental module function value_large ( self , pos ) result ( value ) !! Version: experimental !! !! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative !! or greater than `bits(set) - 1` the result is 0. integer :: value class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function value_large module subroutine write_bitset_string_large ( self , string , status ) !! Version: experimental !! !! Writes a bitset literal to the allocatable default character `string`, !! representing the individual bit values in the bitset_large, `self`. !! If `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success, or the value `alloc_fault` if allocation of !! the output string failed. class ( bitset_large ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine write_bitset_string_large module subroutine write_bitset_unit_large ( self , unit , advance , status ) !! Version: experimental !! !! Writes a bitset literal to the I/O unit, `unit`, representing the !! individual bit values in the bitset, `self`. By default or if !! `advance` is present with the value 'YES', advancing output is used. !! If `advance` is present with the value 'NO', then the current record !! is not advanced by the write. If `status` is absent an error results !! in an error stop with an informative stop code. If `status` is !! present it has the default value of `success`, the value !! `alloc_fault` if allocation of the output string failed, or !! `write_failure` if the `write` statement outputting the literal failed. class ( bitset_large ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine write_bitset_unit_large end interface interface assignment ( = ) !! Version: experimental !! !! Used to define assignment for `bitset_large`. !! ([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value)) !! !!#### Example !! !!```fortran !!    program demo_assignment !!        use stdlib_bitsets !!        logical(int8)  :: logical1(64) = .true. !!        logical(int32), allocatable :: logical2(:) !!        type(bitset_64) :: set0, set1 !!        set0 = logical1 !!        if ( set0 % bits() /= 64 ) then !!            error stop procedure // & !!                ' initialization with logical(int8) failed to set' // & !!                ' the right size.' !!        else if ( .not. set0 % all() ) then !!            error stop procedure // ' initialization with' // & !!                ' logical(int8) failed to set the right values.' !!        else !!            write(*,*) 'Initialization with logical(int8) succeeded.' !!        end if !!        set1 = set0 !!        if ( set1 == set0 ) & !!            write(*,*) 'Initialization by assignment succeeded' !!        logical2 = set1 !!        if ( all( logical2 ) ) then !!            write(*,*) 'Initialization of logical(int32) succeeded.' !!        end if !!    end program demo_assignment !!``` pure module subroutine assign_large ( set1 , set2 ) !! Version: experimental !! !! Used to define assignment for `bitset_large`. type ( bitset_large ), intent ( out ) :: set1 type ( bitset_large ), intent ( in ) :: set2 end subroutine assign_large # : for k1 in INT_KINDS pure module subroutine assign_log$ { k1 }$_ large ( self , logical_vector ) !! Version: experimental !! !! Used to define assignment from an array of type `logical(${k1}$)` to a !! `bitset_large`. type ( bitset_large ), intent ( out ) :: self logical ( ${ k1 }$ ), intent ( in ) :: logical_vector (:) end subroutine assign_log$ { k1 }$_ large pure module subroutine log ${ k1 }$_ assign_large ( logical_vector , set ) !! Version: experimental !! !! Used to define assignment to an array of type `logical(${k1}$)` from a !! `bitset_large`. logical ( ${ k1 }$ ), intent ( out ), allocatable :: logical_vector (:) type ( bitset_large ), intent ( in ) :: set end subroutine log ${ k1 }$_ assign_large # : endfor end interface assignment ( = ) type , extends ( bitset_type ) :: bitset_64 !! Version: experimental !! !! Type for bitsets with no more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( block_kind ), private :: block = 0 contains procedure , pass ( self ) :: all => all_64 procedure , pass ( self ) :: any => any_64 procedure , pass ( self ) :: bit_count => bit_count_64 procedure , pass ( self ) :: clear_bit => clear_bit_64 procedure , pass ( self ) :: clear_range => clear_range_64 procedure , pass ( self ) :: flip_bit => flip_bit_64 procedure , pass ( self ) :: flip_range => flip_range_64 procedure , pass ( self ) :: from_string => from_string_64 procedure , pass ( self ) :: init_zero => init_zero_64 procedure , pass ( self ) :: input => input_64 procedure , pass ( self ) :: none => none_64 procedure , pass ( self ) :: not => not_64 procedure , pass ( self ) :: output => output_64 procedure , pass ( self ) :: read_bitset_string => read_bitset_string_64 procedure , pass ( self ) :: read_bitset_unit => read_bitset_unit_64 procedure , pass ( self ) :: set_bit => set_bit_64 procedure , pass ( self ) :: set_range => set_range_64 procedure , pass ( self ) :: test => test_64 procedure , pass ( self ) :: to_string => to_string_64 procedure , pass ( self ) :: value => value_64 procedure , pass ( self ) :: write_bitset_string => write_bitset_string_64 procedure , pass ( self ) :: write_bitset_unit => write_bitset_unit_64 end type bitset_64 interface elemental module function all_64 ( self ) result ( all ) !! Version: experimental !! !! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise. logical :: all class ( bitset_64 ), intent ( in ) :: self end function all_64 elemental module function any_64 ( self ) result ( any ) !! Version: experimental !! !! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise. logical :: any class ( bitset_64 ), intent ( in ) :: self end function any_64 elemental module function bit_count_64 ( self ) result ( bit_count ) !! Version: experimental !! !! Returns the number of non-zero bits in `self`. integer ( bits_kind ) :: bit_count class ( bitset_64 ), intent ( in ) :: self end function bit_count_64 elemental module subroutine clear_bit_64 ( self , pos ) !! Version: experimental !! !! Sets to zero the bit at `pos` position in `self`. If `pos` is less than !! zero or greater than `bits(self)-1` it is ignored. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine clear_bit_64 pure module subroutine clear_range_64 ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `self`. !! If `stop_pos < start_pos` then no bits are modified. Positions outside !! the range 0 to `bits(set)-1` are ignored. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine clear_range_64 elemental module subroutine flip_bit_64 ( self , pos ) !! Version: experimental !! !! Flips the bit value at the `pos` position in `self`, provided the position is !! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is !! changed. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine flip_bit_64 pure module subroutine flip_range_64 ( self , start_pos , stop_pos ) !! Version: experimental !! !! Flips all valid bits from the `start_pos` to the `stop_pos` positions in !! `self`. If `stop_pos < start_pos` no bits are flipped. Positions less than !! 0 or greater than `bits(self)-1` are ignored. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine flip_range_64 module subroutine from_string_64 ( self , string , status ) !! Version: experimental !! !! Initializes the bitset `self` treating `string` as a binary literal !! `status` may have the values: !! * `success` - if no problems were found, !! * `alloc_fault` - if allocation of the bitset failed !! * `char_string_too_large_error` - if `string` was too large, or !! * `char_string_invalid_error` - if string had an invalid character. class ( bitset_64 ), intent ( out ) :: self character ( * ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine from_string_64 module subroutine init_zero_64 ( self , bits , status ) !! Version: experimental !! !! Creates the bitset, `self`, of size `bits`, with all bits initialized to !! zero. `bits` must be non-negative.  If an error occurs and `status` is !! absent then processing stops with an informative stop code. `status` !! will have one of the values: !! * `success` -  if no problems were found, !! * `alloc_fault` - if memory allocation failed !! * `array_size_invalid_error` - if `bits` is either negative or larger !!   than 64 with `self` of class `bitset_64`. class ( bitset_64 ), intent ( out ) :: self integer ( bits_kind ), intent ( in ) :: bits integer , intent ( out ), optional :: status end subroutine init_zero_64 module subroutine input_64 ( self , unit , status ) !! Version: experimental !! !! Reads the components of the bitset, `self`, from the unformatted I/O !! unit, `unit`, assuming that the components were written using `output`. !! If an error occurs and `status` is absent then processing stops with !! an informative stop code. `status` has one of the values: !! * `success` - if no problem was found !! * `alloc_fault` - if it failed allocating memory for `self`, or !! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative !!   or greater than 64 for a `bitset_64` input. !! * `read_failure` - if it failed during the reads from `unit` class ( bitset_64 ), intent ( out ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine input_64 elemental module function none_64 ( self ) result ( none ) !! Version: experimental !! !! Returns `.true.` if none of the bits in `self` have the value 1. logical :: none class ( bitset_64 ), intent ( in ) :: self end function none_64 elemental module subroutine not_64 ( self ) !! Version: experimental !! !! Sets the bits in `self` to their logical complement. class ( bitset_64 ), intent ( inout ) :: self end subroutine not_64 module subroutine output_64 ( self , unit , status ) !! Version: experimental !! !! Writes the components of the bitset, `self`, to the unformatted I/O !! unit, `unit`, in a unformatted sequence compatible with `input`. If !! `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success`, or the value `write_failure` if the write failed. class ( bitset_64 ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status end subroutine output_64 module subroutine read_bitset_string_64 ( self , string , status ) !! Version: experimental !! !! Uses the bitset literal in the default character `string`, to define !! the bitset, `self`. The literal may be preceded by an an arbitrary !! sequence of blank characters. If `status` is absent an error results !! in an error stop with an informative stop code. If `status` !! is present it has one of the values: !! * `success` - if no problems occurred, !! * `alloc_fault` - if allocation of memory for SELF failed, !! * `array_size_invalid_error - if `bits(self)` in `string` is greater !!   than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the bitset literal has an invalid !!   character, !! * `char_string_too_small_error - if the string ends before all the bits !!   are read. !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, class ( bitset_64 ), intent ( out ) :: self character ( len =* ), intent ( in ) :: string integer , intent ( out ), optional :: status end subroutine read_bitset_string_64 module subroutine read_bitset_unit_64 ( self , unit , advance , status ) !! Version: experimental !! !! Uses the bitset literal at the current position in the formatted !! file with I/O unit, `unit`, to define the bitset, `self`. The literal !! may be preceded by an an arbitrary sequence of blank characters. !! If `advance` is present it must be either 'YES' or 'NO'. If absent !! it has the default value of 'YES' to determine whether advancing !! I/O occurs. If `status` is absent an error results in an error stop !! with an informative stop code. If `status` is present it has one of !! the values: !! * `success` - if no problem occurred, !! * `alloc_fault` - if allocation of `self` failed, !! * `array_size_invalid_error` - if `bits(self)` in the bitset literal !!   is greater than 64 for a `bitset_64`, !! * `char_string_invalid_error` - if the read of the bitset literal found !!   an invalid character, !! * `eof_failure` - if a `read` statement reached an end-of-file before !!   completing the read of the bitset literal, !! * `integer_overflow_error` - if the bitset literal has a `bits(self)` !!   value too large to be represented, !! * `read_failure` - if a `read` statement fails, class ( bitset_64 ), intent ( out ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine read_bitset_unit_64 elemental module subroutine set_bit_64 ( self , pos ) !! Version: experimental !! !! Sets the value at the `pos` position in `self`, provided the position is !! valid. If the position is less than 0 or greater than `bits(self)-1` !! then `self` is unchanged. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos end subroutine set_bit_64 pure module subroutine set_range_64 ( self , start_pos , stop_pos ) !! Version: experimental !! !! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions !! in `self`. If `stop_pos < start_pos` no bits are changed. Positions outside !! the range 0 to `bits(self)-1` are ignored. class ( bitset_64 ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos end subroutine set_range_64 elemental module function test_64 ( self , pos ) result ( test ) !! Version: experimental !! !! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos` !! is negative or greater than `bits(self)-1` the result is `.false.`. logical :: test class ( bitset_64 ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function test_64 module subroutine to_string_64 ( self , string , status ) !! Version: experimental !! !! Represents the value of `self` as a binary literal in `string`. !! Status may have the values `success` or `alloc_fault` class ( bitset_64 ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine to_string_64 elemental module function value_64 ( self , pos ) result ( value ) !! Version: experimental !! !! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative !! or greater than `bits(set)-1` the result is 0. integer :: value class ( bitset_64 ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos end function value_64 module subroutine write_bitset_string_64 ( self , string , status ) !! Version: experimental !! !! Writes a bitset literal to the allocatable default character `string`, !! representing the individual bit values in the `bitset_64`, `self`. !! If `status` is absent an error results in an error stop with an !! informative stop code. If `status` is present it has the default !! value of `success`, or the value `alloc_fault` if allocation of !! the output string failed. class ( bitset_64 ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status end subroutine write_bitset_string_64 module subroutine write_bitset_unit_64 ( self , unit , advance , status ) !! Version: experimental !! !! Writes a bitset literal to the I/O unit, `unit`, representing the !! individual bit values in the bitset, `self`. By default or if !! `advance` is present with the value 'YES', advancing output is used. !! If `advance` is present with the value 'NO', then the current record !! is not advanced by the write. If `status` is absent an error results !! in an error stop with an informative stop code. If `status` is !! present it has the default value of `success`, the value !! `alloc_fault` if allocation of the output string failed, or !! `write_failure` if the `write` statement outputting the literal failed. class ( bitset_64 ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status end subroutine write_bitset_unit_64 end interface interface assignment ( = ) pure module subroutine assign_64 ( set1 , set2 ) !! Version: experimental !! !! Used to define assignment for `bitset_64`. type ( bitset_64 ), intent ( out ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 end subroutine assign_64 # : for k1 in INT_KINDS module subroutine assign_log$ { k1 }$_ 64 ( self , logical_vector ) !! Version: experimental !! !! Used to define assignment from an array of type `logical(${k1}$)` to a !! `bitset_64`. type ( bitset_64 ), intent ( out ) :: self logical ( ${ k1 }$ ), intent ( in ) :: logical_vector (:) end subroutine assign_log$ { k1 }$_ 64 pure module subroutine log ${ k1 }$_ assign_64 ( logical_vector , set ) !! Version: experimental !! !! Used to define assignment to an array of type `logical(${k1}$)` from a !! `bitset_64`. logical ( ${ k1 }$ ), intent ( out ), allocatable :: logical_vector (:) type ( bitset_64 ), intent ( in ) :: set end subroutine log ${ k1 }$_ assign_64 # : endfor end interface assignment ( = ) interface and !! Version: experimental !! !! Sets the bits in `set1` to the bitwise `and` of the original bits in `set1` !! and `set2`. The sets must have the same number of bits !! otherwise the result is undefined. !! ([Specification](../page/specs/stdlib_bitsets.html#and-bitwise-and-of-the-bits-of-two-bitsets)) !! !!#### Example !! !!```fortran !!    program demo_and !!        use stdlib_bitsets !!        type(bitset_large) :: set0, set1 !!        call set0 % init(166) !!        call set1 % init(166) !!        call and( set0, set1 ) ! none none !!        if ( none(set0) ) write(*,*) 'First test of AND worked.' !!        call set0 % not() !!        call and( set0, set1 ) ! all none !!        if ( none(set0) ) write(*,*) 'Second test of AND worked.' !!        call set1 % not() !!        call and( set0, set1 ) ! none all !!        if ( none(set0) ) write(*,*) 'Third test of AND worked.' !!        call set0 % not() !!        call and( set0, set1 ) ! all all !!        if ( all(set0) ) write(*,*) 'Fourth test of AND worked.' !!    end program demo_and !!``` elemental module subroutine and_large ( set1 , set2 ) type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 end subroutine and_large elemental module subroutine and_64 ( set1 , set2 ) type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 end subroutine and_64 end interface and interface and_not !! Version: experimental !! !! Sets the bits in `set1` to the bitwise and of the original bits in `set1` !! with the bitwise negation of `set2`. The sets must have the same !! number of bits otherwise the result is undefined. !! !! ([Specification](../page/specs/stdlib_bitsets.html#and_not-bitwise-and-of-one-bitset-with-the-negation-of-another)) !! !!#### Example !! !!```fortran !!    program demo_and_not !!        use stdlib_bitsets !!        type(bitset_large) :: set0, set1 !!        call set0 % init(166) !!        call set1 % init(166) !!        call and_not( set0, set1 ) ! none none !!        if ( none(set0) ) write(*,*) 'First test of AND_NOT worked.' !!        call set0 % not() !!        call and_not( set0, set1 ) ! all none !!        if ( all(set0) ) write(*,*) 'Second test of AND_NOT worked.' !!        call set0 % not() !!        call set1 % not() !!        call and_not( set0, set1 ) ! none all !!        if ( none(set0) ) write(*,*) 'Third test of AND_NOT worked.' !!        call set0 % not() !!        call and_not( set0, set1 ) ! all all !!        if ( none(set0) ) write(*,*) 'Fourth test of AND_NOT worked.' !!    end program demo_and_not !!``` elemental module subroutine and_not_large ( set1 , set2 ) type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 end subroutine and_not_large elemental module subroutine and_not_64 ( set1 , set2 ) type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 end subroutine and_not_64 end interface and_not interface extract !! Version: experimental !! !! Creates a new bitset, `new`, from a range, `start_pos` to `stop_pos`, in !! bitset `old`. If `start_pos` is greater than `stop_pos` the new bitset is !! empty. If `start_pos` is less than zero or `stop_pos` is greater than !! `bits(old)-1` then if `status` is present it has the value !! `index_invalid_error` and `new` is undefined, otherwise processing stops !! with an informative message. !! ([Specification](../page/specs/stdlib_bitsets.html#extract-create-a-new-bitset-from-a-range-in-an-old-bitset)) !! !!#### Example !! !!```fortran !!    program demo_extract !!        use stdlib_bitsets !!        type(bitset_large) :: set0, set1 !!        call set0 % init(166) !!        call set0 % set(100,150) !!        call extract( set1, set0, 100, 150) !!        if ( set1 % bits() == 51 ) & !!            write(*,*) 'SET1 has the proper size.' !!        if ( set1 % all() ) write(*,*) 'SET1 has the proper values.' !!    end program demo_extract !!``` module subroutine extract_large ( new , old , start_pos , stop_pos , status ) type ( bitset_large ), intent ( out ) :: new type ( bitset_large ), intent ( in ) :: old integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer , intent ( out ), optional :: status end subroutine extract_large module subroutine extract_64 ( new , old , start_pos , stop_pos , status ) type ( bitset_64 ), intent ( out ) :: new type ( bitset_64 ), intent ( in ) :: old integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer , intent ( out ), optional :: status end subroutine extract_64 end interface extract interface or !! Version: experimental !! !! Sets the bits in `set1` to the bitwise `or` of the original bits in `set1` !! and `set2`. The sets must have the same number of bits otherwise !! the result is undefined. !! ([Specification](../page/specs/stdlib_bitsets.html#or-bitwise-or-of-the-bits-of-two-bitsets)) !! !!#### Example !! !!```fortran !!    program demo_or !!        use stdlib_bitsets !!        type(bitset_large) :: set0, set1 !!        call set0 % init(166) !!        call set1 % init(166) !!        call or( set0, set1 ) ! none none !!        if ( none(set0) ) write(*,*) 'First test of OR worked.' !!        call set0 % not() !!        call or( set0, set1 ) ! all none !!        if ( all(set0) ) write(*,*) 'Second test of OR worked.' !!        call set0 % not() !!        call set1 % not() !!        call or( set0, set1 ) ! none all !!        if ( all(set0) ) write(*,*) 'Third test of OR worked.' !!        call set0 % not() !!        call or( set0, set1 ) ! all all !!        if ( all(set0) ) write(*,*) 'Fourth test of OR worked.' !!    end program demo_or !!``` elemental module subroutine or_large ( set1 , set2 ) type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 end subroutine or_large elemental module subroutine or_64 ( set1 , set2 ) type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 end subroutine or_64 end interface or interface xor !! Version: experimental !! !! Sets the bits in `set1` to the bitwise `xor` of the original bits in `set1` !! and `set2`. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#xor-bitwise-exclusive-or)) !! !!#### Example !! !!```fortran !!    program demo_xor !!        use stdlib_bitsets !!        type(bitset_large) :: set0, set1 !!        call set0 % init(166) !!        call set1 % init(166) !!        call xor( set0, set1 ) ! none none !!        if ( none(set0) ) write(*,*) 'First test of XOR worked.' !!        call set0 % not() !!        call xor( set0, set1 ) ! all none !!        if ( all(set0) ) write(*,*) 'Second test of XOR worked.' !!        call set0 % not() !!        call set1 % not() !!        call xor( set0, set1 ) ! none all !!        if ( all(set0) ) write(*,*) 'Third test of XOR worked.' !!        call set0 % not() !!        call xor( set0, set1 ) ! all all !!        if ( none(set0) ) write(*,*) 'Fourth test of XOR worked.' !!    end program demo_xor !!``` elemental module subroutine xor_large ( set1 , set2 ) type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 end subroutine xor_large elemental module subroutine xor_64 ( set1 , set2 ) type ( bitset_64 ), intent ( inout ) :: set1 type ( bitset_64 ), intent ( in ) :: set2 end subroutine xor_64 end interface xor interface operator ( == ) !! Version: experimental !! !! Returns `.true.` if all bits in `set1` and `set2` have the same value, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value)) !! !!#### Example !! !!```fortran !!    program demo_equality !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set0 == set0 .and. set1 == set1 .and. set2 == set2 .and. & !!            .not. set0 == set1 .and. .not. set0 == set2 .and. .not.   & !!            set1 == set2 ) then !!            write(*,*) 'Passed 64 bit equality tests.' !!        else !!            error stop 'Failed 64 bit equality tests.' !!        end if !!    end program demo_equality !!``` elemental module function eqv_large ( set1 , set2 ) result ( eqv ) logical :: eqv type ( bitset_large ), intent ( in ) :: set1 , set2 end function eqv_large elemental module function eqv_64 ( set1 , set2 ) result ( eqv ) logical :: eqv type ( bitset_64 ), intent ( in ) :: set1 , set2 end function eqv_64 end interface operator ( == ) interface operator ( /= ) !! Version: experimental !! !! Returns `.true.` if not all bits in `set1` and `set2` have the same value, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-any-bits-differ-in-value)) !! !!#### Example !! !!```fortran !!    program demo_inequality !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set0 /= set1 .and. set0 /= set2 .and. set1 /= set2 .and. & !!            .not. set0 /= set0 .and. .not. set1 /= set1 .and. .not.   & !!            set2 /= set2 ) then !!            write(*,*) 'Passed 64 bit inequality tests.' !!        else !!            error stop 'Failed 64 bit inequality tests.' !!        end if !!    end program demo_inequality !!``` elemental module function neqv_large ( set1 , set2 ) result ( neqv ) logical :: neqv type ( bitset_large ), intent ( in ) :: set1 , set2 end function neqv_large elemental module function neqv_64 ( set1 , set2 ) result ( neqv ) logical :: neqv type ( bitset_64 ), intent ( in ) :: set1 , set2 end function neqv_64 end interface operator ( /= ) interface operator ( > ) !! Version: experimental !! !! Returns `.true.` if the bits in `set1` and `set2` differ and the !! highest order different bit is set to 1 in `set1` and to 0 in `set2`, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-the-other)) !! !!#### Example !! !!```fortran !!    program demo_gt !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set1 > set0 .and. set2 > set1 .and. set2 > set0 .and. & !!            .not. set0 > set0 .and. .not. set0 > set1 .and. .not.   & !!            set1 > set2 ) then !!            write(*,*) 'Passed 64 bit greater than tests.' !!        else !!            error stop 'Failed 64 bit greater than tests.' !!        end if !!    end program demo_gt !!``` elemental module function gt_large ( set1 , set2 ) result ( gt ) logical :: gt type ( bitset_large ), intent ( in ) :: set1 , set2 end function gt_large elemental module function gt_64 ( set1 , set2 ) result ( gt ) logical :: gt type ( bitset_64 ), intent ( in ) :: set1 , set2 end function gt_64 end interface operator ( > ) interface operator ( >= ) !! Version: experimental !! !! Returns `.true.` if the bits in `set1` and `set2` are the same or the !! highest order different bit is set to 1 in `set1` and to 0 in `set2`, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !! ([Specification](../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-or-equal-to-the-second)) !! !!#### Example !! !!```fortran !!    program demo_ge !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set1 >= set0 .and. set2 >= set1 .and. set2 >= set0 .and. & !!            set0 >= set0 .and. set1 >= set1 .and. set2 >= set2 .and. & !!            .not. set0 >= set1 .and. .not. set0 >= set2 .and. .not.   & !!            set1 >= set2 ) then !!            write(*,*) 'Passed 64 bit greater than or equals tests.' !!        else !!            error stop 'Failed 64 bit greater than or equals tests.' !!        end if !!    end program demo_ge !!``` elemental module function ge_large ( set1 , set2 ) result ( ge ) logical :: ge type ( bitset_large ), intent ( in ) :: set1 , set2 end function ge_large elemental module function ge_64 ( set1 , set2 ) result ( ge ) logical :: ge type ( bitset_64 ), intent ( in ) :: set1 , set2 end function ge_64 end interface operator ( >= ) interface operator ( < ) !! Version: experimental !! !! Returns `.true.` if the bits in `set1` and `set2` differ and the !! highest order different bit is set to 0 in `set1` and to 1 in `set2`, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-the-other)) !! !!#### Example !! !!```fortran !!    program demo_lt !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set0 < set1 .and. set1 < set2 .and. set0 < set2 .and. & !!            .not. set0 < set0 .and. .not. set2 < set0 .and. .not.   & !!            set2 < set1 ) then !!            write(*,*) 'Passed 64 bit less than tests.' !!        else !!            error stop 'Failed 64 bit less than tests.' !!        end if !!    end program demo_lt !!``` elemental module function lt_large ( set1 , set2 ) result ( lt ) logical :: lt type ( bitset_large ), intent ( in ) :: set1 , set2 end function lt_large elemental module function lt_64 ( set1 , set2 ) result ( lt ) logical :: lt type ( bitset_64 ), intent ( in ) :: set1 , set2 end function lt_64 end interface operator ( < ) interface operator ( <= ) !! Version: experimental !! !! Returns `.true.` if the bits in `set1` and `set2` are the same or the !! highest order different bit is set to 0 in `set1` and to 1 in `set2`, !! `.false.`  otherwise. The sets must have the same number of bits !! otherwise the result is undefined. !!([Specification](../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-or-equal-to-the-other)) !! !!#### Example !! !!```fortran !!    program demo_le !!        use stdlib_bitsets !!        type(bitset_64) :: set0, set1, set2 !!        call set0 % init( 33 ) !!        call set1 % init( 33 ) !!        call set2 % init( 33 ) !!        call set1 % set( 0 ) !!        call set2 % set( 32 ) !!        if ( set0 <= set1 .and. set1 <= set2 .and. set0 <= set2 .and. & !!            set0 <= set0 .and. set1 <= set1 .and. set2 <= set2 .and. & !!            .not. set1 <= set0 .and. .not. set2 <= set0 .and. .not.   & !!            set2 <= set1 ) then !!            write(*,*) 'Passed 64 bit less than or equal tests.' !!        else !!            error stop 'Failed 64 bit less than or equal tests.' !!        end if !!    end program demo_le !!``` elemental module function le_large ( set1 , set2 ) result ( le ) logical :: le type ( bitset_large ), intent ( in ) :: set1 , set2 end function le_large elemental module function le_64 ( set1 , set2 ) result ( le ) logical :: le type ( bitset_64 ), intent ( in ) :: set1 , set2 end function le_64 end interface operator ( <= ) interface error_handler module subroutine error_handler ( message , error , status , & module , procedure ) character ( * ), intent ( in ) :: message integer , intent ( in ) :: error integer , intent ( out ), optional :: status character ( * ), intent ( in ), optional :: module character ( * ), intent ( in ), optional :: procedure end subroutine error_handler end interface error_handler contains elemental function bits ( self ) !! Version: experimental !! !! Returns the number of bit positions in `self`. integer ( bits_kind ) :: bits class ( bitset_type ), intent ( in ) :: self bits = self % num_bits return end function bits module subroutine error_handler ( message , error , status , module , procedure ) character ( * ), intent ( in ) :: message integer , intent ( in ) :: error integer , intent ( out ), optional :: status character ( * ), intent ( in ), optional :: module character ( * ), intent ( in ), optional :: procedure if ( present ( status ) ) then status = error else if ( present ( module ) ) then if ( present ( procedure ) ) then write ( error_unit , '(a)' ) trim ( module ) // ' % ' // & trim ( procedure ) // ': ' // trim ( message ) else write ( error_unit , '(a)' ) trim ( module ) // ' % N/A: ' // & trim ( message ) end if else if ( present ( procedure ) ) then write ( error_unit , '(a)' ) trim ( procedure ) // ': ' // & trim ( message ) else write ( error_unit , '(a)' ) trim ( message ) end if select case ( error ) case ( alloc_fault ) error stop 'A memory allocation failed.' case ( array_size_invalid_error ) error stop \"An array size was invalid.\" case ( char_string_invalid_error ) error stop \"A character string had an invalid character.\" case ( char_string_too_large_error ) error stop \"A character string was too large.\" case ( char_string_too_small_error ) error stop \"A character string was too small.\" case ( eof_failure ) error stop \"An End-Of-File failure occurred on a READ \" // & \"statement.\" case ( index_invalid_error ) error stop \"An index was invalid.\" case ( integer_overflow_error ) error stop \"An integer overflow error occurred.\" case ( read_failure ) error stop \"A failure occurred in a READ statement.\" case ( write_failure ) error stop \"A failure occurred on a WRITE statement.\" end select end if end subroutine error_handler end module stdlib_bitsets","tags":"","loc":"sourcefile/stdlib_bitsets.fypp.html"},{"title":"stdlib_math_linspace.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_math_linspace.fypp~~EfferentGraph sourcefile~stdlib_math_linspace.fypp stdlib_math_linspace.fypp sourcefile~stdlib_math.fypp stdlib_math.fypp sourcefile~stdlib_math_linspace.fypp->sourcefile~stdlib_math.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_math.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_math_linspace Source Code stdlib_math_linspace.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_math ) stdlib_math_linspace implicit none contains # : for k1 , t1 in REAL_KINDS_TYPES # : set RName = rname ( \"linspace_default\" , 1 , t1 , k1 ) module function ${ RName }$ ( start , end ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end ${ t1 }$ :: res ( DEFAULT_LINSPACE_LENGTH ) res = linspace ( start , end , DEFAULT_LINSPACE_LENGTH ) end function ${ RName }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES # : set RName = rname ( \"linspace_n\" , 1 , t1 , k1 ) module function ${ RName }$ ( start , end , n ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n ${ t1 }$ :: res ( n ) integer :: i ! Looping index ${ t1 }$ :: interval ! Difference between adjacent elements if ( n <= 0 ) return ! If passed length is less than or equal to 0, return an empty (allocated with length 0) array if ( n == 1 ) then res ( 1 ) = end return end if interval = ( end - start ) / real (( n - 1 ), ${ k1 }$ ) res ( 1 ) = start res ( n ) = end do i = 2 , n - 1 res ( i ) = real (( i - 1 ), ${ k1 }$ ) * interval + start end do end function ${ RName }$ # : endfor # : for k1 , t1 in CMPLX_KINDS_TYPES # : set RName = rname ( \"linspace_default\" , 1 , t1 , k1 ) module procedure ${ RName }$ res = linspace ( start , end , DEFAULT_LINSPACE_LENGTH ) end procedure ${ RName }$ # : endfor # : for k1 , t1 in CMPLX_KINDS_TYPES # : set RName = rname ( \"linspace_n\" , 1 , t1 , k1 ) module procedure ${ RName }$ real ( ${ k1 }$ ) :: x ( n ) ! array of the real part of complex number real ( ${ k1 }$ ) :: y ( n ) ! array of the imaginary part of the complex number x = linspace ( start % re , end % re , n ) y = linspace ( start % im , end % im , n ) res = cmplx ( x , y , kind = ${ k1 }$ ) end procedure ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"linspace_default\" , 1 , t1 , k1 ) module procedure ${ RName }$ res = linspace ( real ( start , kind = dp ), real ( end , kind = dp ), DEFAULT_LINSPACE_LENGTH ) end procedure ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"linspace_n\" , 1 , t1 , k1 ) module procedure ${ RName }$ res = linspace ( real ( start , kind = dp ), real ( end , kind = dp ), n ) end procedure ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_math_linspace.fypp.html"},{"title":"stdlib_optval.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_optval.fypp~~EfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_optval.fypp~~AfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment_scalar.fypp stdlib_stats_moment_scalar.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_mask.fypp stdlib_stats_moment_mask.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_strings.f90 stdlib_strings.f90 sourcefile~stdlib_strings.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_all.fypp stdlib_stats_moment_all.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_distribution_prng.fypp stdlib_stats_distribution_PRNG.fypp sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_optval Source Code stdlib_optval.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES + & & [( 'l1' , 'logical' )] module stdlib_optval !! !! Provides a generic function `optval`, which can be used to !! conveniently implement fallback values for optional arguments !! to subprograms !! ([Specification](../page/specs/stdlib_optval.html)) !! !! If `x` is an `optional` parameter of a !! subprogram, then the expression `optval(x, default)` inside that !! subprogram evaluates to `x` if it is present, otherwise `default`. !! !! It is an error to call `optval` with a single actual argument. !! use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 implicit none private public :: optval interface optval !! version: experimental !! !! Fallback value for optional arguments !! ([Specification](../page/specs/stdlib_optval.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor module procedure optval_character ! TODO: differentiate ascii & ucs char kinds end interface optval contains # : for k1 , t1 in KINDS_TYPES pure elemental function optval_$ { t1 [ 0 ] }{ k1 }$ ( x , default ) result ( y ) ${ t1 }$ , intent ( in ), optional :: x ${ t1 }$ , intent ( in ) :: default ${ t1 }$ :: y if ( present ( x )) then y = x else y = default end if end function optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor ! Cannot be made elemental pure function optval_character ( x , default ) result ( y ) character ( len =* ), intent ( in ), optional :: x character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: y if ( present ( x )) then y = x else y = default end if end function optval_character end module stdlib_optval","tags":"","loc":"sourcefile/stdlib_optval.fypp.html"},{"title":"stdlib_specialfunctions_legendre.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_specialfunctions_legendre.f90~~EfferentGraph sourcefile~stdlib_specialfunctions_legendre.f90 stdlib_specialfunctions_legendre.f90 sourcefile~stdlib_specialfunctions.f90 stdlib_specialfunctions.f90 sourcefile~stdlib_specialfunctions_legendre.f90->sourcefile~stdlib_specialfunctions.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_specialfunctions.f90->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_specialfunctions_legendre Source Code stdlib_specialfunctions_legendre.f90 Source Code submodule ( stdlib_specialfunctions ) stdlib_specialfunctions_legendre implicit none contains ! derivatives of legegendre polynomials ! unspecified behaviour if n is negative pure elemental module function dlegendre_fp64 ( n , x ) result ( dleg ) integer , intent ( in ) :: n real ( dp ), intent ( in ) :: x real ( dp ) :: dleg select case ( n ) case ( 0 ) dleg = 0 case ( 1 ) dleg = 1 case default block real ( dp ) :: leg_down1 , leg_down2 , leg real ( dp ) :: dleg_down1 , dleg_down2 integer :: i leg_down1 = x dleg_down1 = 1 leg_down2 = 1 dleg_down2 = 0 do i = 2 , n leg = ( 2 * i - 1 ) * x * leg_down1 / i - ( i - 1 ) * leg_down2 / i dleg = dleg_down2 + ( 2 * i - 1 ) * leg_down1 leg_down2 = leg_down1 leg_down1 = leg dleg_down2 = dleg_down1 dleg_down1 = dleg end do end block end select end function ! legegendre polynomials ! unspecified behaviour if n is negative pure elemental module function legendre_fp64 ( n , x ) result ( leg ) integer , intent ( in ) :: n real ( dp ), intent ( in ) :: x real ( dp ) :: leg select case ( n ) case ( 0 ) leg = 1 case ( 1 ) leg = x case default block real ( dp ) :: leg_down1 , leg_down2 integer :: i leg_down1 = x leg_down2 = 1 do i = 2 , n leg = ( 2 * i - 1 ) * x * leg_down1 / i - ( i - 1 ) * leg_down2 / i leg_down2 = leg_down1 leg_down1 = leg end do end block end select end function end submodule","tags":"","loc":"sourcefile/stdlib_specialfunctions_legendre.f90.html"},{"title":"stdlib_ascii.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_ascii.fypp~~EfferentGraph sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_ascii.fypp~~AfferentGraph sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_strings.f90 stdlib_strings.f90 sourcefile~stdlib_strings.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_sorting_ord_sort.fypp stdlib_sorting_ord_sort.fypp sourcefile~stdlib_sorting_ord_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort_index.fypp stdlib_sorting_sort_index.fypp sourcefile~stdlib_sorting_sort_index.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort.fypp stdlib_sorting_sort.fypp sourcefile~stdlib_sorting_sort.fypp->sourcefile~stdlib_sorting.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_ascii Source Code stdlib_ascii.fypp Source Code #:include \"common.fypp\" !> The `stdlib_ascii` module provides procedures for handling and manipulating !> intrinsic character variables and constants. !> !> The specification of this module is available [here](../page/specs/stdlib_ascii.html). module stdlib_ascii use stdlib_kinds , only : int8 , int16 , int32 , int64 , lk , c_bool implicit none private ! Character validation functions public :: is_alpha , is_alphanum public :: is_digit , is_hex_digit , is_octal_digit public :: is_control , is_white , is_blank public :: is_ascii , is_punctuation public :: is_graphical , is_printable public :: is_lower , is_upper ! Character conversion functions public :: to_lower , to_upper , to_title , to_sentence , reverse public :: to_string !> Version: experimental !> !> Create a character string representing the value of the provided variable. interface to_string # : for kind in INT_KINDS module procedure :: to_string_integer_$ { kind }$ # : endfor # : for kind in LOG_KINDS module procedure :: to_string_logical_$ { kind }$ # : endfor end interface to_string ! All control characters in the ASCII table (see www.asciitable.com). character ( len = 1 ), public , parameter :: NUL = achar ( int ( z '00' )) !! Null character ( len = 1 ), public , parameter :: SOH = achar ( int ( z '01' )) !! Start of heading character ( len = 1 ), public , parameter :: STX = achar ( int ( z '02' )) !! Start of text character ( len = 1 ), public , parameter :: ETX = achar ( int ( z '03' )) !! End of text character ( len = 1 ), public , parameter :: EOT = achar ( int ( z '04' )) !! End of transmission character ( len = 1 ), public , parameter :: ENQ = achar ( int ( z '05' )) !! Enquiry character ( len = 1 ), public , parameter :: ACK = achar ( int ( z '06' )) !! Acknowledge character ( len = 1 ), public , parameter :: BEL = achar ( int ( z '07' )) !! Bell character ( len = 1 ), public , parameter :: BS = achar ( int ( z '08' )) !! Backspace character ( len = 1 ), public , parameter :: TAB = achar ( int ( z '09' )) !! Horizontal tab character ( len = 1 ), public , parameter :: LF = achar ( int ( z '0A' )) !! NL line feed, new line character ( len = 1 ), public , parameter :: VT = achar ( int ( z '0B' )) !! Vertical tab character ( len = 1 ), public , parameter :: FF = achar ( int ( z '0C' )) !! NP form feed, new page character ( len = 1 ), public , parameter :: CR = achar ( int ( z '0D' )) !! Carriage return character ( len = 1 ), public , parameter :: SO = achar ( int ( z '0E' )) !! Shift out character ( len = 1 ), public , parameter :: SI = achar ( int ( z '0F' )) !! Shift in character ( len = 1 ), public , parameter :: DLE = achar ( int ( z '10' )) !! Data link escape character ( len = 1 ), public , parameter :: DC1 = achar ( int ( z '11' )) !! Device control 1 character ( len = 1 ), public , parameter :: DC2 = achar ( int ( z '12' )) !! Device control 2 character ( len = 1 ), public , parameter :: DC3 = achar ( int ( z '13' )) !! Device control 3 character ( len = 1 ), public , parameter :: DC4 = achar ( int ( z '14' )) !! Device control 4 character ( len = 1 ), public , parameter :: NAK = achar ( int ( z '15' )) !! Negative acknowledge character ( len = 1 ), public , parameter :: SYN = achar ( int ( z '16' )) !! Synchronous idle character ( len = 1 ), public , parameter :: ETB = achar ( int ( z '17' )) !! End of transmission block character ( len = 1 ), public , parameter :: CAN = achar ( int ( z '18' )) !! Cancel character ( len = 1 ), public , parameter :: EM = achar ( int ( z '19' )) !! End of medium character ( len = 1 ), public , parameter :: SUB = achar ( int ( z '1A' )) !! Substitute character ( len = 1 ), public , parameter :: ESC = achar ( int ( z '1B' )) !! Escape character ( len = 1 ), public , parameter :: FS = achar ( int ( z '1C' )) !! File separator character ( len = 1 ), public , parameter :: GS = achar ( int ( z '1D' )) !! Group separator character ( len = 1 ), public , parameter :: RS = achar ( int ( z '1E' )) !! Record separator character ( len = 1 ), public , parameter :: US = achar ( int ( z '1F' )) !! Unit separator character ( len = 1 ), public , parameter :: DEL = achar ( int ( z '7F' )) !! Delete ! Constant character sequences character ( len =* ), public , parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" !! 0 .. 9A .. Fa .. f character ( len =* ), public , parameter :: hex_digits = fullhex_digits ( 1 : 16 ) !! 0 .. 9A .. F character ( len =* ), public , parameter :: lowerhex_digits = \"0123456789abcdef\" !! 0 .. 9a .. f character ( len =* ), public , parameter :: digits = hex_digits ( 1 : 10 ) !! 0 .. 9 character ( len =* ), public , parameter :: octal_digits = digits ( 1 : 8 ) !! 0 .. 7 character ( len =* ), public , parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" !! A .. Za .. z character ( len =* ), public , parameter :: uppercase = letters ( 1 : 26 ) !! A .. Z character ( len =* ), public , parameter :: lowercase = letters ( 27 :) !! a .. z character ( len =* ), public , parameter :: whitespace = \" \" // TAB // VT // CR // LF // FF !! ASCII _whitespace !> Returns a new character sequence which is the lower case !> version of the input character sequence !> This method is pure and returns a character sequence interface to_lower module procedure :: to_lower end interface to_lower !> Returns a new character sequence which is the upper case !> version of the input character sequence !> This method is pure and returns a character sequence interface to_upper module procedure :: to_upper end interface to_upper !> Returns a new character sequence which is the title case !> version of the input character sequence !> This method is pure and returns a character sequence interface to_title module procedure :: to_title end interface to_title !> Returns a new character sequence which is the sentence case !> version of the input character sequence !> This method is pure and returns a character sequence interface to_sentence module procedure :: to_sentence end interface to_sentence !> Returns a new character sequence which is reverse of !> the input charater sequence !> This method is pure and returns a character sequence interface reverse module procedure :: reverse end interface reverse contains !> Checks whether `c` is an ASCII letter (A .. Z, a .. z). pure logical function is_alpha ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alpha = ( c >= 'A' . and . c <= 'Z' ) . or . ( c >= 'a' . and . c <= 'z' ) end function !> Checks whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z). pure logical function is_alphanum ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alphanum = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'z' ) & . or . ( c >= 'A' . and . c <= 'Z' ) end function !> Checks whether or not `c` is in the ASCII character set - !> i.e. in the range 0 .. 0x7F. pure logical function is_ascii ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_ascii = iachar ( c ) <= int ( z '7F' ) end function !> Checks whether `c` is a control character. pure logical function is_control ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_control = ic < int ( z '20' ) . or . ic == int ( z '7F' ) end function !> Checks whether `c` is a digit (0 .. 9). pure logical function is_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_digit = ( '0' <= c ) . and . ( c <= '9' ) end function !> Checks whether `c` is a digit in base 8 (0 .. 7). pure logical function is_octal_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_octal_digit = ( c >= '0' ) . and . ( c <= '7' ); end function !> Checks whether `c` is a digit in base 16 (0 .. 9, A .. F, a .. f). pure logical function is_hex_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_hex_digit = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'f' ) & . or . ( c >= 'A' . and . c <= 'F' ) end function !> Checks whether or not `c` is a punctuation character. That includes !> all ASCII characters which are not control characters, letters, !> digits, or whitespace. pure logical function is_punctuation ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !       '~'                 '!' is_punctuation = ( ic <= int ( z '7E' )) . and . ( ic >= int ( z '21' )) . and . & (. not . is_alphanum ( c )) end function !> Checks whether or not `c` is a printable character other than the !> space character. pure logical function is_graphical ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is graphical if it's between '!' and '~' in the ASCII table, !that is: printable but not a space is_graphical = ( int ( z '21' ) <= ic ) . and . ( ic <= int ( z '7E' )) end function !> Checks whether or not `c` is a printable character - including the !> space character. pure logical function is_printable ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is printable if it's between ' ' and '~' in the ASCII table is_printable = ic >= iachar ( ' ' ) . and . ic <= int ( z '7E' ) end function !> Checks whether `c` is a lowercase ASCII letter (a .. z). pure logical function is_lower ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_lower = ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' ) end function !> Checks whether `c` is an uppercase ASCII letter (A .. Z). pure logical function is_upper ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_upper = ( c >= 'A' ) . and . ( c <= 'Z' ) end function !> Checks whether or not `c` is a whitespace character. That includes the !> space, tab, vertical tab, form feed, carriage return, and linefeed !> characters. pure logical function is_white ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB, LF, VT, FF, CR is_white = ( c == ' ' ) . or . ( ic >= int ( z '09' ) . and . ic <= int ( z '0D' )); end function !> Checks whether or not `c` is a blank character. That includes the !> only the space and tab characters pure logical function is_blank ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB is_blank = ( c == ' ' ) . or . ( ic == int ( z '09' )); end function !> Returns the corresponding lowercase letter, if `c` is an uppercase !> ASCII character, otherwise `c` itself. pure function char_to_lower ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: k k = index ( uppercase , c ) if ( k > 0 ) then t = lowercase ( k : k ) else t = c endif end function char_to_lower !> Returns the corresponding uppercase letter, if `c` is a lowercase !> ASCII character, otherwise `c` itself. pure function char_to_upper ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: k k = index ( lowercase , c ) if ( k > 0 ) then t = uppercase ( k : k ) else t = c endif end function char_to_upper !> Convert character variable to lower case !> ([Specification](../page/specs/stdlib_ascii.html#to_lower)) !> !> Version: experimental pure function to_lower ( string ) result ( lower_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lower_string integer :: i do i = 1 , len ( string ) lower_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_lower !> Convert character variable to upper case !> ([Specification](../page/specs/stdlib_ascii.html#to_upper)) !> !> Version: experimental pure function to_upper ( string ) result ( upper_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: upper_string integer :: i do i = 1 , len ( string ) upper_string ( i : i ) = char_to_upper ( string ( i : i )) end do end function to_upper !> Converts character sequence to title case !> ([Specification](../page/specs/stdlib_ascii.html#to_title)) !> !> Version: experimental pure function to_title ( string ) result ( title_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: title_string integer :: i logical :: capitalize_switch capitalize_switch = . true . do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then if ( capitalize_switch ) then title_string ( i : i ) = char_to_upper ( string ( i : i )) capitalize_switch = . false . else title_string ( i : i ) = char_to_lower ( string ( i : i )) end if else title_string ( i : i ) = string ( i : i ) capitalize_switch = . true . end if end do end function to_title !> Converts character sequence to sentence case !> ([Specification](../page/specs/stdlib_ascii.html#to_sentence)) !> !> Version: experimental pure function to_sentence ( string ) result ( sentence_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: sentence_string integer :: i , n n = len ( string ) do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then sentence_string ( i : i ) = char_to_upper ( string ( i : i )) n = i exit else sentence_string ( i : i ) = string ( i : i ) end if end do do i = n + 1 , len ( string ) sentence_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_sentence !> Reverse the character order in the input character variable !> ([Specification](../page/specs/stdlib_ascii.html#reverse)) !> !> Version: experimental pure function reverse ( string ) result ( reverse_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: reverse_string integer :: i , n n = len ( string ) do i = 1 , n reverse_string ( n - i + 1 : n - i + 1 ) = string ( i : i ) end do end function reverse # : for kind in INT_KINDS !> Represent an integer of kind ${kind}$ as character sequence pure function to_string_integer_$ { kind }$ ( val ) result ( string ) integer , parameter :: ik = ${ kind }$ integer ( ik ), intent ( in ) :: val character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer ( ik ) :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0_ik ) then string = numbers ( 0 ) return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0_ik ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10_ik )) n = n / 10_ik end do if ( val < 0_ik ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function to_string_integer_$ { kind }$ # : endfor # : for kind in LOG_KINDS !> Represent an logical of kind ${kind}$ as character sequence pure function to_string_logical_$ { kind }$ ( val ) result ( string ) integer , parameter :: ik = ${ kind }$ logical ( ik ), intent ( in ) :: val character ( len = 1 ) :: string string = merge ( \"T\" , \"F\" , val ) end function to_string_logical_$ { kind }$ # : endfor end module stdlib_ascii","tags":"","loc":"sourcefile/stdlib_ascii.fypp.html"},{"title":"stdlib_strings.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_strings.f90~~EfferentGraph sourcefile~stdlib_strings.f90 stdlib_strings.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_strings Source Code stdlib_strings.f90 Source Code ! SPDX-Identifier: MIT !> This module implements basic string handling routines. !> !> The specification of this module is available [here](../page/specs/stdlib_strings.html). module stdlib_strings use stdlib_ascii , only : whitespace use stdlib_string_type , only : string_type , char , verify , repeat , len use stdlib_optval , only : optval implicit none private public :: strip , chomp public :: starts_with , ends_with public :: slice , find , replace_all , padl , padr , count !> Remove leading and trailing whitespace characters. !> !> Version: experimental interface strip module procedure :: strip_string module procedure :: strip_char end interface strip !> Remove trailing characters in set from string. !> If no character set is provided trailing whitespace is removed. !> !> Version: experimental interface chomp module procedure :: chomp_string module procedure :: chomp_char module procedure :: chomp_set_string_char module procedure :: chomp_set_char_char module procedure :: chomp_substring_string_string module procedure :: chomp_substring_char_string module procedure :: chomp_substring_string_char module procedure :: chomp_substring_char_char end interface chomp !> Check whether a string starts with substring or not !> !> Version: experimental interface starts_with module procedure :: starts_with_string_string module procedure :: starts_with_string_char module procedure :: starts_with_char_string module procedure :: starts_with_char_char end interface starts_with !> Check whether a string ends with substring or not !> !> Version: experimental interface ends_with module procedure :: ends_with_string_string module procedure :: ends_with_string_char module procedure :: ends_with_char_string module procedure :: ends_with_char_char end interface ends_with !> Extracts characters from the input string to return a new string !> !> Version: experimental interface slice module procedure :: slice_string module procedure :: slice_char end interface slice !> Finds the starting index of substring 'pattern' in the input 'string' !> [Specifications](link to the specs - to be completed) !> !> Version: experimental interface find module procedure :: find_string_string module procedure :: find_string_char module procedure :: find_char_string module procedure :: find_char_char end interface find !> Replaces all the occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Version: experimental interface replace_all module procedure :: replace_all_string_string_string module procedure :: replace_all_string_string_char module procedure :: replace_all_string_char_string module procedure :: replace_all_char_string_string module procedure :: replace_all_string_char_char module procedure :: replace_all_char_string_char module procedure :: replace_all_char_char_string module procedure :: replace_all_char_char_char end interface replace_all !> Version: experimental !> !> Left pad the input string !> [Specifications](../page/specs/stdlib_strings.html#padl) interface padl module procedure :: padl_string_default module procedure :: padl_string_pad_with module procedure :: padl_char_default module procedure :: padl_char_pad_with end interface padl !> Version: experimental !> !> Right pad the input string !> [Specifications](../page/specs/stdlib_strings.html#padr) interface padr module procedure :: padr_string_default module procedure :: padr_string_pad_with module procedure :: padr_char_default module procedure :: padr_char_pad_with end interface padr !> Version: experimental !> !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> [Specifications](../page/specs/stdlib_strings.html#count) interface count module procedure :: count_string_string module procedure :: count_string_char module procedure :: count_char_string module procedure :: count_char_char end interface count contains !> Remove leading and trailing whitespace characters. pure function strip_string ( string ) result ( stripped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use stdlib_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: stripped_string stripped_string = strip ( char ( string )) end function strip_string !> Remove leading and trailing whitespace characters. pure function strip_char ( string ) result ( stripped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: stripped_string integer :: first , last first = verify ( string , whitespace ) if ( first == 0 ) then stripped_string = \"\" else last = verify ( string , whitespace , back = . true .) stripped_string = string ( first : last ) end if end function strip_char !> Remove trailing characters in set from string. !> Default character set variant where trailing whitespace is removed. pure function chomp_string ( string ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use stdlib_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = char ( string , 1 , last ) end function chomp_string !> Remove trailing characters in set from string. !> Default character set variant where trailing whitespace is removed. pure function chomp_char ( string ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = string ( 1 : last ) end function chomp_char !> Remove trailing characters in set from string. pure function chomp_set_string_char ( string , set ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use stdlib_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), set ) end function chomp_set_string_char !> Remove trailing characters in set from string. pure function chomp_set_char_char ( string , set ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , set_to_string ( set ), back = . true .) chomped_string = string ( 1 : last ) end function chomp_set_char_char !> Remove trailing substrings from string. pure function chomp_substring_string_string ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use stdlib_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), char ( substring )) end function chomp_substring_string_string !> Remove trailing substrings from string. pure function chomp_substring_string_char ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use stdlib_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), substring ) end function chomp_substring_string_char !> Remove trailing substrings from string. pure function chomp_substring_char_string ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string chomped_string = chomp ( string , char ( substring )) end function chomp_substring_char_string !> Remove trailing substrings from string. pure function chomp_substring_char_char ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( nsub > 0 ) then do while ( string ( last - nsub + 1 : last ) == substring ) last = last - nsub end do end if chomped_string = string ( 1 : last ) end function chomp_substring_char_char !> Implementation to transfer a set of characters to a string representing the set. !> !> This function is internal and not part of the public API. pure function set_to_string ( set ) result ( string ) character ( len = 1 ), intent ( in ) :: set (:) character ( len = size ( set )) :: string string = transfer ( set , string ) end function set_to_string !> Check whether a string starts with substring or not pure function starts_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: nsub nsub = len ( substring ) if ( len ( string ) < nsub ) then match = . false . return end if match = string ( 1 : nsub ) == substring end function starts_with_char_char !> Check whether a string starts with substring or not elemental function starts_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), substring ) end function starts_with_string_char !> Check whether a string starts with substring or not elemental function starts_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( string , char ( substring )) end function starts_with_char_string !> Check whether a string starts with substring or not elemental function starts_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), char ( substring )) end function starts_with_string_string !> Check whether a string ends with substring or not pure function ends_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( last < nsub ) then match = . false . return end if match = string ( last - nsub + 1 : last ) == substring end function ends_with_char_char !> Check whether a string ends with substring or not elemental function ends_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), substring ) end function ends_with_string_char !> Check whether a string ends with substring or not elemental function ends_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( string , char ( substring )) end function ends_with_char_string !> Check whether a string ends with substring or not elemental function ends_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), char ( substring )) end function ends_with_string_string !> Extract the characters from the region between 'first' and 'last' index (both inclusive) !> of the input 'string' by taking strides of length 'stride' !> Returns a new string elemental function slice_string ( string , first , last , stride ) result ( sliced_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride type ( string_type ) :: sliced_string sliced_string = string_type ( slice ( char ( string ), first , last , stride )) end function slice_string !> Extract the characters from the region between 'first' and 'last' index (both inclusive) !> of the input 'string' by taking strides of length 'stride' !> Returns a new string pure function slice_char ( string , first , last , stride ) result ( sliced_string ) character ( len =* ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride integer :: first_index , last_index , stride_vector , strides_taken , length_string , i , j character ( len = :), allocatable :: sliced_string length_string = len ( string ) first_index = 0 ! first_index = -infinity last_index = length_string + 1 ! last_index = +infinity stride_vector = 1 if ( present ( stride )) then if ( stride /= 0 ) then if ( stride < 0 ) then first_index = length_string + 1 ! first_index = +infinity last_index = 0 ! last_index = -infinity end if stride_vector = stride end if else if ( present ( first ) . and . present ( last )) then if ( last < first ) then stride_vector = - 1 end if end if end if if ( present ( first )) then first_index = first end if if ( present ( last )) then last_index = last end if if ( stride_vector > 0 ) then first_index = max ( first_index , 1 ) last_index = min ( last_index , length_string ) else first_index = min ( first_index , length_string ) last_index = max ( last_index , 1 ) end if strides_taken = floor ( real ( last_index - first_index ) / real ( stride_vector ) ) allocate ( character ( len = max ( 0 , strides_taken + 1 )) :: sliced_string ) j = 1 do i = first_index , last_index , stride_vector sliced_string ( j : j ) = string ( i : i ) j = j + 1 end do end function slice_char !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_string_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), char ( pattern ), occurrence , consider_overlapping ) end function find_string_string !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_string_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), pattern , occurrence , consider_overlapping ) end function find_string_char !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_char_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( string , char ( pattern ), occurrence , consider_overlapping ) end function find_char_string !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_char_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern , occurrence_ occurrence_ = optval ( occurrence , 1 ) res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string & & . and . occurrence_ > 0 ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then occurrence_ = occurrence_ - 1 if ( occurrence_ == 0 ) then res = s_i - length_pattern + 1 exit else if ( optval ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function find_char_char !> Computes longest prefix suffix for each index of the input 'string' !> !> Returns an array of integers pure function compute_lps ( string ) result ( lps_array ) character ( len =* ), intent ( in ) :: string integer :: lps_array ( len ( string )) integer :: i , j , length_string length_string = len ( string ) if ( length_string > 0 ) then lps_array ( 1 ) = 0 i = 2 j = 1 do while ( i <= length_string ) if ( string ( j : j ) == string ( i : i )) then lps_array ( i ) = j i = i + 1 j = j + 1 else if ( j > 1 ) then j = lps_array ( j - 1 ) + 1 else lps_array ( i ) = 0 i = i + 1 end if end do end if end function compute_lps !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_string_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), & & char ( pattern ), char ( replacement ))) end function replace_all_string_string_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_string_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), char ( pattern ), replacement )) end function replace_all_string_string_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_char_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , char ( replacement ))) end function replace_all_string_char_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_string_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), char ( replacement )) end function replace_all_char_string_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_char_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , replacement )) end function replace_all_string_char_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_string_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), replacement ) end function replace_all_char_string_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_char_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , pattern , char ( replacement )) end function replace_all_char_char_string !> Replaces all the occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_char_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res integer :: lps_array ( len ( pattern )) integer :: s_i , p_i , last , length_string , length_pattern res = \"\" length_string = len ( string ) length_pattern = len ( pattern ) last = 1 if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res // & & string ( last : s_i - length_pattern ) // & & replacement last = s_i + 1 p_i = 0 end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if res = res // string ( last : length_string ) end function replace_all_char_char_char !> Left pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padl_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , \" \" )) end function padl_string_default !> Left pad the input string with the 'pad_with' character !> !> Returns a new string pure function padl_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , pad_with )) end function padl_string_pad_with !> Left pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padl_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = padl ( string , output_length , \" \" ) end function padl_char_default !> Left pad the input string with the 'pad_with' character !> !> Returns a new string pure function padl_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) if ( string_length < output_length ) then res = repeat ( pad_with , output_length - string_length ) res ( output_length - string_length + 1 : output_length ) = string else res = string end if end function padl_char_pad_with !> Right pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padr_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: char_output type ( string_type ) :: res ! We're taking advantage of `char_output` being longer than `string` and ! initialized with whitespaces. By casting `string` to a `character` ! type and back to `string_type`, we're effectively right-padding ! `string` with spaces, so we don't need to pad explicitly. char_output = char ( string ) res = string_type ( char_output ) end function padr_string_default !> Right pad the input string with the 'pad_with' character !> !> Returns a new string pure function padr_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padr ( char ( string ), output_length , pad_with )) end function padr_string_pad_with !> Right pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padr_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = string end function padr_char_default !> Right pad the input string with the 'pad_with' character !> !> Returns a new string pure function padr_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) res = string if ( string_length < output_length ) then res ( string_length + 1 : output_length ) = & repeat ( pad_with , output_length - string_length ) end if end function padr_char_pad_with !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_string_string ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), char ( pattern ), consider_overlapping ) end function count_string_string !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_string_char ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), pattern , consider_overlapping ) end function count_string_char !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_char_string ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( string , char ( pattern ), consider_overlapping ) end function count_char_string !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_char_char ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res + 1 if ( optval ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function count_char_char end module stdlib_strings","tags":"","loc":"sourcefile/stdlib_strings.f90.html"},{"title":"stdlib_bitsets_large.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_bitsets_large.fypp~~EfferentGraph sourcefile~stdlib_bitsets_large.fypp stdlib_bitsets_large.fypp sourcefile~stdlib_bitsets.fypp stdlib_bitsets.fypp sourcefile~stdlib_bitsets_large.fypp->sourcefile~stdlib_bitsets.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_bitsets.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_bitsets_large Source Code stdlib_bitsets_large.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_bitsets ) stdlib_bitsets_large implicit none contains elemental module function all_large ( self ) result ( all ) !     Returns .TRUE. if all bits in SELF are 1, .FALSE. otherwise. logical :: all class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ) :: block , full_blocks , pos all = . true . full_blocks = bits ( self ) / block_size do block = 1_bits_kind , full_blocks if ( self % blocks ( block ) /= - 1_block_kind ) then all = . false . return end if end do if ( full_blocks == size ( self % blocks ) ) return do pos = 0_bits_kind , modulo ( bits ( self ), block_size ) - 1 if ( . not . btest ( self % blocks ( full_blocks + 1 ), pos ) ) then all = . false . return end if end do end function all_large elemental module subroutine and_large ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise AND of the original bits in SET1 !     and SET2. It is required that SET1 have the same number of bits as !     SET2 otherwise the result is undefined. ! type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 integer ( bits_kind ) :: block_ do block_ = 1_bits_kind , size ( set1 % blocks , kind = bits_kind ) set1 % blocks ( block_ ) = iand ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) end do end subroutine and_large elemental module subroutine and_not_large ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise and of the original bits in SET1 !     with the bitwise negation of SET2. SET1 and SET2 must have the same !     number of bits otherwise the result is undefined. ! type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 integer ( bits_kind ) :: block_ do block_ = 1_bits_kind , size ( set1 % blocks , kind = bits_kind ) set1 % blocks ( block_ ) = & iand ( set1 % blocks ( block_ ), not ( set2 % blocks ( block_ ) ) ) end do end subroutine and_not_large elemental module function any_large ( self ) result ( any ) !     Returns .TRUE. if any bit in SELF is 1, .FALSE. otherwise. logical :: any class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ) :: block_ do block_ = 1_bits_kind , size ( self % blocks , kind = bits_kind ) if ( self % blocks ( block_ ) /= 0 ) then any = . true . return end if end do any = . false . end function any_large pure module subroutine assign_large ( set1 , set2 ) !     Used to define assignment for bitset_large type ( bitset_large ), intent ( out ) :: set1 type ( bitset_large ), intent ( in ) :: set2 set1 % num_bits = set2 % num_bits allocate ( set1 % blocks ( size ( set2 % blocks , kind = bits_kind ) ) ) set1 % blocks (:) = set2 % blocks (:) end subroutine assign_large # : for k1 in INT_KINDS pure module subroutine assign_log$ { k1 }$_ large ( self , logical_vector ) !     Used to define assignment from an array of type logical for bitset_large type ( bitset_large ), intent ( out ) :: self logical ( ${ k1 }$ ), intent ( in ) :: logical_vector (:) integer ( bits_kind ) :: blocks integer ( bits_kind ) :: log_size integer ( bits_kind ) :: index log_size = size ( logical_vector , kind = bits_kind ) self % num_bits = log_size if ( log_size == 0 ) then blocks = 0 else blocks = ( log_size - 1 ) / block_size + 1 end if allocate ( self % blocks ( blocks ) ) self % blocks (:) = 0 do index = 0_bits_kind , log_size - 1 if ( logical_vector ( index + 1 ) ) then call self % set ( index ) end if end do end subroutine assign_log$ { k1 }$_ large pure module subroutine log ${ k1 }$_ assign_large ( logical_vector , set ) !     Used to define assignment to an array of type logical for bitset_large logical ( ${ k1 }$ ), intent ( out ), allocatable :: logical_vector (:) type ( bitset_large ), intent ( in ) :: set integer ( bits_kind ) :: index allocate ( logical_vector ( set % num_bits ) ) do index = 0_bits_kind , set % num_bits - 1 if ( set % value ( index ) == 1 ) then logical_vector ( index + 1 ) = . true . else logical_vector ( index + 1 ) = . false . end if end do end subroutine log ${ k1 }$_ assign_large # : endfor elemental module function bit_count_large ( self ) result ( bit_count ) !     Returns the number of non-zero bits in SELF. integer ( bits_kind ) :: bit_count class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ) :: block_ , pos bit_count = 0 do block_ = 1_bits_kind , size ( self % blocks , kind = bits_kind ) - 1 do pos = 0 , block_size - 1 if ( btest ( self % blocks ( block_ ), pos ) ) & bit_count = bit_count + 1 end do end do do pos = 0_bits_kind , self % num_bits - ( block_ - 1 ) * block_size - 1 if ( btest ( self % blocks ( block_ ), pos ) ) bit_count = bit_count + 1 end do end function bit_count_large elemental module subroutine clear_bit_large ( self , pos ) ! !     Sets to zero the POS position in SELF. If POS is less than zero or !     greater than BITS(SELF)-1 it is ignored. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos integer :: clear_block , block_bit if ( pos < 0 . OR . ( pos > self % num_bits - 1 ) ) return clear_block = pos / block_size + 1 block_bit = pos - ( clear_block - 1 ) * block_size self % blocks ( clear_block ) = & ibclr ( self % blocks ( clear_block ), block_bit ) end subroutine clear_bit_large pure module subroutine clear_range_large ( self , start_pos , stop_pos ) ! !     Sets to zero all bits from the START_POS to STOP_POS positions in SELF. !     If STOP_POS < START_POS then no bits are modified. Positions outside !     the range 0 to BITS(SELF)-1 are ignored. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: bit , block_ , first_block , last_block , & true_first , true_last true_first = max ( 0_bits_kind , start_pos ) true_last = min ( self % num_bits - 1 , stop_pos ) if ( true_last < true_first ) return first_block = true_first / block_size + 1 last_block = true_last / block_size + 1 if ( first_block == last_block ) then !     TRUE_FIRST and TRUE_LAST are in the same block call mvbits ( all_zeros , & true_first - ( first_block - 1 ) * block_size , & true_last - true_first + 1 , & self % blocks ( first_block ), & true_first - ( first_block - 1 ) * block_size ) return end if !     Do \"partial\" black containing FIRST bit = true_first - ( first_block - 1 ) * block_size call mvbits ( all_zeros , & bit , & block_size - bit , & self % blocks ( first_block ), & bit ) !     Do \"partial\" black containing LAST bit = true_last - ( last_block - 1 ) * block_size call mvbits ( all_zeros , & 0 , & bit + 1 , & self % blocks ( last_block ), & 0 ) !     Do intermediate blocks do block_ = first_block + 1 , last_block - 1 self % blocks ( block_ ) = all_zeros end do end subroutine clear_range_large elemental module function eqv_large ( set1 , set2 ) result ( eqv ) ! !     Returns .TRUE. if all bits in SET1 and SET2 have the same value, !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: eqv type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block , common_blocks eqv = . false . common_blocks = size ( set1 % blocks , kind = bits_kind ) do block = 1 , common_blocks if ( set1 % blocks ( block ) /= set2 % blocks ( block ) ) return end do eqv = . true . end function eqv_large module subroutine extract_large ( new , old , start_pos , stop_pos , status ) !    Creates a new bitset, NEW, from a range, START_POS to STOP_POS, in bitset !    OLD. If START_POS is greater than STOP_POS the new bitset is empty. !    If START_POS is less than zero or STOP_POS is greater than BITS(OLD)-1 !    then if STATUS is present it has the value INDEX_INVALID_ERROR, !    otherwise processing stops with an informative message. type ( bitset_large ), intent ( out ) :: new type ( bitset_large ), intent ( in ) :: old integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer , intent ( out ), optional :: status integer ( bits_kind ) :: bits , blocks , ex_block , i , j , k , old_block character ( * ), parameter :: procedure = 'EXTRACT' if ( start_pos < 0 ) then call error_handler ( 'had a START_POS less than 0.' , & index_invalid_error , status , & module_name , procedure ) return end if if ( stop_pos >= old % num_bits ) then call error_handler ( 'had a STOP_POS greater than BITS(OLD)-1.' , & index_invalid_error , status , & module_name , procedure ) return end if bits = stop_pos - start_pos + 1 if ( bits <= 0 ) then new % num_bits = 0 allocate ( new % blocks ( 0 ) ) return end if blocks = (( bits - 1 ) / block_size ) + 1 new % num_bits = bits allocate ( new % blocks ( blocks ) ) new % blocks (:) = 0 do i = 0_bits_kind , bits - 1 ex_block = i / block_size + 1 j = i - ( ex_block - 1 ) * block_size old_block = ( start_pos + i ) / block_size + 1 k = ( start_pos + i ) - ( old_block - 1 ) * block_size if ( btest ( old % blocks ( old_block ), k ) ) then new % blocks ( ex_block ) = ibset ( new % blocks ( ex_block ), j ) end if end do if ( present ( status ) ) status = success end subroutine extract_large elemental module subroutine flip_bit_large ( self , pos ) ! !     Flips the value at the POS position in SELF, provided the position is !     valid. If POS is less than 0 or greater than BITS(SELF)-1, no value is !     changed. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos integer ( bits_kind ) :: flip_block , block_bit if ( pos < 0 . OR . pos > self % num_bits - 1 ) return flip_block = pos / block_size + 1 block_bit = pos - ( flip_block - 1 ) * block_size if ( btest ( self % blocks ( flip_block ), block_bit ) ) then self % blocks ( flip_block ) = ibclr ( self % blocks ( flip_block ), & block_bit ) else self % blocks ( flip_block ) = ibset ( self % blocks ( flip_block ), & block_bit ) end if end subroutine flip_bit_large pure module subroutine flip_range_large ( self , start_pos , stop_pos ) ! !     Flips all valid bits from the START_POS to the STOP_POS positions in !     SELF. If STOP_POS < START_POS no bits are flipped. Positions less than !     0 or greater than BITS(SELF)-1 are ignored. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: bit , block_ , end_bit , first_block , last_block , & start_bit start_bit = max ( 0_bits_kind , start_pos ) end_bit = min ( stop_pos , self % num_bits - 1 ) if ( end_bit < start_bit ) return first_block = start_bit / block_size + 1 last_block = end_bit / block_size + 1 if ( first_block == last_block ) then !         FIRST and LAST are in the same block call mvbits ( not ( self % blocks ( first_block )), & start_bit - ( first_block - 1 ) * block_size , & end_bit - start_bit + 1 , & self % blocks ( first_block ), & start_bit - ( first_block - 1 ) * block_size ) return end if !     Do \"partial\" black containing FIRST bit = start_bit - ( first_block - 1 ) * block_size call mvbits ( not ( self % blocks ( first_block ) ), & bit , & block_size - bit , & self % blocks ( first_block ), & bit ) !     Do \"partial\" black containing LAST bit = end_bit - ( last_block - 1 ) * block_size call mvbits ( not ( self % blocks ( last_block ) ), & 0 , & bit + 1 , & self % blocks ( last_block ), & 0 ) !     Do remaining blocks do block_ = first_block + 1 , last_block - 1 self % blocks ( block_ ) = not ( self % blocks ( block_ ) ) end do end subroutine flip_range_large module subroutine from_string_large ( self , string , status ) !     Initializes the bitset `self` treating `string` as a binary literal !     `status` may have the values: !         `success` - if no problems were found, !         `alloc_fault` - if allocation of the bitset failed !         `char_string_too_large_error` - if `string` was too large, or !         `char_string_invalid_error` - if string had an invalid character. class ( bitset_large ), intent ( out ) :: self character ( * ), intent ( in ) :: string integer , intent ( out ), optional :: status character ( * ), parameter :: procedure = 'FROM_STRING' integer ( int64 ) :: bit integer ( int64 ) :: bits character ( 1 ) :: char bits = len ( string , kind = int64 ) if ( bits > huge ( 0_bits_kind ) ) then call error_handler ( 'STRING was too long for a ' // & 'BITSET_LARGE SELF.' , & char_string_too_large_error , status , & module_name , procedure ) return end if call init_zero_large ( self , int ( bits , kind = bits_kind ), status ) if ( present ( status ) ) then if ( status /= success ) return end if do bit = 1_bits_kind , bits char = string ( bit : bit ) if ( char == '0' ) then call self % clear ( int ( bits - bit , kind = bits_kind ) ) else if ( char == '1' ) then call self % set ( int ( bits - bit , kind = bits_kind ) ) else call error_handler ( 'STRING had a character other than ' // & '0 or 1.' , & char_string_invalid_error , status , & module_name , procedure ) return end if end do if ( present ( status ) ) status = success end subroutine from_string_large elemental module function ge_large ( set1 , set2 ) result ( ge ) ! !     Returns .TRUE. if the bits in SET1 and SET2 are the same or the !     highest order different bit is set to 1 in SET1 and to 0 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: ge type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block_ do block_ = size ( set1 % blocks , kind = bits_kind ), 1_bits_kind , - 1 if ( set1 % blocks ( block_ ) == set2 % blocks ( block_ ) ) then cycle else if ( bgt ( set1 % blocks ( block_ ), set2 % blocks ( block_ ) ) ) then ge = . true . return else ge = . false . return end if end do ge = . true . end function ge_large elemental module function gt_large ( set1 , set2 ) result ( gt ) ! !     Returns .TRUE. if the bits in SET1 and SET2 differ and the !     highest order different bit is set to 1 in SET1 and to 0 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: gt type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block_ do block_ = size ( set1 % blocks , kind = bits_kind ), 1_bits_kind , - 1 if ( set1 % blocks ( block_ ) == set2 % blocks ( block_ ) ) then cycle else if ( bgt ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) ) then gt = . true . return else gt = . false . return end if end do gt = . false . end function gt_large module subroutine init_zero_large ( self , bits , status ) ! !  Creates the bitset, `self`, of size `bits`, with all bits initialized to !  zero. `bits` must be non-negative.  If an error occurs and `status` is !  absent then processing stops with an informative stop code. `status` !  will have one of the values; !  * `success` -  if no problems were found, !  * `array_size_invalid_error` - if `bits` is either negative or larger !    than 64 with `self` of class `bitset_64`, or !  * `alloc_fault` - if memory allocation failed ! class ( bitset_large ), intent ( out ) :: self integer ( bits_kind ), intent ( in ) :: bits integer , intent ( out ), optional :: status character ( len = 120 ) :: message character ( * ), parameter :: procedure = \"INIT\" integer :: blocks , ierr message = '' if ( bits < 0 ) then call error_handler ( 'BITS had a negative value.' , & array_size_invalid_error , status , & module_name , procedure ) return end if if ( bits == 0 ) then self % num_bits = 0 allocate ( self % blocks ( 0 ), stat = ierr , errmsg = message ) if ( ierr /= 0 ) go to 998 return else blocks = (( bits - 1 ) / block_size ) + 1 end if self % num_bits = bits allocate ( self % blocks ( blocks ), stat = ierr , errmsg = message ) if ( ierr /= 0 ) go to 998 self % blocks (:) = all_zeros if ( present ( status ) ) status = success return 998 call error_handler ( 'Allocation failure for SELF.' , & alloc_fault , status , & module_name , procedure ) end subroutine init_zero_large module subroutine input_large ( self , unit , status ) ! ! Reads the components of the bitset, `self`, from the unformatted I/O ! unit, `unit`, assuming that the components were written using `output`. ! If an error occurs and `status` is absent then processing stops with ! an informative stop code. `status` has one of the values: ! * `success` - if no problem was found ! * `alloc_fault` - if it failed during allocation of memory for `self`, or ! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative !   or greater than 64 for a `bitset_64` input. ! * `read_failure` - if it failed during the reads from `unit` ! class ( bitset_large ), intent ( out ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status integer ( bits_kind ) :: bits integer :: ierr character ( len = 120 ) :: message character ( * ), parameter :: procedure = 'INPUT' integer :: stat read ( unit , iostat = ierr , iomsg = message ) bits if ( ierr /= 0 ) then call error_handler ( 'Failure on a READ statement for UNIT.' , & read_failure , status , module_name , procedure ) return end if if ( bits < 0 ) then call error_handler ( 'BITS in UNIT had a negative value.' , & array_size_invalid_error , status , & module_name , procedure ) return end if call self % init ( bits , stat ) if ( stat /= success ) then call error_handler ( 'Allocation failure for SELF.' , & alloc_fault , status , module_name , procedure ) return end if if ( bits < 1 ) return read ( unit , iostat = ierr , iomsg = message ) self % blocks (:) if ( ierr /= 0 ) then call error_handler ( 'Failure on a READ statement for UNIT.' , & read_failure , status , module_name , procedure ) return end if if ( present ( status ) ) status = success end subroutine input_large elemental module function le_large ( set1 , set2 ) result ( le ) ! !     Returns .TRUE. if the bits in SET1 and SET2 are the same or the !     highest order different bit is set to 0 in SET1 and to 1 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: le type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block_ do block_ = size ( set1 % blocks , kind = bits_kind ), 1_bits_kind , - 1 if ( set1 % blocks ( block_ ) == set2 % blocks ( block_ ) ) then cycle else if ( blt ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) ) then le = . true . return else le = . false . return end if end do le = . true . end function le_large elemental module function lt_large ( set1 , set2 ) result ( lt ) ! !     Returns .TRUE. if the bits in SET1 and SET2 differ and the !     highest order different bit is set to 0 in SET1 and to 1 in set2. !     .FALSE.  otherwise.  The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: lt type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block_ do block_ = size ( set1 % blocks , kind = bits_kind ), 1_bits_kind , - 1 if ( set1 % blocks ( block_ ) == set2 % blocks ( block_ ) ) then cycle else if ( blt ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) ) then lt = . true . return else lt = . false . return end if end do lt = . false . end function lt_large elemental module function neqv_large ( set1 , set2 ) result ( neqv ) ! !     Returns .TRUE. if any bits in SET1 and SET2 differ in  value, !     .FALSE.  otherwise. The sets must have the same number of bits !     otherwise the results are undefined. ! logical :: neqv type ( bitset_large ), intent ( in ) :: set1 , set2 integer ( bits_kind ) :: block_ neqv = . true . do block_ = 1_bits_kind , size ( set1 % blocks , kind = bits_kind ) if ( set1 % blocks ( block_ ) /= set2 % blocks ( block_ ) ) return end do neqv = . false . end function neqv_large elemental module function none_large ( self ) result ( none ) ! !     Returns .TRUE. if none of the bits in SELF have the value 1. ! logical :: none class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ) :: block none = . true . do block = 1_bits_kind , size ( self % blocks , kind = bits_kind ) if ( self % blocks ( block ) /= 0 ) then none = . false . return end if end do end function none_large elemental module subroutine not_large ( self ) ! !     Sets the bits in SELF to their logical complement ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ) :: bit , full_blocks , block integer :: remaining_bits if ( self % num_bits == 0 ) return full_blocks = self % num_bits / block_size do block = 1_bits_kind , full_blocks self % blocks ( block ) = not ( self % blocks ( block ) ) end do remaining_bits = self % num_bits - full_blocks * block_size do bit = 0 , remaining_bits - 1 if ( btest ( self % blocks ( block ), bit ) ) then self % blocks ( block ) = ibclr ( self % blocks ( block ), bit ) else self % blocks ( block ) = ibset ( self % blocks ( block ), bit ) end if end do end subroutine not_large elemental module subroutine or_large ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise OR of the original bits in SET1 !     and SET2. SET1 and SET2 must have the same number of bits otherwise !     the result is undefined. ! type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 integer ( bits_kind ) :: block_ do block_ = 1 , size ( set1 % blocks , kind = bits_kind ) set1 % blocks ( block_ ) = ior ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) end do end subroutine or_large module subroutine output_large ( self , unit , status ) ! !     Writes the components of the bitset, SELF, to the unformatted I/O !     unit, UNIT, in a unformatted sequence compatible with INPUT. If !     STATUS is absent an error results in an error stop with an !     informative stop code. If STATUS is present it has the default !     value of SUCCESS, or the value WRITE_FAILURE if the write failed. ! class ( bitset_large ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( out ), optional :: status integer :: ierr character ( len = 120 ) :: message character ( * ), parameter :: procedure = \"OUTPUT\" write ( unit , iostat = ierr , iomsg = message ) self % num_bits if ( ierr /= 0 ) go to 999 if ( self % num_bits < 1 ) return write ( unit , iostat = ierr , iomsg = message ) self % blocks (:) if ( ierr /= 0 ) go to 999 return 999 call error_handler ( 'Failure on a WRITE statement for UNIT.' , & write_failure , status , module_name , procedure ) end subroutine output_large module subroutine read_bitset_string_large ( self , string , status ) ! !     Uses the bitset literal in the default character `string`, to define !     the bitset, `self`. The literal may be preceded by an an arbitrary !     sequence of blank characters. If `status` is absent an error results !     in an error stop with an informative stop code. If `status` !     is present it has one of the values !     * `success` - if no problems occurred, !     * `alloc_fault` - if allocation of memory for SELF failed, !     * `array_size_invalid_error - if `bits(self)` in `string` is greater !       than 64 for a `bitset_64`, !     * `char_string_invalid_error` - if the bitset literal has an invalid !       character, !     * `char_string_too_small_error - if the string ends before all the bits !       are read. !     * `integer_overflow_error` - if the bitset literal has a `bits(self)` !       value too large to be represented, ! class ( bitset_large ), intent ( out ) :: self character ( len =* ), intent ( in ) :: string integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , bits integer ( bits_kind ) :: digits , pos character ( * ), parameter :: procedure = \"READ_BITSET\" integer :: stat pos = 1 find_start : do pos = 1_bits_kind , len ( string , kind = bits_kind ) if ( string ( pos : pos ) /= ' ' ) exit end do find_start if ( pos > len ( string ) - 8 ) go to 999 if ( string ( pos : pos ) /= 's' . AND . string ( pos : pos ) /= 'S' ) go to 999 pos = pos + 1 bits = 0 digits = 0 do select case ( iachar ( string ( pos : pos ) ) ) case ( ia0 : ia9 ) digits = digits + 1 if ( digits == max_digits . AND . bits > overflow_bits ) go to 996 if ( digits > max_digits ) go to 996 bits = bits * 10 + iachar ( string ( pos : pos ) ) - ia0 if ( bits < 0 ) go to 996 case ( iachar ( 'b' ), iachar ( 'B' )) exit case default call error_handler ( 'There was an invalid character ' // & 'in STRING' , & char_string_invalid_error , status , & module_name , procedure ) return end select pos = pos + 1 end do if ( bits + pos > len ( string ) ) then call error_handler ( 'STRING was too small for the number of ' // & 'bits specified by STRING.' , & char_string_too_small_error , status , & module_name , procedure ) return end if call self % init ( bits , stat ) if ( stat /= success ) then call error_handler ( 'There was an allocation fault for SELF.' , & alloc_fault , status , module_name , procedure ) return end if pos = pos + 1 bit = bits - 1 do if ( string ( pos : pos ) == '0' ) then call self % clear ( bit ) else if ( string ( pos : pos ) == '1' ) then call self % set ( bit ) else go to 999 end if pos = pos + 1 bit = bit - 1 if ( bit < 0 ) exit end do if ( present ( status ) ) status = success return 996 call error_handler ( 'There was an integer overflow in reading' // & 'size of bitset literal from UNIT' , & integer_overflow_error , status , & module_name , procedure ) return 999 call error_handler ( 'There was an invalid character in STRING' , & char_string_invalid_error , status , & module_name , procedure ) end subroutine read_bitset_string_large module subroutine read_bitset_unit_large ( self , unit , advance , status ) ! !     Uses the bitset literal at the current position in the formatted !     file with I/O unit, `unit`, to define the bitset, `self`. The literal !     may be preceded by an arbitrary sequence of blank characters. !     If `advance` is present it must be either 'YES' or 'NO'. If absent !     it has the default value of 'YES' to determine whether advancing !     I/O occurs. If `status` is absent an error results in an error stop !     with an informative stop code. If `status` is present it has one of !     the values: !     * `success` - if no problem occurred, !     * `alloc_fault` - if allocation of `self` failed, !     * `array_size_invalid_error` - if `bits(self)` in the bitset literal !       is greater than 64 for a `bitset_64`. !     * `char_string_invalid_error` - if the read of the bitset literal found !       an invalid character, !     * `eof_failure` - if a `read` statement reaches an end-of-file before !       completing the read of the bitset literal, !     * `integer_overflow_error` - if the bitset literal has a `bits(self)` !       value too large to be represented, !     * `read_failure` - if a `read` statement fails, ! class ( bitset_large ), intent ( out ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , bits , digits integer :: ierr character ( len = 128 ) :: message character ( * ), parameter :: procedure = \"READ_BITSET\" character ( len = 1 ) :: char do read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char select case ( char ) case ( ' ' ) cycle case ( 's' , 'S' ) exit case default go to 999 end select end do bits = 0 digits = 0 do read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char if ( char == 'b' . or . char == 'B' ) exit select case ( char ) case ( '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ) digits = digits + 1 if ( digits == max_digits . AND . bits > overflow_bits ) & go to 996 if ( digits > max_digits ) go to 996 bits = 10 * bits + iachar ( char ) - iachar ( '0' ) if ( bits < 0 ) go to 996 case default go to 999 end select end do if ( bits < 0 . OR . digits == 0 . OR . digits > max_digits ) go to 999 call self % init ( bits , status ) if ( present ( status ) ) then call error_handler ( 'There was an allocation fault for SELF.' , & alloc_fault , status , module_name , procedure ) return end if do bit = 1 , bits - 1 read ( unit , & advance = 'NO' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char if ( char == '0' ) then call self % clear ( bits - bit ) else if ( char == '1' ) then call self % set ( bits - bit ) else go to 999 end if end do if ( present ( advance ) ) then read ( unit , & advance = advance , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char else read ( unit , & advance = 'YES' , & FMT = '(A1)' , & err = 997 , & end = 998 , & iostat = ierr , & iomsg = message ) char end if if ( char == '0' ) then call self % clear ( bits - bit ) else if ( char == '1' ) then call self % set ( bits - bit ) else go to 999 end if if ( present ( status ) ) status = success return 996 call error_handler ( 'Integer overflow in reading size of ' // & 'bitset literal from UNIT.' , & read_failure , status , module_name , procedure ) return 997 call error_handler ( 'Failure on read of UNIT.' , & read_failure , status , module_name , procedure ) return 998 call error_handler ( 'End of File of UNIT before finishing a ' // & 'bitset literal.' , & eof_failure , status , module_name , procedure ) return 999 call error_handler ( 'Invalid character in bitset literal in UNIT ' , & char_string_invalid_error , status , & module_name , procedure ) end subroutine read_bitset_unit_large elemental module subroutine set_bit_large ( self , pos ) ! !     Sets the value at the POS position in SELF, provided the position is !     valid. If the position is less than 0 or greater than BITS(SELF)-1 !     then SELF is unchanged. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: pos integer ( bits_kind ) :: set_block , block_bit if ( pos < 0 . OR . pos > self % num_bits - 1 ) return set_block = pos / block_size + 1 block_bit = pos - ( set_block - 1 ) * block_size self % blocks ( set_block ) = ibset ( self % blocks ( set_block ), block_bit ) end subroutine set_bit_large pure module subroutine set_range_large ( self , start_pos , stop_pos ) ! !     Sets all valid bits to 1 from the START_POS to the STOP_POS positions !     in SELF. If STOP_POA < START_POS no bits are changed. Positions outside !     the range 0 to BITS(SELF)-1 are ignored. ! class ( bitset_large ), intent ( inout ) :: self integer ( bits_kind ), intent ( in ) :: start_pos , stop_pos integer ( bits_kind ) :: bit , block_ , end_bit , first_block , last_block , & start_bit start_bit = max ( 0_bits_kind , start_pos ) end_bit = min ( stop_pos , self % num_bits - 1 ) if ( end_bit < start_bit ) return first_block = start_bit / block_size + 1 last_block = end_bit / block_size + 1 if ( first_block == last_block ) then !         FIRST and LAST are in the same block call mvbits ( all_ones , & start_bit - ( first_block - 1 ) * block_size , & end_bit - start_bit + 1 , & self % blocks ( first_block ), & start_bit - ( first_block - 1 ) * block_size ) return end if !     Do \"partial\" black containing FIRST bit = start_bit - ( first_block - 1 ) * block_size call mvbits ( all_ones , & bit , & block_size - bit , & self % blocks ( first_block ), & bit ) !     Do \"partial\" black containing LAST bit = end_bit - ( last_block - 1 ) * block_size call mvbits ( all_ones , & 0 , & bit + 1 , & self % blocks ( last_block ), & 0 ) ! Do remaining blocks do block_ = first_block + 1 , last_block - 1 self % blocks ( block_ ) = all_ones end do end subroutine set_range_large elemental module function test_large ( self , pos ) result ( test ) ! !     Returns .TRUE. if the POS position is set, .FALSE. otherwise. If POS !     is negative or greater than BITS(SELF) - 1 the result is .FALSE.. ! logical :: test class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos integer ( bits_kind ) :: bit_block if ( pos < 0 . or . pos >= self % num_bits ) then test = . false . else bit_block = pos / block_size + 1 test = btest ( self % blocks ( bit_block ), & pos - ( bit_block - 1 ) * block_size ) end if end function test_large module subroutine to_string_large ( self , string , status ) ! !     Represents the value of SELF as a binary literal in STRING !     Status may have the values SUCCESS or ALLOC_FAULT ! class ( bitset_large ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status character ( * ), parameter :: procedure = 'TO_STRING' integer ( bits_kind ) :: bit , bit_count , pos integer :: stat bit_count = self % num_bits allocate ( character ( len = bit_count ) :: string , stat = stat ) if ( stat > 0 ) then call error_handler ( 'There was an allocation fault for STRING.' , & alloc_fault , status , module_name , procedure ) return end if do bit = 0_bits_kind , bit_count - 1 pos = bit_count - bit if ( self % test ( bit ) ) then string ( pos : pos ) = '1' else string ( pos : pos ) = '0' end if end do if ( present ( status ) ) status = success end subroutine to_string_large elemental module function value_large ( self , pos ) result ( value ) ! !     Returns 1 if the POS position is set, 0 otherwise. If POS is negative !     or greater than BITS(SELF) - 1 the result is 0. ! integer :: value class ( bitset_large ), intent ( in ) :: self integer ( bits_kind ), intent ( in ) :: pos integer :: bit_block if ( pos < 0 . or . pos >= self % num_bits ) then value = 0 else bit_block = pos / block_size + 1 if ( btest ( self % blocks ( bit_block ), & pos - ( bit_block - 1 ) * block_size ) ) then value = 1 else value = 0 end if end if end function value_large module subroutine write_bitset_string_large ( self , string , status ) ! !     Writes a bitset literal to the allocatable default character STRING, !     representing the individual bit values in the bitset_t, SELF. !     If STATUS is absent an error results in an error stop with an !     informative stop code. If STATUS is present it has the default !     value of SUCCESS, or the value ALLOC_FAULT if allocation of !     the output string failed. ! class ( bitset_large ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ) :: string integer , intent ( out ), optional :: status integer ( bits_kind ) :: bit , & bit_count , & count_digits , & pos integer :: stat character ( * ), parameter :: procedure = 'WRITE_BITSET' bit_count = bits ( self ) call digit_count ( self % num_bits , count_digits ) allocate ( character ( len = count_digits + bit_count + 2 ) :: string , stat = stat ) if ( stat > 0 ) then call error_handler ( 'There was an allocation fault for STRING.' , & alloc_fault , status , module_name , procedure ) return end if write ( string , \"('S', i0)\" ) self % num_bits string ( count_digits + 2 : count_digits + 2 ) = \"B\" do bit = 0_bits_kind , bit_count - 1 pos = count_digits + 2 + bit_count - bit if ( self % test ( bit ) ) then string ( pos : pos ) = '1' else string ( pos : pos ) = '0' end if end do if ( present ( status ) ) status = success contains subroutine digit_count ( bits , digits ) integer ( bits_kind ), intent ( in ) :: bits integer ( bits_kind ), intent ( out ) :: digits integer ( bits_kind ) :: factor factor = bits if ( factor <= 0 ) then digits = 1 return end if do digits = 1 , 127 factor = factor / 10 if ( factor == 0 ) return end do end subroutine digit_count end subroutine write_bitset_string_large module subroutine write_bitset_unit_large ( self , unit , advance , status ) ! !     Writes a bitset literal to the I/O unit, UNIT, representing the !     individual bit values in the bitset_t, SELF. By default or if !     ADVANCE is present with the value 'YES', advancing output is used. !     If ADVANCE is present with the value 'NO', then the current record !     is not advanced by the write. If STATUS is absent an error results !     in an error stop with an informative stop code. If STATUS is !     present it has the default value of SUCCESS, the value !     ALLOC_FAULT if allocation of the output string failed, or !     WRITE_FAILURE if the WRITE statement outputting the literal failed. ! class ( bitset_large ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: advance integer , intent ( out ), optional :: status integer :: ierr character (:), allocatable :: string character ( len = 120 ) :: message character ( * ), parameter :: procedure = \"WRITE_BITSET\" call self % write_bitset ( string , status ) if ( present ( status ) ) then if ( status /= success ) return end if if ( present ( advance ) ) then write ( unit , & FMT = '(A)' , & advance = advance , & iostat = ierr , & iomsg = message ) & string else write ( unit , & FMT = '(A)' , & advance = 'YES' , & iostat = ierr , & iomsg = message ) & string end if if ( ierr /= 0 ) then call error_handler ( 'Failure on a WRITE statement for UNIT.' , & write_failure , status , module_name , procedure ) return endif end subroutine write_bitset_unit_large elemental module subroutine xor_large ( set1 , set2 ) ! !     Sets the bits in SET1 to the bitwise XOR of the original bits in SET1 !     and SET2. SET1 and SET2 must have the same number of bits otherwise !     the result is undefined. ! type ( bitset_large ), intent ( inout ) :: set1 type ( bitset_large ), intent ( in ) :: set2 integer ( bits_kind ) :: block_ do block_ = 1_bits_kind , size ( set1 % blocks , kind = bits_kind ) set1 % blocks ( block_ ) = ieor ( set1 % blocks ( block_ ), & set2 % blocks ( block_ ) ) end do end subroutine xor_large end submodule stdlib_bitsets_large","tags":"","loc":"sourcefile/stdlib_bitsets_large.fypp.html"},{"title":"stdlib_logger.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_logger.f90~~EfferentGraph sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_logger.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_logger Source Code stdlib_logger.f90 Source Code module stdlib_logger !!### Module stdlib_logger !! !! This module defines a derived type, procedures, a variable, and !! constants to be used for logging information and reporting errors !! in Fortran applications. !!([Specification](../page/specs/stdlib_logger.html)) !! The derived type, `logger_type`, is to be used to define variables to !! serve as both local and global loggers. A logger directs its messages !! to selected I/O units so the user has a record (a log) of major events. !! For each entity of `logger_type` the reports go to a list of I/O units !! represented by the private internal array, `log_units`. If `log_units` is !! empty then output by default goes to `output_unit`. Otherwise reports !! go to `output_unit` only if it has been explicitly added to `log_units`. !! Each entity of type `logger_type` also maintains an internal state !! controlling the formatting of output. !! !! The procedures are as follows. The logical function !! `log_units_assigned` returns the number of I/O units in `log_units`. The !! subroutines `add_log_file` and `add_log_unit` include the specified file !! in `log_units`. `remove_log_units` removes the specified logical unit from !! the `log_units` array and optionally closes the file. `configure` !! configures the details of the logging process. `configuration` !! reports the details of that configuration. The subroutines !! `log_error`, `log_information`, `log_io_error`, `log_message`, !! `log_text_error`, and `log_warning` send messages to the log units. !! !! The variable `global_logger` of type `logger_type` can be used !! as a default global logger anywhere in the source code. !! !! The constants are used to report errors by some of the subroutines !! in their optional `stat` arguments. The constants are as follows. !! `success` indicates that no error has occurred. `close_failure` !! indicates that a `close` statement for an I/O unit failed. !! `index_invalid_error` indicates that `column` was invalid for !! the given `line`. `open_failure` indicates that an `open` statement !! failed. `read_only_error` indicates that an output unit did not have a !! `\"write\"` or `\"readwrite\"` action. `non_sequential_error` indicates !! that the unit did not have `sequential` access. `unformatted_in_error` !! indicates that the unit did not have a `form` of `\"formatted\"`. !! `unopened_in_error` indicates that the unit was not opened. `write_failure` !! indicates that at least one of the writes to `log_units` failed. use , intrinsic :: & iso_fortran_env , only : & error_unit , & input_unit , & output_unit use stdlib_ascii , only : to_lower use stdlib_optval , only : optval implicit none private public :: global_logger , logger_type !! public constants used as error flags integer , parameter , public :: & success = 0 , & close_failure = 1 , & index_invalid_error = 2 , & non_sequential_error = 3 , & open_failure = 4 , & read_only_error = 5 , & unformatted_in_error = 6 , & unopened_in_error = 7 , & write_failure = 8 integer , parameter , public :: & debug_level = 10 , & information_level = 20 , & warning_level = 30 , & error_level = 40 , & io_error_level = 40 , & text_error_level = 50 , & all_level = - 10 + min ( & debug_level , & information_level , & warning_level , & error_level , & io_error_level , & text_error_level ), & none_level = 10 + max ( & debug_level , & information_level , & warning_level , & error_level , & io_error_level , & text_error_level ) character ( * ), parameter :: module_name = 'stdlib_logger' type :: logger_type !! version: experimental !! Public derived type ([Specification](../page/specs/stdlib_logger.html#the-derived-type-logger_type)) private logical :: add_blank_line = . false . logical :: indent_lines = . true . integer :: level = information_level integer , allocatable :: log_units (:) integer :: max_width = 0 logical :: time_stamp = . true . integer :: units = 0 contains private procedure , public , pass ( self ) :: add_log_file procedure , public , pass ( self ) :: add_log_unit procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: log_debug procedure , public , pass ( self ) :: log_error procedure , public , pass ( self ) :: log_information procedure , public , pass ( self ) :: log_io_error procedure , public , pass ( self ) :: log_message procedure , public , pass ( self ) :: log_text_error procedure , public , pass ( self ) :: log_units_assigned procedure , public , pass ( self ) :: log_warning procedure , public , pass ( self ) :: remove_log_unit final :: final_logger end type logger_type !! Variable of type `logger_type` to be used as a global logger type ( logger_type ) :: global_logger character ( * ), parameter :: & invalid_column = 'column is not a valid index to line.' contains subroutine add_log_file ( self , filename , unit , action , position , status , & stat ) !! version: experimental !! Opens a formatted sequential access output file, `filename` using !! `newunit` and adds the resulting unit number to `self`'s `log_units` !! array. `action`, if present, is the `action` specifier of the `open` !! statement, and has the default value of `\"write\"`. `position`, if present, !! is the `position` specifier, and has the default value of `\"REWIND\"`. !! `status`, if present, is the `status` specifier of the `open` statement, !! and has the default value of `\"REPLACE\"`. `stat`, if present, has the value !! `success` if `filename` could be opened, `read_only_error` if `action` is !! `\"read\"`, and `open_failure` otherwise. !!([Specification](../page/specs/stdlib_logger.html#add_log_file-open-a-file-and-add-its-unit-to-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable to which the file is to be added character ( * ), intent ( in ) :: filename !! The name of the file to be  added to the logger integer , intent ( out ), optional :: unit !! The resulting I/O unit number character ( * ), intent ( in ), optional :: action !! The `action` specifier for the `open`` statement character ( * ), intent ( in ), optional :: position !! The `position` specifier for the `open` statement character ( * ), intent ( in ), optional :: status !! The `status` specifier for the  `open`  statement integer , intent ( out ), optional :: stat !! The error status on exit with the possible values !! * `success` - no errors found !! * `read_only_error` - file unopened as `action1 was `\"read\"` for an output !!   file !! * `open_failure` - the `open` statement failed !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         integer :: unit, stat !!         ... !!         call global_logger % add_log_file( 'error_log.txt', unit,      & !!                                            position='asis', stat=stat ) !!         if ( stat /= success ) then !!             error stop 'Unable to open \"error_log.txt\".' !!         end if !!         ... !!     end program main character ( 16 ) :: aaction , aposition , astatus integer :: aunit character ( 128 ) :: iomsg integer :: iostat character ( * ), parameter :: procedure_name = 'add_log_file' integer , allocatable :: dummy (:) integer :: lun integer :: i aaction = optval ( action , 'write' ) aposition = optval ( position , 'rewind' ) astatus = optval ( status , 'replace' ) if ( len_trim ( aaction ) == 4 ) then do i = 1 , 4 aaction ( i : i ) = to_lower ( aaction ( i : i )) end do if ( aaction == 'read' ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'In ' // module_name // ' % ' // & procedure_name // ' action is \"read\" which ' // & 'does not allow writes to the file.' end if end if end if open ( newunit = aunit , file = filename , form = 'formatted' , action = aaction , & position = aposition , status = astatus , iostat = iostat , iomsg = iomsg , & err = 999 ) if ( allocated ( self % log_units ) ) then if ( size ( self % log_units ) == self % units ) then allocate ( dummy ( 2 * self % units ) ) do lun = 1 , self % units dummy ( lun ) = self % log_units ( lun ) end do dummy ( self % units + 1 :) = 0 call move_alloc ( dummy , self % log_units ) end if else allocate ( self % log_units ( 16 ) ) end if self % log_units ( self % units + 1 ) = aunit self % units = self % units + 1 if ( present ( unit ) ) unit = aunit if ( present ( stat ) ) stat = success return 999 if ( present ( stat ) ) then stat = open_failure return else call self % log_io_error ( 'Unable to open ' // trim ( filename ), & module = module_name , & procedure = procedure_name , & iostat = iostat , & iomsg = iomsg ) error stop module_name // ' % ' // procedure_name // & ': Unable to open file' end if end subroutine add_log_file subroutine add_log_unit ( self , unit , stat ) !! version: experimental !! Adds `unit` to the log file units in `log_units`. `unit` must be an `open` !! file, of `form` `\"formatted\"`, with `\"sequential\"` `access`, and an `action` !! of `\"write\"` or `\"readwrite\"`, otherwise either `stat`, if present, has a !! value other than `success` and `unit` is not entered into `log_units`, !! or, if `stat` is not presecn, processing stops. !!([Specification](../page/specs/stdlib_logger.html#add_log_unit-add-a-unit-to-the-array-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable to which the I/O unit is to be added integer , intent ( in ) :: unit !! The input logical unit number integer , intent ( out ), optional :: stat !! An error code with the possible values !! * `success` - no problems were found !! * `non_sequential_error` - `unit` did not have sequential access !! * `read_only_error` - `unit` was not writeable !! * `unformatted_in_error` - `unit` was an `'unformatted'` file !! * `unopened_in_error` - `unit` was not opened !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         character(256) :: iomsg !!         integer :: iostat, unit, stat !!         ... !!         open( newunit=unit, 'error_log.txt', form='formatted', & !!               status='replace', position='rewind', err=999,    & !!               action='read', iostat=iostat, iomsg=iomsg ) !!         ... !!         call global_logger % add_log_unit( unit, stat ) !!         select case ( stat ) !!         ... !!         case ( read_only_error ) !!             error stop 'Unable to write to \"error_log.txt\".' !!         ... !!         end select !!         ... !!     999 error stop 'Unable to open \"error_log.txt\". !!         ... !!     end program main integer , allocatable :: dummy (:) character ( * ), parameter :: procedure_name = 'set_log_unit' integer :: lun character ( 12 ) :: specifier logical :: question integer :: istat call validate_unit () if ( present ( stat ) ) then if ( stat /= success ) return end if do lun = 1 , self % units ! Check that unit is not already registered if ( self % log_units ( lun ) == unit ) return end do if ( allocated ( self % log_units ) ) then if ( size ( self % log_units ) == self % units ) then allocate ( dummy ( 2 * self % units ) ) do lun = 1 , self % units dummy ( lun ) = self % log_units ( lun ) end do call move_alloc ( dummy , self % log_units ) end if else allocate ( self % log_units ( 16 ) ) end if self % log_units ( self % units + 1 ) = unit self % units = self % units + 1 contains subroutine validate_unit () ! Check that unit is not input_unit if ( unit == input_unit ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' must not be input_unit.' end if end if ! Check that unit is opened inquire ( unit , opened = question , iostat = istat ) if ( istat /= 0 ) question = . false . if ( . not . question ) then if ( present ( stat ) ) then stat = unopened_in_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not open.' end if end if ! Check that unit is writeable inquire ( unit , write = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not writeable.' end if end if inquire ( unit , sequential = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = non_sequential_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not \"sequential\".' end if end if inquire ( unit , formatted = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = unformatted_in_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not \"formatted\".' end if end if if ( present ( stat ) ) stat = success end subroutine validate_unit end subroutine add_log_unit pure subroutine configuration ( self , add_blank_line , indent , level , & max_width , time_stamp , log_units ) !! version: experimental !! Reports the logging configuration of `self`. The following attributes are !! reported: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !! 2. `indent` is a logical flag with `.true.` implying that subsequent columns !!    will be indented 4 spaces and `.false.` implying no indentation. !! 3. `level` is the lowest level for printing a message !! 4. `max_width` is the maximum number of columns of output text with !!    `max_width` == 0 => no bounds on output width. !! 5. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. !! 6. `log_units` is an array of the I/O unit numbers to which log output !!    will be written. !!([Specification](../page/specs/stdlib_logger.html#configuration-report-a-loggers-configuration)) class ( logger_type ), intent ( in ) :: self !! The logger variable whose configuration is being reported logical , intent ( out ), optional :: add_blank_line !! A logical flag to add a preceding blank line logical , intent ( out ), optional :: indent !! A logical flag to indent subsequent lines integer , intent ( out ), optional :: level !! The minimum level for printing a message integer , intent ( out ), optional :: max_width !! The maximum number of columns for most outputs logical , intent ( out ), optional :: time_stamp !! A logical flag to add a time stamp integer , intent ( out ), allocatable , optional :: log_units (:) !! The I/O units used in output !!##### Example !! !!     module example_mod !!       use stdlib_logger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         call global_logger % configuration( log_units=log_units ) !!         if ( size(log_units) == 0 ) then !!            call add_logger_unit( unit ) !!         end if !!         .. !!       end subroutine example_sub !!       ... !!     end module example_mod if ( present ( add_blank_line ) ) add_blank_line = self % add_blank_line if ( present ( indent ) ) indent = self % indent_lines if ( present ( level ) ) level = self % level if ( present ( max_width ) ) max_width = self % max_width if ( present ( time_stamp ) ) time_stamp = self % time_stamp if ( present ( log_units ) ) then if ( self % units . gt . 0 ) then log_units = self % log_units ( 1 : self % units ) else allocate ( log_units ( 0 )) end if end if end subroutine configuration pure subroutine configure ( self , add_blank_line , indent , level , max_width , & time_stamp ) !! version: experimental !! Configures the logging process for SELF. The following attributes are !! configured: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !!    `add_blank_line` has a startup value of `.false.`. !! 2. `indent` is a logical flag with `.true.` implying that subsequent lines !!    will be indented 4 spaces and `.false.` implying no indentation. `indent` !!    has a startup value of `.true.`. !! 3. `level` is the lowest level for printing a message !! 4. `max_width` is the maximum number of columns of output text with !!    `max_width == 0` => no bounds on output width. `max_width` has a startup !!    value of 0. !! 5. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. `time_stamp` has a startup value of `.true.`. !!([Specification](../page/specs/stdlib_logger.html#configure-configure-the-logging-process)) !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         call global_logger % configure( indent=.false., max_width=72 ) !!         ... class ( logger_type ), intent ( inout ) :: self logical , intent ( in ), optional :: add_blank_line logical , intent ( in ), optional :: indent integer , intent ( in ), optional :: level integer , intent ( in ), optional :: max_width logical , intent ( in ), optional :: time_stamp if ( present ( add_blank_line ) ) self % add_blank_line = add_blank_line if ( present ( level ) ) self % level = level if ( present ( indent ) ) self % indent_lines = indent if ( present ( max_width ) ) then if ( max_width <= 4 ) then self % max_width = 0 else self % max_width = max_width end if end if if ( present ( time_stamp ) ) self % time_stamp = time_stamp end subroutine configure subroutine final_logger ( self ) !! version: experimental !! Finalizes the `logger_type` entity `self` by flushing the units type ( logger_type ), intent ( in ) :: self integer :: iostat character ( 256 ) :: message integer :: unit do unit = 1 , self % units flush ( self % log_units ( unit ), iomsg = message , iostat = iostat ) if ( iostat /= 0 ) then write ( error_unit , '(a, i0)' ) 'In the logger_type ' // & 'finalizer an error occurred in flushing unit = ' , & self % log_units ( unit ) write ( error_unit , '(a, i0)' ) 'With iostat = ' , iostat write ( error_unit , '(a)' ) 'With iomsg = ' // trim ( message ) end if end do end subroutine final_logger subroutine format_output_string ( self , string , col_indent , len_buffer , buffer ) !! version: experimental !! Writes the STRING to UNIT ensuring that the number of characters !! does not exceed MAX_WIDTH and that the lines after the first !! one are indented four characters. class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: col_indent integer , intent ( out ) :: len_buffer character ( len = :), allocatable , intent ( out ) :: buffer integer :: count , indent_len , index_ , length , remain integer , parameter :: new_len = len ( new_line ( 'a' )) length = len_trim ( string ) allocate ( character ( 2 * length ) :: buffer ) len_buffer = 0 indent_len = len ( col_indent ) call format_first_line () if ( self % indent_lines ) then do while ( remain > 0 ) call indent_format_subsequent_line () end do else do while ( remain > 0 ) call format_subsequent_line () end do end if contains subroutine format_first_line () if ( self % max_width == 0 . or . & ( length <= self % max_width . and . & index ( string ( 1 : length ), new_line ( 'a' )) == 0 ) ) then buffer ( 1 : length ) = string ( 1 : length ) len_buffer = length remain = 0 return else index_ = index ( string ( 1 : min ( length , self % max_width )), & new_line ( 'a' ) ) if ( index_ == 0 ) then do index_ = self % max_width , 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == 0 ) then buffer ( 1 : self % max_width ) = & string ( 1 : self % max_width ) len_buffer = self % max_width count = self % max_width remain = length - count return else buffer ( 1 : index_ - 1 ) = string ( 1 : index_ - 1 ) len_buffer = index_ - 1 count = index_ remain = length - count return end if end if end subroutine format_first_line subroutine format_subsequent_line () integer :: new_len_buffer character (:), allocatable :: dummy if ( remain <= self % max_width ) then new_len_buffer = len_buffer + length - count + new_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // string ( count + 1 : length ) len_buffer = new_len_buffer count = length remain = 0 return else index_ = count + index ( string ( count + 1 : count + self % max_width ),& new_line ( 'a' )) if ( index_ == count ) then do index_ = count + self % max_width , count + 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == count ) then new_len_buffer = len_buffer + self % max_width + & new_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // string ( count + 1 : count + self % max_width ) len_buffer = new_len_buffer count = count + self % max_width remain = length - count return else new_len_buffer = len_buffer + index_ - 1 & - count + new_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // string ( count + 1 : index_ - 1 ) len_buffer = new_len_buffer count = index_ remain = length - count return end if end if end subroutine format_subsequent_line subroutine indent_format_subsequent_line () integer :: new_len_buffer character (:), allocatable :: dummy if ( index ( string ( count + 1 : length ), new_line ( 'a' )) == 0 . and . & remain <= self % max_width - indent_len ) then new_len_buffer = len_buffer + length & - count + new_len + indent_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // col_indent // string ( count + 1 : length ) len_buffer = new_len_buffer count = length remain = 0 return else index_ = count + index ( string ( count + 1 : & min ( length , count + self % max_width - indent_len ) ), & new_line ( 'a' )) if ( index_ == count ) then do index_ = count + self % max_width - indent_len , count + 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == count ) then new_len_buffer = len_buffer + self % max_width & + new_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // col_indent // & string ( count + 1 : count + self % max_width - indent_len ) len_buffer = new_len_buffer count = count + self % max_width - indent_len remain = length - count return else new_len_buffer = len_buffer + index_ - count - 1 & + new_len + indent_len if ( new_len_buffer > len ( buffer ) ) then allocate ( character ( 2 * len ( buffer ) ) :: dummy ) dummy = buffer call move_alloc ( dummy , buffer ) end if buffer ( len_buffer + 1 : new_len_buffer ) = & new_line ( 'a' ) // col_indent // string ( count + 1 : index_ - 1 ) len_buffer = new_len_buffer count = index_ remain = length - count return end if end if end subroutine indent_format_subsequent_line end subroutine format_output_string subroutine handle_write_failure ( unit , procedure_name , iostat , iomsg ) !! version: experimental !! Handles a failure to write to `unit` in `procedure_name` with `iostat` and !! `iomsg` by writing a description of the failure to `output_unit` and !! stopping. integer , intent ( in ) :: unit character ( * ), intent ( in ) :: procedure_name integer , intent ( in ) :: iostat character ( * ), intent ( in ) :: iomsg character ( 256 ) :: name logical :: named character ( 10 ) :: action write ( output_unit , '(a)' ) 'write failure in ' // module_name // & ' % ' // trim ( procedure_name ) // '.' if ( unit == - 999 ) then write ( output_unit , '(a, i0)' ) 'unit = internal file' else write ( output_unit , '(a, i0)' ) 'unit = ' , unit inquire ( unit , named = named ) if ( named ) then inquire ( unit , name = name ) write ( output_unit , '(a, a)' ) 'name = ' , trim ( name ) else write ( output_unit , '(a)' ) 'unit is unnamed' end if inquire ( unit , action = action ) write ( output_unit , '(a, a)' ) 'action = ' , trim ( action ) end if write ( output_unit , '(a, i0)' ) 'iostat = ' , iostat write ( output_unit , '(a, a )' ) 'iomsg = ' , trim ( iomsg ) error stop 'write failure in ' // module_name // '.' end subroutine handle_write_failure subroutine log_debug ( self , message , module , procedure ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_debug-writes-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, and then `message` is !! written with the prefix 'DEBUG: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( selection ) !!         integer, intent(out) :: selection !!         integer        :: stat !!         write(*,'(a)') \"Enter an integer to select a widget\" !!         read(*,'(i0)') selection !!         write( message, `(a, i0)' )           & !!               \"The user selected \", selection !!         call alogger % log_debug( message,                   & !!                                   module = 'EXAMPLE_MOD',    & !!                                   procedure = 'EXAMPLE_SUB' ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger used to send the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of `log_information` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of !! `log_information` if ( self % level > debug_level ) return call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'DEBUG' ) end subroutine log_debug subroutine log_error ( self , message , module , procedure , stat , errmsg ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !! ([Specification](../specs/stdlib_logger.html#log_error-writes-the-string-message-to-self-log_units)) !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'ERROR: ', and then if `stat` or `errmsg` !! are present they are written. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size ) !!         integer, intent(in) :: size !!         character(128) :: errmsg, message !!         integer        :: stat !!         allocate( a(size), stat=stat, errmsg=errmsg ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               \"Allocation of A failed with SIZE = \", size !!           alogger % call log_error( message,                   & !!                                     module = 'EXAMPLE_MOD',    & !!                                     procedure = 'EXAMPLE_SUB', & !!                                     stat = stat,               & !!                                     errmsg = errmsg ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger to be used in logging the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of `log_error` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of `log_error` integer , intent ( in ), optional :: stat !! The value of the `stat` specifier returned by a Fortran statement character ( len =* ), intent ( in ), optional :: errmsg !! The value of the `errmsg` specifier returned by a Fortran statement integer :: iostat character ( 28 ) :: dummy character ( 256 ) :: iomsg character ( * ), parameter :: procedure_name = 'log_error' character (:), allocatable :: suffix if ( self % level > error_level ) return if ( present ( stat ) ) then write ( dummy , '(a, i0)' , err = 999 , iostat = iostat , iomsg = iomsg ) & new_line ( 'a' ) // \"With stat = \" , stat else dummy = ' ' end if if ( present ( errmsg ) ) then if ( len_trim ( errmsg ) > 0 ) then suffix = trim ( dummy ) // & new_line ( 'a' ) // 'With errmsg = \"' // trim ( errmsg ) // '\"' else suffix = dummy end if else suffix = dummy end if call self % log_message ( trim ( message ) // suffix , & module = module , & procedure = procedure , & prefix = 'ERROR' ) return 999 call handle_write_failure ( - 999 , procedure_name , iostat , iomsg ) end subroutine log_error subroutine log_information ( self , message , module , procedure ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_information-writes-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, and then `message` is !! written with the prefix 'INFO: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( selection ) !!         integer, intent(out) :: selection !!         integer        :: stat !!         write(*,'(a)') \"Enter an integer to select a widget\" !!         read(*,'(i0)') selection !!         write( message, `(a, i0)' )           & !!               \"The user selected \", selection !!         call alogger % log_information( message,                   & !!                                         module = 'EXAMPLE_MOD',    & !!                                         procedure = 'EXAMPLE_SUB' ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger used to send the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of `log_information` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of !! `log_information` if ( self % level > information_level ) return call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'INFO' ) end subroutine log_information subroutine log_io_error ( self , message , module , procedure , iostat , & iomsg ) !! version: experimental !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_io_error-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with a prefix 'I/O ERROR: ', and then if `iostat` or `iomsg` !! are present they are also written. !! !!##### Example !! !!    program example !!      use stdlib_logger !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: iostat, lun !!      character(128)          :: iomsg !!      character(*), parameter :: message = 'Failure in opening \"dummy.txt\".' !! !!      open( newunit=lun, file = filename, form='formatted', & !!            status='old', iostat=iostat, iomsg=iomsg ) !!      if ( iostat /= 0 ) then !!        call global_logger % log_io_error( message, procedure = 'EXAMPLE', & !!            iostat=iostat, iomsg = iomsg ) !!        error stop 'Error on opening ' // filename !!      end if !!      ... !!    end program example class ( logger_type ), intent ( in ) :: self !! The logger variable to receivee the message character ( len =* ), intent ( in ) :: message !! A string to be written to LOG_UNIT character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of REPORT_ERROR character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of REPORT_ERROR integer , intent ( in ), optional :: iostat !! The value of the IOSTAT specifier returned by a Fortran I/O statement character ( len =* ), intent ( in ), optional :: iomsg !! The value of the IOMSG specifier returned by a Fortran I/O statement character ( 28 ) :: dummy character ( 256 ) :: iomsg2 integer :: iostat2 character ( * ), parameter :: procedure_name = 'log_io_error' character (:), allocatable :: suffix if ( self % level > io_error_level ) return if ( present ( iostat ) ) then write ( dummy , '(a, i0)' , err = 999 , iostat = iostat2 , iomsg = iomsg2 ) & new_line ( 'a' ) // \"With iostat = \" , iostat else dummy = ' ' end if if ( present ( iomsg ) ) then if ( len_trim ( iomsg ) > 0 ) then suffix = trim ( dummy ) // & new_line ( 'a' ) // 'With iomsg = \"' // trim ( iomsg ) // '\"' else suffix = trim ( dummy ) end if else suffix = trim ( dummy ) end if call self % log_message ( trim ( message ) // suffix , & module = module , & procedure = procedure , & prefix = 'I/O ERROR' ) return 999 call handle_write_failure ( - 999 , procedure_name , iostat2 , iomsg2 ) end subroutine log_io_error subroutine log_message ( self , message , module , procedure , prefix ) !! version: experimental !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_message-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by `module` !! and `procedure` if present, followed by `prefix // ': '` if present, !! and then `message`. !! !!##### Example !! !!    module  example_mod !!      use stdlib_logger !!      ... !!      real, allocatable :: a(:) !!      ... !!    contains !!      ... !!      subroutine example_sub( selection ) !!        integer, intent(out) :: selection !!        integer        :: stat !!        write(*,'(a)') \"Enter an integer to select a widget\" !!        read(*,'(i0)') selection !!        write( message, `(a, i0)' )          & !!              \"The user selected \", selection !!        call global_logger % log_message( message,                   & !!                                          module = 'example_mod',    & !!                                          procedure = 'example_sub', & !!                                          prefix = 'info' ) !!      end subroutine example_sub !!      ... !!    end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger variable to receive the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of `log_message` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of `log_message` character ( len =* ), intent ( in ), optional :: prefix !! To be prepended to message as `prefix // ': ' // message`. integer :: unit integer :: iostat integer :: len_buffer character ( * ), parameter :: procedure_name = 'log_message' character ( 256 ) :: iomsg character (:), allocatable :: d_and_t , m_and_p , pref character (:), allocatable :: buffer if ( present ( prefix ) ) then pref = prefix // ': ' else pref = '' end if if ( self % time_stamp ) then d_and_t = time_stamp () // ': ' else d_and_t = '' end if if ( present ( module ) ) then if ( present ( procedure ) ) then m_and_p = trim ( module ) // ' % ' // trim ( procedure ) // ': ' else m_and_p = trim ( module ) // ': ' end if else if ( present ( procedure ) ) then m_and_p = trim ( procedure ) // ': ' else m_and_p = '' end if call format_output_string ( self , & d_and_t // m_and_p // pref // & trim ( message ), & '    ' , & len_buffer , & buffer ) if ( self % units == 0 ) then if ( self % add_blank_line ) then write ( output_unit , '(a)' , err = 999 , iostat = iostat , & iomsg = iomsg ) & new_line ( 'a' ) // buffer ( 1 : len_buffer ) else write ( output_unit , '(a)' , err = 999 , iostat = iostat , & iomsg = iomsg ) & buffer ( 1 : len_buffer ) end if else if ( self % add_blank_line ) then do unit = 1 , self % units write ( self % log_units ( unit ), '(a)' , err = 999 , iostat = iostat , & iomsg = iomsg ) new_line ( 'a' ) // & buffer ( 1 : len_buffer ) end do else do unit = 1 , self % units write ( self % log_units ( unit ), '(a)' , err = 999 , iostat = iostat , & iomsg = iomsg ) & buffer ( 1 : len_buffer ) end do end if end if return 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine log_message subroutine log_text_error ( self , line , column , summary , filename , & line_number , caret , stat ) !! version: experimental !! Sends a message to `self % log_units` describing an error found !! in a line of text. !!([Specification](../page/specs/stdlib_logger.html#log_text_error-send-a-message-to-self-log_units-describing-an-error)) !!##### Behavior !! !! If time stamps are active first a time stamp is written. Then if !! `filename` or `line_number` or `column` are present they are written. !! Then `line` is written. Then the symbol `caret` is written below `line` !! at the column indicated by `column`. Then `summary` is written. ! !!##### Example !! !!    program example !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: col_num, line_num, lun !!      character(128)          :: line !!      character(*), parameter :: message = 'Bad text found.' !! !!      open( newunit=lun, file = filename, statu='old', form='formatted' ) !!      line_num = 0 !!      do !!        read( lun, fmt='(a)', end=900 ) line !!        line_num = line_num + 1 !!        call check_line( line, status, col_num ) !!        if ( status /= 0 ) !!          call global_logger % log_text_error( line, col_num, message, & !!                                               filename, line_num ) !!          error stop 'Error in reading ' // filename !!        end if !!        ... !!      end do !!900   continue !!      ... !!    end program example !! class ( logger_type ), intent ( in ) :: self !! The logger variable to receive the message character ( * ), intent ( in ) :: line !! The line of text in which the error was found. integer , intent ( in ) :: column !! The one's based column in LINE at which the error starts. character ( * ), intent ( in ) :: summary !! A brief description of the error. character ( * ), intent ( in ), optional :: filename !! The name of the file, if any, in which the error was found. integer , intent ( in ), optional :: line_number !! The one's based line number in the file where `line` was found. character ( 1 ), intent ( in ), optional :: caret !! The symbol used to mark the column wher the error was first detected integer , intent ( out ), optional :: stat !! Integer flag that an error has occurred. Has the value `success` if no !! error hass occurred, `index_invalid_error` if `column` is less than zero or !! greater than `len(line)`, and `write_failure` if any of the `write` !! statements has failed. character ( 1 ) :: acaret character ( 128 ) :: iomsg integer :: iostat integer :: lun character ( * ), parameter :: procedure_name = 'LOG_TEXT_ERROR' character ( len = :), allocatable :: buffer if ( self % level > text_error_level ) return acaret = optval ( caret , '&#94;' ) if ( column < 0 . or . column > len ( line ) + 1 ) then if ( present ( stat ) ) then stat = index_invalid_error return else call self % log_error ( invalid_column , & module = module_name , & procedure = procedure_name ) error stop module_name // ' % ' // procedure_name // ': ' // & invalid_column end if end if call write_log_text_error_buffer ( ) if ( self % units == 0 ) then write ( output_unit , '(a)' ) buffer else do lun = 1 , self % units write ( self % log_units ( lun ), '(a)' ) buffer end do end if contains subroutine write_log_text_error_buffer ( ) integer :: i character (:), allocatable :: location , marker if ( present ( filename ) ) then if ( present ( line_number ) ) then allocate ( character ( len_trim ( filename ) + 15 ) :: location ) write ( location , fmt = '(a, \":\", i0, \":\", i0)' , err = 999 , & iomsg = iomsg , iostat = iostat ) & trim ( filename ) , line_number , column else allocate ( character ( len_trim ( filename ) + 45 ) :: location ) write ( location , fmt = '(a, i0)' , err = 999 , iomsg = iomsg , & iostat = iostat ) & \"Error found in file: '\" // trim ( filename ) // & \"', at column: \" , column end if else if ( present ( line_number ) ) then allocate ( character ( 54 ) :: location ) write ( location , fmt = '(a, i0, a, i0)' , err = 999 , & iomsg = iomsg , iostat = iostat ) & 'Error found at line number: ' , line_number , & ', and column: ' , column else allocate ( character ( 36 ) :: location ) write ( location , & fmt = '(\"Error found in line at column:\", i0)' ) & column end if end if allocate ( character ( column ) :: marker ) do i = 1 , column - 1 marker ( i : i ) = ' ' end do marker ( column : column ) = acaret if ( self % add_blank_line ) then if ( self % time_stamp ) then buffer = new_line ( 'a' ) // time_stamp () // & new_line ( 'a' ) // trim ( location ) // & new_line ( 'a' ) // new_line ( 'a' ) // trim ( line ) // & new_line ( 'a' ) // marker // & new_line ( 'a' ) // 'Error: ' // trim ( summary ) else buffer = new_line ( 'a' ) // trim ( location ) // & new_line ( 'a' ) // new_line ( 'a' ) // trim ( line ) // & new_line ( 'a' ) // marker // & new_line ( 'a' ) // 'Error: ' // trim ( summary ) end if else if ( self % time_stamp ) then buffer = time_stamp () // & new_line ( 'a' ) // trim ( location ) // & new_line ( 'a' ) // new_line ( 'a' ) // trim ( line ) // & new_line ( 'a' ) // marker // & new_line ( 'a' ) // 'Error: ' // trim ( summary ) else buffer = trim ( location ) // & new_line ( 'a' ) // new_line ( 'a' ) // trim ( line ) // & new_line ( 'a' ) // marker // & new_line ( 'a' ) // 'Error: ' // trim ( summary ) end if end if if ( present ( stat ) ) stat = success return 999 if ( present ( stat ) ) then stat = write_failure return else call handle_write_failure ( - 999 , procedure_name , iostat , & iomsg ) end if end subroutine write_log_text_error_buffer end subroutine log_text_error elemental function log_units_assigned ( self ) !! version: experimental !! Returns the number of units assigned to `self % log_units` !!([Specification](../page/specs/stdlib_logger.html#log_units_assigned-returns-the-number-of-active-io-units)) class ( logger_type ), intent ( in ) :: self !! The logger subject to the inquiry integer :: log_units_assigned !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         if ( alogger % log_units_assigned() == 0 ) then !!            call alogger % add_log_unit( unit ) !!         end if !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod log_units_assigned = self % units end function log_units_assigned subroutine log_warning ( self , message , module , procedure ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_warning-write-the-string-message-to-log_units)) !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'WARN: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size, stat ) !!         integer, intent(in)  :: size !!         integer, intent(out) :: stat !!         allocate( a(size) ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               \"Allocation of A failed with SIZE = \", size !!           call alogger % log_warning( message,                   & !!                                       module = 'EXAMPLE_MOD',    & !!                                       procedure = 'EXAMPLE_SUB' ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger to which the message is written character ( len =* ), intent ( in ) :: message !! A string to be written to LOG_UNIT character ( len =* ), intent ( in ), optional :: module !! The name of the module containing the current invocation of `log_warning` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure containing the current invocation of `log_warning` if ( self % level > warning_level ) return call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'WARN' ) end subroutine log_warning subroutine remove_log_unit ( self , unit , close_unit , stat ) !! version: experimental !! Remove the I/O unit from the self % log_units list. If `close_unit` is !! present and `.true.` then the corresponding file is closed. If `unit` is !! not in `log_units` then nothing is done. If `stat` is present it, by !! default, has the value `success`. If closing the `unit` fails, then if !! `stat` is present it has the value `close_failure`, otherwise processing !! stops with an informative message. !!([Specification](../page/specs/stdlib_logger.html#remove_log_unit-remove-unit-from-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable whose unit is to be removed integer , intent ( in ) :: unit !! The I/O unit to be removed from self logical , intent ( in ), optional :: close_unit !! A logical flag to close the unit while removing it from the SELF list integer , intent ( out ), optional :: stat !! An error status with the values !! * success - no problems found !! * close_failure - the close statement for unit failed !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) ::  alogger !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         call alogger % remove_log_unit( unit ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod character ( 128 ) :: errmsg integer :: lun , lun_old character ( * ), parameter :: procedure_name = 'REMOVE_LOG_UNIT' if ( present ( stat ) ) stat = success do lun = 1 , self % units if ( unit == self % log_units ( lun ) ) exit end do if ( lun == self % units + 1 ) return if ( present ( close_unit ) ) then if ( close_unit ) close ( unit , err = 999 , iomsg = errmsg ) end if do lun_old = lun + 1 , self % units self % log_units ( lun_old - 1 ) = self % log_units ( lun_old ) end do self % units = self % units - 1 return 999 if ( present ( stat ) ) then stat = close_failure return else write ( * , '(a, i0)' ) 'In ' // module_name // ' % ' // & procedure_name // ' close_unit failed for unit = ' , unit write ( * , '(a)' ) 'With iomsg = ' // trim ( errmsg ) error stop 'close_unit failed in ' // module_name // ' % ' // & procedure_name // '.' end if end subroutine remove_log_unit function time_stamp () !! Creates a time stamp in the format 'yyyy-mm-dd hh:mm:ss.sss' character ( 23 ) :: time_stamp character ( 8 ) :: date character ( 10 ) :: time call date_and_time ( date , time ) time_stamp ( 1 : 4 ) = date ( 1 : 4 ) time_stamp ( 5 : 5 ) = '-' time_stamp ( 6 : 7 ) = date ( 5 : 6 ) time_stamp ( 8 : 8 ) = '-' time_stamp ( 9 : 10 ) = date ( 7 : 8 ) time_stamp ( 11 : 11 ) = ' ' time_stamp ( 12 : 13 ) = time ( 1 : 2 ) time_stamp ( 14 : 14 ) = ':' time_stamp ( 15 : 16 ) = time ( 3 : 4 ) time_stamp ( 17 : 17 ) = ':' time_stamp ( 18 : 23 ) = time ( 5 : 10 ) end function time_stamp end module stdlib_logger","tags":"","loc":"sourcefile/stdlib_logger.f90.html"},{"title":"stdlib_stats.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats.fypp~~EfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_stats.fypp~~AfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment_scalar.fypp stdlib_stats_moment_scalar.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment_mask.fypp stdlib_stats_moment_mask.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment_all.fypp stdlib_stats_moment_all.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_stats Source Code stdlib_stats.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_stats !! Provides support for various statistical methods. This includes currently !! descriptive statistics !! ([Specification](../page/specs/stdlib_stats.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private ! Public API public :: corr , cov , mean , moment , var interface corr !! version: experimental !! !! Pearson correlation of array elements !! ([Specification](../page/specs/stdlib_stats.html#description)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface corr interface cov !! version: experimental !! !! Covariance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_1)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface cov interface mean !! version: experimental !! !! Mean of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_2)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface mean interface var !! version: experimental !! !! Variance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_4)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface var interface moment !! version: experimental !! !! Central moment of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_3)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface moment end module stdlib_stats","tags":"","loc":"sourcefile/stdlib_stats.fypp.html"},{"title":"stdlib_sorting_ord_sort.fypp – Fortran-lang/stdlib","text":"This file is subjec† both to the Fortran Standard Library license, and\n to additional licensing requirements as it contains translations of\n other software. The Fortran Standard Library, including this file, is distributed under\n the MIT license that should be included with the library's distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n   copy of this software and associated documentation files (the\n   \"Software\"),  to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sellcopies of the Software, and to permit\n   persons to whom the Software is furnished to do so, subject to the\n   following conditions: The above copyright notice and this permission notice shall be included\n   in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, ORD_SORT , is substantially a translation to\n Fortran 2008 of the \"Rust\" sort sorting routines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n   file at the top-level directory of this distribution and at\n   http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n   option. This file may not be copied, modified, or distributed\n   except according to those terms. so the license for the original slice.rs code is compatible with the use\n of modified versions of the code in the Fortran Standard Library under\n the MIT license. This file depends on sourcefile~~stdlib_sorting_ord_sort.fypp~~EfferentGraph sourcefile~stdlib_sorting_ord_sort.fypp stdlib_sorting_ord_sort.fypp sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting_ord_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_sorting_ord_sort Source Code stdlib_sorting_ord_sort.fypp Source Code #:include \"common.fypp\" #:set IRS_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES + STRING_KINDS_TYPES #:set SIGN_NAME = [\"increase\", \"decrease\"] #:set SIGN_TYPE = [\">\", \"<\"] #:set SIGN_OPP_TYPE = [\"<\", \">\"] #:set SIGN_NAME_TYPE = list(zip(SIGN_NAME, SIGN_TYPE, SIGN_OPP_TYPE)) !! Licensing: !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `ORD_SORT`, is substantially a translation to !! Fortran 2008 of the `\"Rust\" sort` sorting routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. submodule ( stdlib_sorting ) stdlib_sorting_ord_sort implicit none contains #:for k1, t1 in IRS_KINDS_TYPES module subroutine ${ k1 }$_ ord_sort ( array , work , reverse ) ${ t1 }$ , intent ( inout ) :: array ( 0 :) ${ t1 }$ , intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse logical :: reverse_ reverse_ = . false . if ( present ( reverse )) reverse_ = reverse if ( reverse_ ) then call ${ k1 }$_ decrease_ord_sort ( array , work ) else call ${ k1 }$_ increase_ord_sort ( array , work ) endif end subroutine ${ k1 }$_ ord_sort #:endfor #:for sname, signt, signoppt in SIGN_NAME_TYPE #:for k1, t1 in IRS_KINDS_TYPES subroutine ${ k1 }$_${ sname }$_ ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. ${ t1 }$ , intent ( inout ) :: array ( 0 :) ${ t1 }$ , intent ( out ), optional :: work ( 0 :) ${ t1 }$ , allocatable :: buf (:) integer ( int_size ) :: array_size integer :: stat array_size = size ( array , kind = int_size ) if ( present ( work ) ) then if ( size ( work , kind = int_size ) < array_size / 2 ) then error stop \"${k1}$_${sname}$_ord_sort: work array is too small.\" endif ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"${k1}$_${sname}$_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_size ) :: min_run integer ( int_size ), intent ( in ) :: n integer ( int_size ) :: num , r num = n r = 0_int_size do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_size ) ) num = ishft ( num , - 1_int_size ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , j ${ t1 }$ :: key do j = 1 , size ( array , kind = int_size ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) ${ signoppt }$ = key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_size ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_size ) :: n logical :: test n = size ( runs , kind = int_size ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 ) % base == 0 . or . & runs ( n - 2 ) % len <= runs ( n - 1 ) % len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 ) % len <= & runs ( n - 2 ) % len + runs ( n - 1 ) % len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 ) % len <= & runs ( n - 3 ) % len + runs ( n - 2 ) % len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 ) % len < runs ( n - 1 ) % len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ${ t1 }$ , intent ( inout ) :: array ( 0 :) ${ t1 }$ :: tmp integer ( int_size ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_size ) - 1 if ( array ( i ) ${ signt }$ = tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. ${ t1 }$ , intent ( inout ) :: array ( 0 :) ${ t1 }$ , intent ( inout ) :: buf ( 0 :) integer ( int_size ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_size ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) ${ signoppt }$ array ( start ) ) then Descending : do while ( start > 0 ) if ( array ( start ) ${ signt }$ = array ( start - 1 ) ) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ) ) else Ascending : do while ( start > 0 ) if ( array ( start ) ${ signoppt }$ array ( start - 1 ) ) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ) ) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 ) ) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: mid ${ t1 }$ , intent ( inout ) :: buf ( 0 :) integer ( int_size ) :: array_len , i , j , k array_len = size ( array , kind = int_size ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) ${ signoppt }$ = array ( j ) ) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) ${ signt }$ = array ( i ) ) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ) :: lo , hi ${ t1 }$ :: temp lo = 0 hi = size ( array , kind = int_size ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine ${ k1 }$_${ sname }$_ ord_sort #:endfor #:endfor module subroutine char_ord_sort ( array , work , reverse ) character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse logical :: reverse_ reverse_ = . false . if ( present ( reverse )) reverse_ = reverse if ( reverse_ ) then call char_decrease_ord_sort ( array , work ) else call char_increase_ord_sort ( array , work ) endif end subroutine char_ord_sort #:for sname, signt, signoppt in SIGN_NAME_TYPE subroutine char_$ { sname }$_ ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) character ( len = :), allocatable :: buf (:) integer ( int_size ) :: array_size integer :: stat if ( present ( work ) ) then ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. array_size = size ( array , kind = int_size ) allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"${k1}$_${sname}$_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_size ) :: min_run integer ( int_size ), intent ( in ) :: n integer ( int_size ) :: num , r num = n r = 0_int_size do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_size ) ) num = ishft ( num , - 1_int_size ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , j character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_size ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) ${ signoppt }$ = key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_size ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_size ) :: n logical :: test n = size ( runs , kind = int_size ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 ) % base == 0 . or . & runs ( n - 2 ) % len <= runs ( n - 1 ) % len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 ) % len <= & runs ( n - 2 ) % len + runs ( n - 1 ) % len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 ) % len <= & runs ( n - 3 ) % len + runs ( n - 2 ) % len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 ) % len < runs ( n - 1 ) % len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )) :: tmp integer ( int_size ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_size ) - 1 if ( array ( i ) ${ signt }$ = tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_size ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_size ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) ${ signoppt }$ array ( start ) ) then Descending : do while ( start > 0 ) if ( array ( start ) ${ signt }$ = array ( start - 1 ) ) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ) ) else Ascending : do while ( start > 0 ) if ( array ( start ) ${ signoppt }$ array ( start - 1 ) ) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ) ) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 ) ) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_size ) :: array_len , i , j , k array_len = size ( array , kind = int_size ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) ${ signoppt }$ = array ( j ) ) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) ${ signt }$ = array ( i ) ) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_size ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_$ { sname }$_ ord_sort #:endfor end submodule stdlib_sorting_ord_sort","tags":"","loc":"sourcefile/stdlib_sorting_ord_sort.fypp.html"},{"title":"stdlib_stats_moment_scalar.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment_scalar.fypp~~EfferentGraph sourcefile~stdlib_stats_moment_scalar.fypp stdlib_stats_moment_scalar.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment_scalar Source Code stdlib_stats_moment_scalar.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment_scalar use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( ( real ( x , dp ) - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( real ( x , dp ) - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment_scalar.fypp.html"},{"title":"stdlib_sorting_sort.fypp – Fortran-lang/stdlib","text":"This file is subjec† both to the Fortran Standard Library license, and\n to additional licensing requirements as it contains translations of\n other software. The Fortran Standard Library, including this file, is distributed under\n the MIT license that should be included with the library's distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n   copy of this software and associated documentation files (the\n   \"Software\"),  to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sellcopies of the Software, and to permit\n   persons to whom the Software is furnished to do so, subject to the\n   following conditions: The above copyright notice and this permission notice shall be included\n   in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, SORT , is substantially a\n translation to Fortran 2008, of the introsort of David Musser.\n David Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license provided\n we cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,”\n   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. This file depends on sourcefile~~stdlib_sorting_sort.fypp~~EfferentGraph sourcefile~stdlib_sorting_sort.fypp stdlib_sorting_sort.fypp sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_sorting_sort Source Code stdlib_sorting_sort.fypp Source Code #:include \"common.fypp\" #:set IRS_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES + STRING_KINDS_TYPES #:set SIGN_NAME = [\"increase\", \"decrease\"] #:set SIGN_TYPE = [\">\", \"<\"] #:set SIGN_OPP_TYPE = [\"<\", \">\"] #:set SIGN_NAME_TYPE = list(zip(SIGN_NAME, SIGN_TYPE, SIGN_OPP_TYPE)) !! Licensing: !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `SORT`, is substantially a !! translation to Fortran 2008, of the `introsort` of David Musser. !! David Musser has given permission to include a variant of `introsort` !! in the Fortran Standard Library under the MIT license provided !! we cite: !! !!   Musser, D.R., “Introspective Sorting and Selection Algorithms,” !!   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). !! !! as the official source of the algorithm. submodule ( stdlib_sorting ) stdlib_sorting_sort !! This submodule implements the overloaded sorting subroutine `SORT` !! that can be used to sort four kinds of `INTEGER` arrays and three kinds !! of `REAL` arrays. Sorting is in order of increasing value, with the worst !! case run time performance of `O(N Ln(N))`. !! !! `SORT` uses the `INTROSORT` sorting algorithm of David Musser, !! http://www.cs.rpi.edu/~musser/gp/introsort.ps. `introsort` is a hybrid !! unstable comparison algorithm combining `quicksort`, `insertion sort`, and !! `heap sort`. While this algorithm is always O(N Ln(N)) it is relatively !! fast on randomly ordered data, but inconsistent in performance on partly !! sorted data, sometimes having `merge sort` performance, sometimes having !! better than `quicksort` performance. implicit none contains #:for k1, t1 in IRS_KINDS_TYPES pure module subroutine ${ k1 }$_ sort ( array , reverse ) ${ t1 }$ , intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse logical :: reverse_ reverse_ = . false . if ( present ( reverse )) reverse_ = reverse if ( reverse_ ) then call ${ k1 }$_ decrease_sort ( array ) else call ${ k1 }$_ increase_sort ( array ) endif end subroutine ${ k1 }$_ sort #:endfor #:for sname, signt, signoppt in SIGN_NAME_TYPE #:for k1, t1 in IRS_KINDS_TYPES pure subroutine ${ k1 }$_${ sname }$_ sort ( array ) ! `${k1}$_${sname}$_sort( array )` sorts the input `ARRAY` of type `${t1}$` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `${k1}$_${sname}$_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_size ), & kind = dp ) ) / log ( 2.0_dp ) ), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_size ), parameter :: insert_size = 16_int_size integer ( int_size ) :: index if ( size ( array , kind = int_size ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index ${ t1 }$ :: u , v , w , x , y integer ( int_size ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_size ) / 2 - 1 ) w = array ( size ( array , kind = int_size ) - 1 ) if ( ( u ${ signt }$ v ) . neqv . ( u ${ signt }$ w ) ) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y else if ( ( v ${ signoppt }$ u ) . neqv . ( v ${ signoppt }$ w ) ) then x = v y = array ( size ( array , kind = int_size ) / 2 - 1 ) array ( size ( array , kind = int_size ) / 2 - 1 ) = & array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_size do j = 0_int_size , size ( array , kind = int_size ) - 2 if ( array ( j ) ${ signoppt }$ = x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , j ${ t1 }$ :: key do j = 1_int_size , size ( array , kind = int_size ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) ${ signoppt }$ = key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , heap_size ${ t1 }$ :: y heap_size = size ( array , kind = int_size ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_size , 0_int_size , - 1_int_size call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_size , - 1_int_size ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_size , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: i , heap_size integer ( int_size ) :: l , r , largest ${ t1 }$ :: y largest = i l = 2_int_size * i + 1_int_size r = l + 1_int_size if ( l < heap_size ) then if ( array ( l ) ${ signt }$ array ( largest ) ) largest = l end if if ( r < heap_size ) then if ( array ( r ) ${ signt }$ array ( largest ) ) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine ${ k1 }$_${ sname }$_ sort #:endfor #:endfor pure module subroutine char_sort ( array , reverse ) character ( len =* ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse logical :: reverse_ reverse_ = . false . if ( present ( reverse )) reverse_ = reverse if ( reverse_ ) then call char_decrease_sort ( array ) else call char_increase_sort ( array ) endif end subroutine char_sort #:for sname, signt, signoppt in SIGN_NAME_TYPE pure subroutine char_$ { sname }$_ sort ( array ) ! `char_${sname}$_sort( array )` sorts the input `ARRAY` of type `CHARACTER(*)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `char_${sname}$_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_size ), & kind = dp ) ) / log ( 2.0_dp ) ), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_size ), parameter :: insert_size = 16_int_size integer ( int_size ) :: index if ( size ( array , kind = int_size ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index integer ( int_size ) :: i , j character ( len = len ( array )) :: u , v , w , x , y ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_size ) / 2 - 1 ) w = array ( size ( array , kind = int_size ) - 1 ) if ( ( u ${ signt }$ v ) . neqv . ( u ${ signt }$ w ) ) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y else if ( ( v ${ signoppt }$ u ) . neqv . ( v ${ signoppt }$ w ) ) then x = v y = array ( size ( array , kind = int_size ) / 2 - 1 ) array ( size ( array , kind = int_size ) / 2 - 1 ) = & array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_size do j = 0_int_size , size ( array , kind = int_size ) - 2 if ( array ( j ) ${ signoppt }$ = x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_size ) - 1 ) array ( size ( array , kind = int_size ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , j character ( len = len ( array )) :: key do j = 1_int_size , size ( array , kind = int_size ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) ${ signoppt }$ = key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ) :: i , heap_size character ( len = len ( array )) :: y heap_size = size ( array , kind = int_size ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_size , 0_int_size , - 1_int_size call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_size , - 1_int_size ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_size , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: i , heap_size integer ( int_size ) :: l , r , largest character ( len = len ( array )) :: y largest = i l = 2_int_size * i + 1_int_size r = l + 1_int_size if ( l < heap_size ) then if ( array ( l ) ${ signt }$ array ( largest ) ) largest = l end if if ( r < heap_size ) then if ( array ( r ) ${ signt }$ array ( largest ) ) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine char_$ { sname }$_ sort #:endfor end submodule stdlib_sorting_sort","tags":"","loc":"sourcefile/stdlib_sorting_sort.fypp.html"},{"title":"stdlib_io.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_io.fypp~~EfferentGraph sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_io Source Code stdlib_io.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_io !! Provides a support for file handling !! ([Specification](../page/specs/stdlib_io.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 use stdlib_error , only : error_stop use stdlib_optval , only : optval use stdlib_ascii , only : is_blank implicit none private ! Public API public :: loadtxt , savetxt , open ! Private API that is exposed so that we can test it in tests public :: parse_mode interface loadtxt !! version: experimental !! !! Loads a 2D array from a text file !! ([Specification](../page/specs/stdlib_io.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface loadtxt interface savetxt !! version: experimental !! !! Saves a 2D array into a text file !! ([Specification](../page/specs/stdlib_io.html#description_2)) # : for k1 , t1 in KINDS_TYPES module procedure savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface contains # : for k1 , t1 in KINDS_TYPES subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Loads a 2D array from a text file. !! !! Arguments !! --------- !! !! Filename to load the array from character ( len =* ), intent ( in ) :: filename !! The array 'd' will be automatically allocated with the correct dimensions ${ t1 }$ , allocatable , intent ( out ) :: d (:,:) !! !! Example !! ------- !! !!```fortran !! ${t1}$, allocatable :: data(:, :) !! call loadtxt(\"log.txt\", data)  ! 'data' will be automatically allocated !!``` !! !! Where 'log.txt' contains for example:: !! !!     1 2 3 !!     2 4 6 !!     8 9 10 !!     11 12 13 !!     ... !! integer :: s integer :: nrow , ncol , i s = open ( filename ) ! determine number of columns ncol = number_of_columns ( s ) ! determine number or rows nrow = number_of_rows_numeric ( s ) allocate ( d ( nrow , ncol )) do i = 1 , nrow read ( s , * ) d ( i , :) end do close ( s ) end subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in KINDS_TYPES subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Saves a 2D array into a text file. !! !! Arguments !! --------- !! character ( len =* ), intent ( in ) :: filename ! File to save the array to ${ t1 }$ , intent ( in ) :: d (:,:) ! The 2D array to save !! !! Example !! ------- !! !!```fortran !! ${t1}$ :: data(3, 2) !! call savetxt(\"log.txt\", data) !!``` !! integer :: s , i s = open ( filename , \"w\" ) do i = 1 , size ( d , 1 ) write ( s , * ) d ( i , :) end do close ( s ) end subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor integer function number_of_columns ( s ) !! version: experimental !! !! determine number of columns integer , intent ( in ) :: s integer :: ios character :: c logical :: lastblank rewind ( s ) number_of_columns = 0 lastblank = . true . do read ( s , '(a)' , advance = 'no' , iostat = ios ) c if ( ios /= 0 ) exit if ( lastblank . and . . not . is_blank ( c )) number_of_columns = number_of_columns + 1 lastblank = is_blank ( c ) end do rewind ( s ) end function number_of_columns integer function number_of_rows_numeric ( s ) result ( nrows ) !! version: experimental !! !! determine number or rows integer , intent ( in ) :: s integer :: ios real :: r complex :: z rewind ( s ) nrows = 0 do read ( s , * , iostat = ios ) r if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) ! If there are no rows of real numbers, it may be that they are complex if ( nrows == 0 ) then do read ( s , * , iostat = ios ) z if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) end if end function number_of_rows_numeric integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode end module","tags":"","loc":"sourcefile/stdlib_io.fypp.html"},{"title":"stdlib_quadrature_simps.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_simps.fypp~~EfferentGraph sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_simps Source Code stdlib_quadrature_simps.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_simps use stdlib_error , only : check implicit none ! internal use only interface simps38 # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_dx_$ { k1 }$ module procedure simps38_x_$ { k1 }$ # : endfor end interface simps38 ! internal use only interface simps38_weights # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_weights_$ { k1 }$ # : endfor end interface simps38_weights contains #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * dx * ( y ( 1 ) + y ( 2 )) case ( 3 ) integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * y ( 2 ) + y ( 3 )) case ( 4 ) integral = simps38 ( y , dx ) ! case (5) not needed; handled by default case ( 6 ) ! needs special handling because of averaged 3/8's rule case if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : 6 ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : 3 ), dx ) + simps38 ( y ( 3 : 6 ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( 6 )) + 59 * ( y ( 2 ) + y ( 5 )) + 44 * ( y ( 3 ) + y ( 4 ))) case default if ( mod ( n , 2 ) == 1 ) then integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * sum ( y ( 2 : n - 1 : 2 )) + 2 * sum ( y ( 3 : n - 2 : 2 )) + y ( n )) else if ( present ( even )) then if ( even < 0 ) then ! 3/8th rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : n ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), dx ) + simps38 ( y ( n - 3 : n ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( n )) + 59 * ( y ( 2 ) + y ( n - 1 )) & + 43 * ( y ( 3 ) + y ( n - 2 )) + 49 * ( y ( 4 ) + y ( n - 3 )) + 48 * sum ( y ( 5 : n - 4 ))) end if end select end function simps_dx_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: i integer :: n ${ t1 }$ :: h1 , h2 ${ t1 }$ :: a , b , c n = size ( y ) call check ( size ( x ) == n , \"simps: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) case ( 4 ) integral = simps38 ( y , x ) ! case (6) unneeded; handled by default case default if ( mod ( n , 2 ) == 1 ) then integral = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = integral + a * y ( i ) + b * y ( i + 1 ) + c * y ( i + 2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) return else ! fall through end if end if ! either `even` not present or is zero integral = 0.5 _${ k1 }$ * ( simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) & + simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) ) end if end select end function simps_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w integer :: i , n ${ t1 }$ :: h1 , h2 n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ k1 }$ case ( 2 ) w = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) w ( 1 ) = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( 2 ) = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( 3 ) = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) case ( 4 ) w = simps38_weights ( x ) case default if ( mod ( n , 2 ) == 1 ) then w = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) w ( i ) = w ( i ) + ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( i + 1 ) = w ( i + 1 ) + ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( i + 2 ) = w ( i + 2 ) + ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left w = 0.0 _${ k1 }$ w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! position 4 needs both rules return else if ( even > 0 ) then ! 3/8 rule on right w = 0.0 _${ k1 }$ w ( 1 : n - 3 ) = simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! position n-3 needs both rules return else ! fall through end if end if ! either `even` not present or is zero w = 0.0 _${ k1 }$ ! 3/8 rule on left w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! 3/8 rule on right w ( 1 : n - 3 ) = w ( 1 : n - 3 ) + simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! average w = 0.5 _${ k1 }$ * w end if end select end function simps_weights_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral integral = 3.0 _${ k1 }$ * dx / 8.0 _${ k1 }$ * ( y ( 1 ) + y ( 4 ) + 3 * ( y ( 2 ) + y ( 3 ))) end function simps38_dx_$ { k1 }$ #:endfor #: for k1, t1 in REAL_KINDS_TYPES pure function simps38_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , dimension ( 4 ), intent ( in ) :: x ${ t1 }$ :: integral ${ t1 }$ :: h1 , h2 , h3 ${ t1 }$ :: a , b , c , d h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) a = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) b = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) c = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) d = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) + d * y ( 4 ) end function simps38_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , intent ( in ) :: x ( 4 ) ${ t1 }$ :: w ( size ( x )) ${ t1 }$ :: h1 , h2 , h3 h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) w ( 1 ) = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) w ( 2 ) = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) w ( 3 ) = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) w ( 4 ) = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) end function simps38_weights_$ { k1 }$ #:endfor end submodule stdlib_quadrature_simps","tags":"","loc":"sourcefile/stdlib_quadrature_simps.fypp.html"},{"title":"stdlib_error.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_error.f90~~EfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_error.f90~~AfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment_scalar.fypp stdlib_stats_moment_scalar.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_mask.fypp stdlib_stats_moment_mask.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_distribution_prng.fypp stdlib_stats_distribution_PRNG.fypp sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_all.fypp stdlib_stats_moment_all.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_error Source Code stdlib_error.f90 Source Code module stdlib_error !! Provides support for catching and handling errors !! ([Specification](../page/specs/stdlib_error.html)) use , intrinsic :: iso_fortran_env , only : stderr => error_unit use stdlib_optval , only : optval implicit none private interface ! f{08,18}estop.f90 module subroutine error_stop ( msg , code ) !! version: experimental !! !! Provides a call to `error stop` and allows the user to specify a code and message !! ([Specification](..//page/specs/stdlib_error.html#description_1)) character ( * ), intent ( in ) :: msg integer , intent ( in ), optional :: code end subroutine error_stop end interface public :: check , error_stop contains subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check end module stdlib_error","tags":"","loc":"sourcefile/stdlib_error.f90.html"},{"title":"stdlib_linalg_diag.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg_diag.fypp~~EfferentGraph sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_linalg_diag Source Code stdlib_linalg_diag.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES submodule ( stdlib_linalg ) stdlib_linalg_diag implicit none contains # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) integer :: i res = 0 do i = 1 , size ( v ) res ( i , i ) = v ( i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) integer :: i , sz sz = size ( v ) res = 0 if ( k > 0 ) then do i = 1 , sz res ( i , k + i ) = v ( i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i + abs ( k ), i ) = v ( i ) end do else do i = 1 , sz res ( i , i ) = v ( i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) integer :: i do i = 1 , minval ( shape ( A )) res ( i ) = A ( i , i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) integer :: i , sz sz = minval ( shape ( A )) - abs ( k ) if ( k > 0 ) then do i = 1 , sz res ( i ) = A ( i , k + i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i ) = A ( i + abs ( k ), i ) end do else do i = 1 , sz res ( i ) = A ( i , i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_linalg_diag.fypp.html"},{"title":"stdlib_quadrature_gauss.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_gauss.f90~~EfferentGraph sourcefile~stdlib_quadrature_gauss.f90 stdlib_quadrature_gauss.f90 sourcefile~stdlib_specialfunctions.f90 stdlib_specialfunctions.f90 sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_specialfunctions.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_specialfunctions.f90->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_gauss Source Code stdlib_quadrature_gauss.f90 Source Code submodule ( stdlib_quadrature ) stdlib_quadrature_gauss use stdlib_specialfunctions , only : legendre , dlegendre implicit none real ( dp ), parameter :: pi = acos ( - 1._dp ) real ( dp ), parameter :: tolerance = 4._dp * epsilon ( 1._dp ) integer , parameter :: newton_iters = 100 contains pure module subroutine gauss_legendre_fp64 ( x , w , interval ) real ( dp ), intent ( out ) :: x (:), w (:) real ( dp ), intent ( in ), optional :: interval ( 2 ) associate ( n => size ( x ) - 1 ) select case ( n ) case ( 0 ) x = 0 w = 2 case ( 1 ) x ( 1 ) = - sqrt ( 1._dp / 3._dp ) x ( 2 ) = - x ( 1 ) w = 1 case default block integer :: i , j real ( dp ) :: leg , dleg , delta do i = 0 , ( n + 1 ) / 2 - 1 ! use Gauss-Chebyshev points as an initial guess x ( i + 1 ) = - cos (( 2 * i + 1 ) / ( 2._dp * n + 2._dp ) * pi ) do j = 1 , newton_iters leg = legendre ( n + 1 , x ( i + 1 )) dleg = dlegendre ( n + 1 , x ( i + 1 )) delta = - leg / dleg x ( i + 1 ) = x ( i + 1 ) + delta if ( abs ( delta ) <= tolerance * abs ( x ( i + 1 )) ) exit end do x ( n - i + 1 ) = - x ( i + 1 ) dleg = dlegendre ( n + 1 , x ( i + 1 )) w ( i + 1 ) = 2._dp / (( 1 - x ( i + 1 ) ** 2 ) * dleg ** 2 ) w ( n - i + 1 ) = w ( i + 1 ) end do if ( mod ( n , 2 ) == 0 ) then x ( n / 2 + 1 ) = 0 dleg = dlegendre ( n + 1 , 0.0_dp ) w ( n / 2 + 1 ) = 2._dp / ( dleg ** 2 ) end if end block end select end associate if ( present ( interval )) then associate ( a => interval ( 1 ) , b => interval ( 2 ) ) x = 0.5_dp * ( b - a ) * x + 0.5_dp * ( b + a ) x ( 1 ) = interval ( 1 ) x ( size ( x )) = interval ( 2 ) w = 0.5_dp * ( b - a ) * w end associate end if end subroutine pure module subroutine gauss_legendre_lobatto_fp64 ( x , w , interval ) real ( dp ), intent ( out ) :: x (:), w (:) real ( dp ), intent ( in ), optional :: interval ( 2 ) associate ( n => size ( x ) - 1 ) select case ( n ) case ( 1 ) x ( 1 ) = - 1 x ( 2 ) = 1 w = 1 case default block integer :: i , j real ( dp ) :: leg , dleg , delta x ( 1 ) = - 1._dp x ( n + 1 ) = 1._dp w ( 1 ) = 2._dp / ( n * ( n + 1._dp )) w ( n + 1 ) = 2._dp / ( n * ( n + 1._dp )) do i = 1 , ( n + 1 ) / 2 - 1 ! initial guess from an approximate form given by SV Parter (1999) x ( i + 1 ) = - cos ( ( i + 0.25_dp ) * pi / n - 3 / ( 8 * n * pi * ( i + 0.25_dp ))) do j = 1 , newton_iters leg = legendre ( n + 1 , x ( i + 1 )) - legendre ( n - 1 , x ( i + 1 )) dleg = dlegendre ( n + 1 , x ( i + 1 )) - dlegendre ( n - 1 , x ( i + 1 )) delta = - leg / dleg x ( i + 1 ) = x ( i + 1 ) + delta if ( abs ( delta ) <= tolerance * abs ( x ( i + 1 )) ) exit end do x ( n - i + 1 ) = - x ( i + 1 ) leg = legendre ( n , x ( i + 1 )) w ( i + 1 ) = 2._dp / ( n * ( n + 1._dp ) * leg ** 2 ) w ( n - i + 1 ) = w ( i + 1 ) end do if ( mod ( n , 2 ) == 0 ) then x ( n / 2 + 1 ) = 0 leg = legendre ( n , 0.0_dp ) w ( n / 2 + 1 ) = 2._dp / ( n * ( n + 1._dp ) * leg ** 2 ) end if end block end select end associate if ( present ( interval )) then associate ( a => interval ( 1 ) , b => interval ( 2 ) ) x = 0.5_dp * ( b - a ) * x + 0.5_dp * ( b + a ) x ( 1 ) = interval ( 1 ) x ( size ( x )) = interval ( 2 ) w = 0.5_dp * ( b - a ) * w end associate end if end subroutine end submodule","tags":"","loc":"sourcefile/stdlib_quadrature_gauss.f90.html"},{"title":"stdlib_stats_moment_mask.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment_mask.fypp~~EfferentGraph sourcefile~stdlib_stats_moment_mask.fypp stdlib_stats_moment_mask.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment_mask Source Code stdlib_stats_moment_mask.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment_mask use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = real ( count ( mask , dim ), ${ k1 }$ ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - & center ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = real ( count ( mask , dim ), dp ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ )& ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment_mask.fypp.html"},{"title":"stdlib_quadrature.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature.fypp~~EfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_quadrature.fypp~~AfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_gauss.f90 stdlib_quadrature_gauss.f90 sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_quadrature.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_quadrature Source Code stdlib_quadrature.fypp Source Code #:include \"common.fypp\" module stdlib_quadrature !! ([Specification](../page/specs/stdlib_quadrature.html#description)) use stdlib_kinds , only : sp , dp , qp implicit none private ! array integration public :: trapz public :: trapz_weights public :: simps public :: simps_weights public :: gauss_legendre public :: gauss_legendre_lobatto interface trapz !! version: experimental !! !! Integrates sampled values using trapezoidal rule !! ([Specification](../page/specs/stdlib_quadrature.html#description)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral end function trapz_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES module function trapz_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ :: integral end function trapz_x_$ { k1 }$ # : endfor end interface trapz interface trapz_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_1)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ , dimension ( size ( x )) :: w end function trapz_weights_$ { k1 }$ # : endfor end interface trapz_weights interface simps !! version: experimental !! !! Integrates sampled values using Simpson's rule !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) ! \"recursive\" is an implementation detail # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_x_$ { k1 }$ # : endfor end interface simps interface simps_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w end function simps_weights_$ { k1 }$ # : endfor end interface simps_weights interface gauss_legendre !! version: experimental !! !! Computes Gauss-Legendre quadrature nodes and weights. pure module subroutine gauss_legendre_fp64 ( x , w , interval ) real ( dp ), intent ( out ) :: x (:), w (:) real ( dp ), intent ( in ), optional :: interval ( 2 ) end subroutine end interface gauss_legendre interface gauss_legendre_lobatto !! version: experimental !! !! Computes Gauss-Legendre-Lobatto quadrature nodes and weights. pure module subroutine gauss_legendre_lobatto_fp64 ( x , w , interval ) real ( dp ), intent ( out ) :: x (:), w (:) real ( dp ), intent ( in ), optional :: interval ( 2 ) end subroutine end interface gauss_legendre_lobatto ! Interface for a simple f(x)-style integrand function. ! Could become fancier as we learn about the performance ! ramifications of different ways to do callbacks. abstract interface # : for k1 , t1 in REAL_KINDS_TYPES pure function integrand_$ { k1 }$ ( x ) result ( f ) import :: ${ k1 }$ ${ t1 }$ , intent ( in ) :: x ${ t1 }$ :: f end function integrand_$ { k1 }$ # : endfor end interface end module stdlib_quadrature","tags":"","loc":"sourcefile/stdlib_quadrature.fypp.html"},{"title":"stdlib_stats_mean.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_mean.fypp~~EfferentGraph sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_mean Source Code stdlib_stats_mean.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_mean use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = sum ( x ) / real ( size ( x , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = sum ( real ( x , dp )) / real ( size ( x , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim ) / real ( size ( x , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim ) / real ( size ( x , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res res = sum ( x , mask ) / real ( count ( mask , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res res = sum ( real ( x , dp ), mask ) / real ( count ( mask , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim , mask ) / real ( count ( mask , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim , mask ) / real ( count ( mask , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_mean.fypp.html"},{"title":"stdlib_kinds.f90 – Fortran-lang/stdlib","text":"Files dependent on this one sourcefile~~stdlib_kinds.f90~~AfferentGraph sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_bitsets.fypp stdlib_bitsets.fypp sourcefile~stdlib_bitsets.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats_distribution_prng.fypp stdlib_stats_distribution_PRNG.fypp sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats_distribution_prng.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_math.fypp stdlib_math.fypp sourcefile~stdlib_math.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_specialfunctions.f90 stdlib_specialfunctions.f90 sourcefile~stdlib_specialfunctions.f90->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature_gauss.f90 stdlib_quadrature_gauss.f90 sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_gauss.f90->sourcefile~stdlib_specialfunctions.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_linalg_outer_product.fypp stdlib_linalg_outer_product.fypp sourcefile~stdlib_linalg_outer_product.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_math_logspace.fypp stdlib_math_logspace.fypp sourcefile~stdlib_math_logspace.fypp->sourcefile~stdlib_math.fypp sourcefile~stdlib_strings.f90 stdlib_strings.f90 sourcefile~stdlib_strings.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_strings.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_sorting_sort_index.fypp stdlib_sorting_sort_index.fypp sourcefile~stdlib_sorting_sort_index.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_math_linspace.fypp stdlib_math_linspace.fypp sourcefile~stdlib_math_linspace.fypp->sourcefile~stdlib_math.fypp sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_specialfunctions_legendre.f90 stdlib_specialfunctions_legendre.f90 sourcefile~stdlib_specialfunctions_legendre.f90->sourcefile~stdlib_specialfunctions.f90 sourcefile~stdlib_sorting_sort.fypp stdlib_sorting_sort.fypp sourcefile~stdlib_sorting_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_scalar.fypp stdlib_stats_moment_scalar.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment_scalar.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_mask.fypp stdlib_stats_moment_mask.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment_mask.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_bitsets_64.fypp stdlib_bitsets_64.fypp sourcefile~stdlib_bitsets_64.fypp->sourcefile~stdlib_bitsets.fypp sourcefile~stdlib_sorting_ord_sort.fypp stdlib_sorting_ord_sort.fypp sourcefile~stdlib_sorting_ord_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_bitsets_large.fypp stdlib_bitsets_large.fypp sourcefile~stdlib_bitsets_large.fypp->sourcefile~stdlib_bitsets.fypp sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_logger.f90->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment_all.fypp stdlib_stats_moment_all.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment_all.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_kinds Source Code stdlib_kinds.f90 Source Code module stdlib_kinds !! version: experimental use iso_fortran_env , only : sp => real32 , dp => real64 , qp => real128 use iso_fortran_env , only : int8 , int16 , int32 , int64 use iso_c_binding , only : c_bool ! If we decide later to use iso_c_binding instead of iso_fortran_env: !use iso_c_binding, only: sp=>c_float, dp=>c_double, qp=>c_float128 !use iso_c_binding, only: int8=>c_int8_t, int16=>c_int16_t, int32=>c_int32_t, int64=>c_int64_t implicit none private public sp , dp , qp , int8 , int16 , int32 , int64 , lk , c_bool integer , parameter :: lk = kind (. true .) end module stdlib_kinds","tags":"","loc":"sourcefile/stdlib_kinds.f90.html"},{"title":"f08estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f08estop.f90~~EfferentGraph sourcefile~f08estop.f90 f08estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f08estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! this is a fallback for Fortran 2008 error stop (e.g. Intel 19.1/2020 compiler) ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") write ( stderr , * ) msg if ( present ( code )) then select case ( code ) case ( 1 ) error stop 1 case ( 2 ) error stop 2 case ( 77 ) error stop 77 case default write ( stderr , * ) 'ERROR: code ' , code , ' was specified.' error stop end select else error stop endif end procedure end submodule","tags":"","loc":"sourcefile/f08estop.f90.html"},{"title":"stdlib_quadrature_trapz.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_trapz.fypp~~EfferentGraph sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_trapz Source Code stdlib_quadrature_trapz.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_trapz use stdlib_error , only : check implicit none contains # : for KIND in REAL_KINDS pure module function trapz_dx_$ { KIND }$ ( y , dx ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), intent ( in ) :: dx real ( ${ KIND }$ ) :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * dx * ( y ( 1 ) + y ( 2 )) case default integral = dx * ( sum ( y ( 2 : n - 1 )) + 0.5 _${ KIND }$ * ( y ( 1 ) + y ( n ))) end select end function trapz_dx_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS module function trapz_x_$ { KIND }$ ( y , x ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ) :: integral integer :: i integer :: n n = size ( y ) call check ( size ( x ) == n , \"trapz: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case default integral = 0.0 _${ KIND }$ do i = 2 , n integral = integral + ( x ( i ) - x ( i - 1 )) * ( y ( i ) + y ( i - 1 )) end do integral = 0.5 _${ KIND }$ * integral end select end function trapz_x_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS pure module function trapz_weights_$ { KIND }$ ( x ) result ( w ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ), dimension ( size ( x )) :: w integer :: i integer :: n n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ KIND }$ case ( 2 ) w = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) case default w ( 1 ) = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) w ( n ) = 0.5 _${ KIND }$ * ( x ( n ) - x ( n - 1 )) do i = 2 , size ( x ) - 1 w ( i ) = 0.5 _${ KIND }$ * ( x ( i + 1 ) - x ( i - 1 )) end do end select end function trapz_weights_$ { KIND }$ #:endfor end submodule stdlib_quadrature_trapz","tags":"","loc":"sourcefile/stdlib_quadrature_trapz.fypp.html"},{"title":"stdlib_sorting.fypp – Fortran-lang/stdlib","text":"This file is subject both to the Fortran Standard Library license, and\n to additional licensing requirements as it contains translations of\n other software. The Fortran Standard Library, including this file, is distributed under\n the MIT license that should be included with the library's distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n   copy of this software and associated documentation files (the\n   \"Software\"),  to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sellcopies of the Software, and to permit\n   persons to whom the Software is furnished to do so, subject to the\n   following conditions: The above copyright notice and this permission notice shall be included\n   in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Two of the generic subroutines, ORD_SORT and SORT_INDEX , are\n substantially translations to Fortran 2008 of the \"Rust\" sort sorting\n routines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n   file at the top-level directory of this distribution and at\n   http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n   option. This file may not be copied, modified, or distributed\n   except according to those terms. so the license for the original slice.rs code is compatible with the use\n of modified versions of the code in the Fortran Standard Library under\n the MIT license. One of the generic subroutines, SORT , is substantially a\n translation to Fortran 2008, of the introsort of David Musser.\n David Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license provided\n we cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,”\n   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. This file depends on sourcefile~~stdlib_sorting.fypp~~EfferentGraph sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_sorting.fypp~~AfferentGraph sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting_ord_sort.fypp stdlib_sorting_ord_sort.fypp sourcefile~stdlib_sorting_ord_sort.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort_index.fypp stdlib_sorting_sort_index.fypp sourcefile~stdlib_sorting_sort_index.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_sorting_sort.fypp stdlib_sorting_sort.fypp sourcefile~stdlib_sorting_sort.fypp->sourcefile~stdlib_sorting.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_sorting Source Code stdlib_sorting.fypp Source Code #:include \"common.fypp\" #:set IRS_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES + STRING_KINDS_TYPES !! Licensing: !! !! This file is subject both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! Two of the generic subroutines, `ORD_SORT` and `SORT_INDEX`, are !! substantially translations to Fortran 2008 of the `\"Rust\" sort` sorting !! routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. !! !! One of the generic subroutines, `SORT`, is substantially a !! translation to Fortran 2008, of the `introsort` of David Musser. !! David Musser has given permission to include a variant of `introsort` !! in the Fortran Standard Library under the MIT license provided !! we cite: !! !!   Musser, D.R., “Introspective Sorting and Selection Algorithms,” !!   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). !! !! as the official source of the algorithm. module stdlib_sorting !! This module implements overloaded sorting subroutines named `ORD_SORT`, !! `SORT_INDEX`, and `SORT`, that each can be used to sort four kinds !! of `INTEGER` arrays, three kinds of `REAL` arrays, `character(len=*)` arrays, !! and arrays of `type(string_type)`. !! ([Specification](../page/specs/stdlib_sorting.html)) !! !! By default sorting is in order of !! increasing value, but there is an option to sort in decreasing order. !! All the subroutines have worst case run time performance of `O(N Ln(N))`, !! but on largely sorted data `ORD_SORT` and `SORT_INDEX` can have a run time !! performance of `O(N)`. !! !! `ORD_SORT` is a translation of the `\"Rust\" sort` sorting algorithm in !! `slice.rs`: !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs !! which in turn is inspired by the `timsort` algorithm of Tim Peters, !! http://svn.python.org/projects/python/trunk/Objects/listsort.txt. !! `ORD_SORT` is a hybrid stable comparison algorithm combining `merge sort`, !! and `insertion sort`. It is always at worst O(N Ln(N)) in sorting random !! data, having a performance about 25% slower than `SORT` on such !! data, but has much better performance than `SORT` on partially !! sorted data, having O(N) performance on uniformly non-increasing or !! non-decreasing data. !! !! `SORT_INDEX` is a modification of `ORD_SORT` so that in addition to !! sorting the input array, it returns the indices that map to a !! stable sort of the original array. These indices are !! intended to be used to sort data that is correlated with the input !! array, e.g., different arrays in a database, different columns of a !! rank 2 array, different elements of a derived type. It is less !! efficient than `ORD_SORT` at sorting a simple array. !! !! `SORT` uses the `INTROSORT` sorting algorithm of David Musser, !! http://www.cs.rpi.edu/~musser/gp/introsort.ps. `introsort` is a hybrid !! unstable comparison algorithm combining `quicksort`, `insertion sort`, and !! `heap sort`. While this algorithm is always O(N Ln(N)) it is relatively !! fast on randomly ordered data, but inconsistent in performance on partly !! sorted data, sometimes having `merge sort` performance, sometimes having !! better than `quicksort` performance. `UNORD_SOORT` is about 25% !! more efficient than `ORD_SORT` at sorting purely random data, but af an !! order of `Ln(N)` less efficient at sorting partially sorted data. use stdlib_kinds , only : & int8 , & int16 , & int32 , & int64 , & sp , & dp , & qp use stdlib_string_type , only : string_type , assignment ( = ), operator ( > ), & operator ( >= ), operator ( < ), operator ( <= ) implicit none private integer , parameter , public :: int_size = int64 !! Integer kind for indexing ! Constants for use by tim_sort integer , parameter :: & ! The maximum number of entries in a run stack, good for an array of ! 2**64 elements see ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt max_merge_stack = int ( ceiling ( log ( 2._dp ** 64 ) / & log ( 1.6180339887_dp ) ) ) type run_type !! Version: experimental !! !! Used to pass state around in a stack among helper functions for the !! `ORD_SORT` and `SORT_INDEX` algorithms integer ( int_size ) :: base = 0 integer ( int_size ) :: len = 0 end type run_type public ord_sort !! Version: experimental !! !! The generic subroutine implementing the `ORD_SORT` algorithm to return !! an input array with its elements sorted in order of (non-)decreasing !! value. Its use has the syntax: !! !!     call ord_sort( array[, work, reverse] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`. If both the !!   type of `array` is real and at least one of the elements is a !!   `NaN`, then the ordering of the result is undefined. Otherwise it !!   is defined to be the original elements in non-decreasing order. !! !! * work (optional): shall be a rank 1 array of the same type as !!   `array`, and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `array` will be sorted in order of non-increasing values in stable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in stable order. !! !!#### Example !! !!```fortran !!    ... !!    ! Read arrays from sorted files !!    call read_sorted_file( 'dummy_file1', array1 ) !!    call read_sorted_file( 'dummy_file2', array2 ) !!    ! Concatenate the arrays !!    allocate( array( size(array1) + size(array2) ) ) !!    array( 1:size(array1) ) = array1(:) !!    array( size(array1)+1:size(array1)+size(array2) ) = array2(:) !!    ! Sort the resulting array !!    call ord_sort( array, work ) !!    ! Process the sorted array !!    call array_search( array, values ) !!    ... !!``` public sort !! Version: experimental !! !! The generic subroutine implementing the `SORT` algorithm to return !! an input array with its elements sorted in order of (non-)decreasing !! value. Its use has the syntax: !! !!     call sort( array[, reverse] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`. If both the type !!   of `array` is real and at least one of the elements is a `NaN`, then !!   the ordering of the result is undefined. Otherwise it is defined to be the !!   original elements in non-decreasing order. !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `array` will be sorted in order of non-increasing values in unstable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in unstable order. !! !!#### Example !! !!```fortran !!    ... !!    ! Read random data from a file !!    call read_file( 'dummy_file', array ) !!    ! Sort the random data !!    call sort( array ) !!    ! Process the sorted data !!    call array_search( array, values ) !!    ... !!``` public sort_index !! Version: experimental !! !! The generic subroutine implementing the `SORT_INDEX` algorithm to !! return an index array whose elements would sort the input array in the !! desired direction. It is primarily intended to be used to sort a !! derived type array based on the values of a component of the array. !! Its use has the syntax: !! !!     call sort_index( array, index[, work, iwork, reverse ] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`. If both the !!   type of `array` is real and at least one of the elements is a `NaN`, !!   then the ordering of the `array` and `index` results is undefined. !!   Otherwise it is defined to be as specified by reverse. !! !! * index: a rank 1 array of sorting indices. It is an `intent(out)` !!   argument of the type `integer(int_size)`. Its size shall be the !!   same as `array`. On return, if defined, its elements would !!   sort the input `array` in the direction specified by `reverse`. !! !! * work (optional): shall be a rank 1 array of the same type as !!   `array`, and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * iwork (optional): shall be a rank 1 integer array of kind `int_size`, !!   and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `index` will sort `array` in order of non-increasing values in stable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in stable order. !! !!#### Examples !! !! Sorting a related rank one array: !! !!```Fortran !!    subroutine sort_related_data( a, b, work, index, iwork ) !!        ! Sort `b` in terms or its related array `a` !!        integer, intent(inout)         :: a(:) !!        integer(int32), intent(inout)  :: b(:) ! The same size as a !!        integer(int32), intent(out)    :: work(:) !!        integer(int_size), intent(out) :: index(:) !!        integer(int_size), intent(out) :: iwork(:) !!    ! Find the indices to sort a !!        call sort_index(a, index(1:size(a)),& !!            work(1:size(a)/2), iwork(1:size(a)/2)) !!    ! Sort b based on the sorting of a !!        b(:) = b( index(1:size(a)) ) !!    end subroutine sort_related_data !!``` !! !! Sorting a rank 2 array based on the data in a column !! !!```Fortran !!    subroutine sort_related_data( array, column, work, index, iwork ) !!    ! Sort `a_data` in terms or its component `a` !!        integer, intent(inout)         :: a(:,:) !!        integer(int32), intent(in)     :: column !!        integer(int32), intent(out)    :: work(:) !!        integer(int_size), intent(out) :: index(:) !!        integer(int_size), intent(out) :: iwork(:) !!        integer, allocatable           :: dummy(:) !!        integer :: i !!        allocate(dummy(size(a, dim=1))) !!    ! Extract a component of `a_data` !!        dummy(:) = a(:, column) !!    ! Find the indices to sort the column !!        call sort_index(dummy, index(1:size(dummy)),& !!                        work(1:size(dummy)/2), iwork(1:size(dummy)/2)) !!    ! Sort a based on the sorting of its column !!        do i=1, size(a, dim=2) !!            a(:, i) = a(index(1:size(a, dim=1)), i) !!        end do !!    end subroutine sort_related_data !!``` !! !! Sorting an array of a derived type based on the dsta in one component !!```fortran !!    subroutine sort_a_data( a_data, a, work, index, iwork ) !!    ! Sort `a_data` in terms or its component `a` !!        type(a_type), intent(inout)    :: a_data(:) !!        integer(int32), intent(inout)  :: a(:) !!        integer(int32), intent(out)    :: work(:) !!        integer(int_size), intent(out) :: index(:) !!        integer(int_size), intent(out) :: iwork(:) !!    ! Extract a component of `a_data` !!        a(1:size(a_data)) = a_data(:) % a !!    ! Find the indices to sort the component !!        call sort_index(a(1:size(a_data)), index(1:size(a_data)),& !!                        work(1:size(a_data)/2), iwork(1:size(a_data)/2)) !!    ! Sort a_data based on the sorting of that component !!        a_data(:) = a_data( index(1:size(a_data)) ) !!    end subroutine sort_a_data !!``` interface ord_sort !! Version: experimental !! !! The generic subroutine interface implementing the `ORD_SORT` algorithm, !! a translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in !! `slice.rs` !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 !! `ORD_SORT` is a hybrid stable comparison algorithm combining `merge sort`, !! and `insertion sort`. !! ([Specification](../page/specs/stdlib_sorting.html#ord_sort-sorts-an-input-array)) !! !! It is always at worst O(N Ln(N)) in sorting random !! data, having a performance about 25% slower than `SORT` on such !! data, but has much better performance than `SORT` on partially !! sorted data, having O(N) performance on uniformly non-increasing or !! non-decreasing data. #:for k1, t1 in IRS_KINDS_TYPES module subroutine ${ k1 }$_ ord_sort ( array , work , reverse ) !! Version: experimental !! !! `${k1}$_ord_sort( array )` sorts the input `ARRAY` of type `${t1}$` !! using a hybrid sort based on the `'Rust\" sort` algorithm found in `slice.rs` ${ t1 }$ , intent ( inout ) :: array ( 0 :) ${ t1 }$ , intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine ${ k1 }$_ ord_sort #:endfor module subroutine char_ord_sort ( array , work , reverse ) !! Version: experimental !! !! `char_ord_sort( array[, work, reverse] )` sorts the input `ARRAY` of type !! `CHARACTER(*)` using a hybrid sort based on the `'Rust\" sort` algorithm !! found in `slice.rs` character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_ord_sort end interface ord_sort interface sort !! Version: experimental !! !! The generic subroutine interface implementing the `SORT` algorithm, based !! on the `introsort` of David Musser. !! ([Specification](../page/specs/stdlib_sorting.html#sort-sorts-an-input-array)) #:for k1, t1 in IRS_KINDS_TYPES pure module subroutine ${ k1 }$_ sort ( array , reverse ) !! Version: experimental !! !! `${k1}$_sort( array[, reverse] )` sorts the input `ARRAY` of type `${t1}$` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. ${ t1 }$ , intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine ${ k1 }$_ sort #:endfor pure module subroutine char_sort ( array , reverse ) !! Version: experimental !! !! `char_sort( array[, reverse] )` sorts the input `ARRAY` of type !! `CHARACTER(*)` using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort end interface sort interface sort_index !! Version: experimental !! !! The generic subroutine interface implementing the `SORT_INDEX` algorithm, !! based on the `\"Rust\" sort` algorithm found in `slice.rs` !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 !! but modified to return an array of indices that would provide a stable !! sort of the rank one `ARRAY` input. !! ([Specification](../page/specs/stdlib_sorting.html#sort_index-creates-an-array-of-sorting-indices-for-an-input-array-while-also-sorting-the-array)) !! !! The indices by default correspond to a !! non-decreasing sort, but if the optional argument `REVERSE` is present !! with a value of `.TRUE.` the indices correspond to a non-increasing sort. #:for k1, t1 in IRS_KINDS_TYPES module subroutine ${ k1 }$_ sort_index ( array , index , work , iwork , & reverse ) !! Version: experimental !! !! `${k1}$_sort_index( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `${t1}$` !! using a hybrid sort based on the `'Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX of indices in the !! order that would sort the input `ARRAY` in the desired direction. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index ( 0 :) ${ t1 }$ , intent ( out ), optional :: work ( 0 :) integer ( int_size ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine ${ k1 }$_ sort_index #:endfor module subroutine char_sort_index ( array , index , work , iwork , & reverse ) !! Version: experimental !! !! `char_sort_index( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `CHARACTER(*)` !! using a hybrid sort based on the `'Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX of indices in the !! order that would sort the input `ARRAY` in the desired direction. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_size ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort_index end interface sort_index end module stdlib_sorting","tags":"","loc":"sourcefile/stdlib_sorting.fypp.html"},{"title":"stdlib_math.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_math.fypp~~EfferentGraph sourcefile~stdlib_math.fypp stdlib_math.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_math.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_math.fypp~~AfferentGraph sourcefile~stdlib_math.fypp stdlib_math.fypp sourcefile~stdlib_math_linspace.fypp stdlib_math_linspace.fypp sourcefile~stdlib_math_linspace.fypp->sourcefile~stdlib_math.fypp sourcefile~stdlib_math_logspace.fypp stdlib_math_logspace.fypp sourcefile~stdlib_math_logspace.fypp->sourcefile~stdlib_math.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_math Source Code stdlib_math.fypp Source Code #:include \"common.fypp\" #:set IR_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_math use stdlib_kinds , only : int8 , int16 , int32 , int64 , sp , dp , qp implicit none private public :: clip , linspace , logspace public :: EULERS_NUMBER_SP , EULERS_NUMBER_DP , EULERS_NUMBER_QP public :: DEFAULT_LINSPACE_LENGTH , DEFAULT_LOGSPACE_BASE , DEFAULT_LOGSPACE_LENGTH integer , parameter :: DEFAULT_LINSPACE_LENGTH = 100 integer , parameter :: DEFAULT_LOGSPACE_LENGTH = 50 integer , parameter :: DEFAULT_LOGSPACE_BASE = 10 ! Useful constants for lnspace real ( sp ), parameter :: EULERS_NUMBER_SP = exp ( 1.0_sp ) real ( dp ), parameter :: EULERS_NUMBER_DP = exp ( 1.0_dp ) real ( qp ), parameter :: EULERS_NUMBER_QP = exp ( 1.0_qp ) interface clip # : for k1 , t1 in IR_KINDS_TYPES module procedure clip_$ { k1 }$ # : endfor end interface clip interface linspace !! Version: Experimental !! !! Create rank 1 array of linearly spaced elements !! If the number of elements is not specified, create an array with size 100. If n is a negative value, !! return an array with size 0. If n = 1, return an array whose only element is end !!([Specification](../page/specs/stdlib_math.html#linspace-create-a-linearly-spaced-rank-one-array)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"linspace_default\" , 1 , t1 , k1 ) module function ${ RName }$ ( start , end ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end ${ t1 }$ :: res ( DEFAULT_LINSPACE_LENGTH ) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"linspace_n\" , 1 , t1 , k1 ) module function ${ RName }$ ( start , end , n ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n ${ t1 }$ :: res ( n ) end function ${ RName }$ # : endfor ! Add support for integer linspace !! !! When dealing with integers as the `start` and `end` parameters, the return type is always a `real(dp)`. # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"linspace_default\" , 1 , t1 , k1 ) # ! The interface for INT_KINDS_TYPES cannot be combined with RC_KINDS_TYPES # ! because the output for integer types is always a real with dp. module function ${ RName }$ ( start , end ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end real ( dp ) :: res ( DEFAULT_LINSPACE_LENGTH ) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"linspace_n\" , 1 , t1 , k1 ) module function ${ RName }$ ( start , end , n ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n real ( dp ) :: res ( n ) end function ${ RName }$ # : endfor end interface interface logspace !! Version: Experimental !! !! Create rank 1 array of logarithmically spaced elements from base**start to base**end. !! If the number of elements is not specified, create an array with size 50. If n is a negative value, !! return an array with size 0. If n = 1, return an array whose only element is base**end. If no base !! is specified, logspace will default to using a base of 10 !! !!([Specification](../page/specs/stdlib_math.html#logspace-create-a-logarithmically-spaced-rank-one-array)) # !========================================================= # !=     logspace(start, end)                              = # !========================================================= # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"default\" ) module function ${ RName }$ ( start , end ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end ${ t1 }$ :: res ( DEFAULT_LOGSPACE_LENGTH ) end function ${ RName }$ # : endfor # ! Integer support # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"default\" ) module function ${ RName }$ ( start , end ) result ( res ) integer , intent ( in ) :: start integer , intent ( in ) :: end real ( dp ) :: res ( DEFAULT_LOGSPACE_LENGTH ) end function ${ RName }$ # !========================================================= # !=     logspace(start, end, n)                           = # !========================================================= # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n\" ) module function ${ RName }$ ( start , end , n ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n ${ t1 }$ :: res ( n ) end function ${ RName }$ # : endfor # ! Integer support # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n\" ) module function ${ RName }$ ( start , end , n ) result ( res ) integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: n real ( dp ) :: res ( n ) end function ${ RName }$ # !========================================================= # !=     logspace(start, end, n, base)                     = # !========================================================= # ! Need another function where base is not optional, # ! otherwise the compiler can not differentiate between # ! generic calls to logspace_n where a base is not present # ! ======================================================== # : for k1 , t1 in REAL_KINDS_TYPES ! Generate logarithmically spaced sequence from ${k1}$ base to the powers ! of ${k1}$ start and end. [base&#94;start, ... , base&#94;end] ! Different combinations of parameter types will lead to different result types. ! Those combinations are indicated in the body of each function. # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_rbase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n ${ t1 }$ , intent ( in ) :: base ! real(${k1}$) endpoints + real(${k1}$) base = real(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_cbase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n complex ( ${ k1 }$ ), intent ( in ) :: base ! real(${k1}$) endpoints + complex(${k1}$) base = complex(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_ibase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n integer , intent ( in ) :: base ! real(${k1}$) endpoints + integer base = real(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : endfor # ! ======================================================== # ! ======================================================== # : for k1 , t1 in CMPLX_KINDS_TYPES ! Generate logarithmically spaced sequence from ${k1}$ base to the powers ! of ${k1}$ start and end. [base&#94;start, ... , base&#94;end] ! Different combinations of parameter types will lead to different result types. ! Those combinations are indicated in the body of each function. # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_rbase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n real ( ${ k1 }$ ), intent ( in ) :: base ! complex(${k1}$) endpoints + real(${k1}$) base = complex(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_cbase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n complex ( ${ k1 }$ ), intent ( in ) :: base ! complex(${k1}$) endpoints + complex(${k1}$) base = complex(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : set RName = rname ( \"logspace\" , 1 , t1 , k1 , \"n_ibase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) ${ t1 }$ , intent ( in ) :: start ${ t1 }$ , intent ( in ) :: end integer , intent ( in ) :: n integer , intent ( in ) :: base ! complex(${k1}$) endpoints + integer base = complex(${k1}$) result ${ t1 }$ :: res ( n ) end function ${ RName }$ # : endfor # ! ======================================================== # ! ======================================================== # ! Provide support for Integer start/endpoints ! Generate logarithmically spaced sequence from ${k1}$ base to the powers ! of ${k1}$ start and end. [base&#94;start, ... , base&#94;end] ! Different combinations of parameter types will lead to different result types. ! Those combinations are indicated in the body of each function. # : for k1 in REAL_KINDS # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_r\" + str ( k1 ) + \"base\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: n real ( ${ k1 }$ ), intent ( in ) :: base ! integer endpoints + real(${k1}$) base = real(${k1}$) result real ( ${ k1 }$ ) :: res ( n ) end function ${ RName }$ # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_c\" + str ( k1 ) + \"base\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: n complex ( ${ k1 }$ ), intent ( in ) :: base ! integer endpoints + complex(${k1}$) base = complex(${k1}$) result complex ( ${ k1 }$ ) :: res ( n ) end function ${ RName }$ # : endfor # : set RName = rname ( \"logspace\" , 1 , \"integer(int32)\" , \"int32\" , \"n_ibase\" ) module function ${ RName }$ ( start , end , n , base ) result ( res ) integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: n integer , intent ( in ) :: base ! integer endpoints + integer base = integer result integer :: res ( n ) end function ${ RName }$ end interface contains # : for k1 , t1 in IR_KINDS_TYPES elemental function clip_$ { k1 }$ ( x , xmin , xmax ) result ( res ) ${ t1 }$ , intent ( in ) :: x ${ t1 }$ , intent ( in ) :: xmin ${ t1 }$ , intent ( in ) :: xmax ${ t1 }$ :: res res = max ( min ( x , xmax ), xmin ) end function clip_$ { k1 }$ # : endfor end module stdlib_math","tags":"","loc":"sourcefile/stdlib_math.fypp.html"},{"title":"stdlib_stats_var.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_var.fypp~~EfferentGraph sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_var Source Code stdlib_stats_var.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_var use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), ${ k1 }$ ) mean = sum ( x ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : else res = sum ( abs ( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : endif end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), dp ) mean = sum ( real ( x , dp )) / n res = sum (( real ( x , dp ) - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( x , dim ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : else res = res + abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : endif end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( real ( x , dp ), dim ) / n do i = 1 , size ( x , dim ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean n = real ( count ( mask , kind = int64 ), ${ k1 }$ ) mean = sum ( x , mask ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 , mask ) / ( n - & # : else res = sum ( abs ( x - mean ) ** 2 , mask ) / ( n - & # : endif merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean n = real ( count ( mask , kind = int64 ), dp ) mean = sum ( real ( x , dp ), mask ) / n res = sum (( real ( x , dp ) - mean ) ** 2 , mask ) / ( n - & merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( x , dim , mask ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : else res = res + merge ( abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : endif 0. _${ k1 }$ ,& mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( real ( x , dp ), dim , mask ) / n do i = 1 , size ( x , dim ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_var.fypp.html"},{"title":"stdlib_linalg_outer_product.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg_outer_product.fypp~~EfferentGraph sourcefile~stdlib_linalg_outer_product.fypp stdlib_linalg_outer_product.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_outer_product.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_linalg_outer_product Source Code stdlib_linalg_outer_product.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES submodule ( stdlib_linalg ) stdlib_linalg_outer_product implicit none contains # : for k1 , t1 in RCI_KINDS_TYPES pure module function outer_product_$ { t1 [ 0 ] }{ k1 }$ ( u , v ) result ( res ) ${ t1 }$ , intent ( in ) :: u (:), v (:) ${ t1 }$ :: res ( size ( u ), size ( v )) integer :: col do col = 1 , size ( v ) res (:, col ) = v ( col ) * u end do end function outer_product_$ { t1 [ 0 ] }{ k1 }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_linalg_outer_product.fypp.html"},{"title":"f18estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f18estop.f90~~EfferentGraph sourcefile~f18estop.f90 f18estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f18estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") if ( present ( code )) then write ( stderr , * ) msg error stop code else error stop msg endif end procedure end submodule estop","tags":"","loc":"sourcefile/f18estop.f90.html"},{"title":"stdlib_sorting_sort_index.fypp – Fortran-lang/stdlib","text":"This file is subjec† both to the Fortran Standard Library license, and\n to additional licensing requirements as it contains translations of\n other software. The Fortran Standard Library, including this file, is distributed under\n the MIT license that should be included with the library's distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n   copy of this software and associated documentation files (the\n   \"Software\"),  to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sellcopies of the Software, and to permit\n   persons to whom the Software is furnished to do so, subject to the\n   following conditions: The above copyright notice and this permission notice shall be included\n   in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, SORT_INDEX , is substantially a translation to\n Fortran 2008 of the \"Rust\" sort sorting routines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n   file at the top-level directory of this distribution and at\n   http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n   option. This file may not be copied, modified, or distributed\n   except according to those terms. so the license for the original slice.rs code is compatible with the use\n of modified versions of the code in the Fortran Standard Library under\n the MIT license. This file depends on sourcefile~~stdlib_sorting_sort_index.fypp~~EfferentGraph sourcefile~stdlib_sorting_sort_index.fypp stdlib_sorting_sort_index.fypp sourcefile~stdlib_sorting.fypp stdlib_sorting.fypp sourcefile~stdlib_sorting_sort_index.fypp->sourcefile~stdlib_sorting.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_string_type.fypp stdlib_string_type.fypp sourcefile~stdlib_sorting.fypp->sourcefile~stdlib_string_type.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.fypp stdlib_ascii.fypp sourcefile~stdlib_string_type.fypp->sourcefile~stdlib_ascii.fypp sourcefile~stdlib_ascii.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_sorting_sort_index Source Code stdlib_sorting_sort_index.fypp Source Code #:include \"common.fypp\" #:set IRS_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES + STRING_KINDS_TYPES !! Licensing: !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `SORT_INDEX`, is substantially a translation to !! Fortran 2008 of the `\"Rust\" sort` sorting routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. submodule ( stdlib_sorting ) stdlib_sorting_sort_index implicit none contains #:for k1, t1 in IRS_KINDS_TYPES module subroutine ${ k1 }$_ sort_index ( array , index , work , iwork , reverse ) ! A modification of `${k1}$_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version is a simplification of the Timsort algorithm described ! in https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size, with ! an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original listsort.txt, and the optional `work` and `iwork` arraya to be ! used as scratch memory. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index ( 0 :) ${ t1 }$ , intent ( out ), optional :: work ( 0 :) integer ( int_size ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int_size ) :: array_size , i , stat ${ t1 }$ , allocatable :: buf (:) integer ( int_size ), allocatable :: ibuf (:) array_size = size ( array , kind = int_size ) do i = 0 , array_size - 1 index ( i ) = i + 1 end do if ( present ( reverse ) ) then if ( reverse ) then call reverse_segment ( array , index ) end if end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work ) ) then if ( size ( work , kind = int_size ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork ) ) then if ( size ( iwork , kind = int_size ) < array_size / 2 ) then error stop \"iwork array is too small.\" endif call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork ) ) then if ( size ( iwork , kind = int_size ) < array_size / 2 ) then error stop \"iwork array is too small.\" endif call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( present ( reverse ) ) then if ( reverse ) then call reverse_segment ( array , index ) end if end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_size ) :: min_run integer ( int_size ), intent ( in ) :: n integer ( int_size ) :: num , r num = n r = 0_int_size do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_size ) ) num = ishft ( num , - 1_int_size ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ) :: i , j , key_index ${ t1 }$ :: key do j = 1 , size ( array , kind = int_size ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_size ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_size ) :: n logical :: test n = size ( runs , kind = int_size ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 ) % base == 0 . or . & runs ( n - 2 ) % len <= runs ( n - 1 ) % len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 ) % len <= & runs ( n - 2 ) % len + runs ( n - 1 ) % len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 ) % len <= & runs ( n - 3 ) % len + runs ( n - 2 ) % len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 ) % len < runs ( n - 1 ) % len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) ${ t1 }$ :: tmp integer ( int_size ) :: i , tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_size ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) ${ t1 }$ , intent ( inout ) :: buf ( 0 :) integer ( int_size ), intent ( inout ) :: ibuf ( 0 :) integer ( int_size ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_size ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start ) ) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 ) ) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish ) ) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 ) ) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish ) ) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 ) ) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: mid ${ t1 }$ , intent ( inout ) :: buf ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ), intent ( inout ) :: ibuf ( 0 :) integer ( int_size ) :: array_len , i , j , k array_len = size ( array , kind = int_size ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j ) ) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i ) ) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place ${ t1 }$ , intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ) :: itemp , lo , hi ${ t1 }$ :: temp lo = 0 hi = size ( array , kind = int_size ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine ${ k1 }$_ sort_index #:endfor module subroutine char_sort_index ( array , index , work , iwork , reverse ) ! A modification of `char_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version is a simplification of the Timsort algorithm described ! in https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size, with ! an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original listsort.txt, and the optional `work` and `iwork` arraya to be ! used as scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_size ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int_size ) :: array_size , i , stat character ( len = :), allocatable :: buf (:) integer ( int_size ), allocatable :: ibuf (:) array_size = size ( array , kind = int_size ) do i = 0 , array_size - 1 index ( i ) = i + 1 end do if ( present ( reverse ) ) then if ( reverse ) then call reverse_segment ( array , index ) end if end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work ) ) then if ( present ( iwork ) ) then call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork ) ) then call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( present ( reverse ) ) then if ( reverse ) then call reverse_segment ( array , index ) end if end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_size ) :: min_run integer ( int_size ), intent ( in ) :: n integer ( int_size ) :: num , r num = n r = 0_int_size do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_size ) ) num = ishft ( num , - 1_int_size ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ) :: i , j , key_index character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_size ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_size ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_size ) :: n logical :: test n = size ( runs , kind = int_size ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 ) % base == 0 . or . & runs ( n - 2 ) % len <= runs ( n - 1 ) % len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 ) % len <= & runs ( n - 2 ) % len + runs ( n - 1 ) % len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 ) % len <= & runs ( n - 3 ) % len + runs ( n - 2 ) % len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 ) % len < runs ( n - 1 ) % len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )) :: tmp integer ( int_size ) :: i , tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_size ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_size ), intent ( inout ) :: ibuf ( 0 :) integer ( int_size ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_size ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start ) ) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 ) ) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish ) ) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 ) ) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish ) ) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 ) ) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ), intent ( inout ) :: ibuf ( 0 :) integer ( int_size ) :: array_len , i , j , k array_len = size ( array , kind = int_size ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j ) ) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i ) ) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_size ), intent ( inout ) :: index ( 0 :) integer ( int_size ) :: itemp , lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_size ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_sort_index end submodule stdlib_sorting_sort_index","tags":"","loc":"sourcefile/stdlib_sorting_sort_index.fypp.html"},{"title":"string_type – Fortran-lang/stdlib ","text":"type, public :: string_type sequence String type holding an arbitrary sequence of characters. Contents Constructor string_type Source Code string_type Constructor public interface string_type Constructor for new string instances private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental function new_string_from_integer_int8(val) result(new) Constructor for new string instances from an integer of kind int8. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int16(val) result(new) Constructor for new string instances from an integer of kind int16. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int32(val) result(new) Constructor for new string instances from an integer of kind int32. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int64(val) result(new) Constructor for new string instances from an integer of kind int64. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_lk(val) result(new) Constructor for new string instances from a logical of kind lk. Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_c_bool(val) result(new) Constructor for new string instances from a logical of kind c_bool. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: val Return Value type( string_type ) Source Code type :: string_type ! Use the sequence statement below as a hack to prevent extending this type. ! It is not used for storage association. sequence private character ( len = :), allocatable :: raw end type string_type","tags":"","loc":"type/string_type.html"},{"title":"bitset_64 – Fortran-lang/stdlib ","text":"type, public, extends( bitset_type ) :: bitset_64 Type for bitsets with no more than 64 bits ( Specification ) Inherits type~~bitset_64~~InheritsGraph type~bitset_64 bitset_64 type~bitset_type bitset_type type~bitset_64->type~bitset_type Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures all any bit_count bits clear clear_bit clear_range flip flip_bit flip_range from_string init init_zero input none not output read_bitset read_bitset_string read_bitset_unit set set_bit set_range test to_string value write_bitset write_bitset_string write_bitset_unit Source Code bitset_64 Type-Bound Procedures procedure, public, pass(self) :: all => all_64 interface private elemental module function all_64(self) result(all) Returns .true. if all bits in self are 1, .false. otherwise. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self Return Value logical procedure, public, pass(self) :: any => any_64 interface private elemental module function any_64(self) result(any) Returns .true. if any bit in self is 1, .false. otherwise. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self Return Value logical procedure, public, pass(self) :: bit_count => bit_count_64 interface private elemental module function bit_count_64(self) result(bit_count) Returns the number of non-zero bits in self . Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self Return Value integer(kind=bits_kind) procedure, public, pass(self) :: bits public elemental function bits (self) Version experimental Returns the number of bit positions in self . Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) generic, public :: clear => clear_bit , clear_range private interface clear_bit_large() Arguments None private interface clear_range_large() Arguments None procedure, public, pass(self) :: clear_bit => clear_bit_64 interface private elemental module subroutine clear_bit_64(self, pos) Sets to zero the bit at pos position in self . If pos is less than\n zero or greater than bits(self)-1 it is ignored. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: clear_range => clear_range_64 interface private pure module subroutine clear_range_64(self, start_pos, stop_pos) Sets to zero all bits from the start_pos to stop_pos positions in self .\n If stop_pos < start_pos then no bits are modified. Positions outside\n the range 0 to bits(set)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos generic, public :: flip => flip_bit , flip_range private interface flip_bit_large() Arguments None private interface flip_range_large() Arguments None procedure, public, pass(self) :: flip_bit => flip_bit_64 interface private elemental module subroutine flip_bit_64(self, pos) Flips the bit value at the pos position in self , provided the position is\n valid. If pos is less than 0 or greater than bits(self)-1 , no value is\n changed. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: flip_range => flip_range_64 interface private pure module subroutine flip_range_64(self, start_pos, stop_pos) Flips all valid bits from the start_pos to the stop_pos positions in self . If stop_pos < start_pos no bits are flipped. Positions less than\n 0 or greater than bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure, public, pass(self) :: from_string => from_string_64 interface private module subroutine from_string_64(self, string, status) Initializes the bitset self treating string as a binary literal status may have the values:\n * success - if no problems were found,\n * alloc_fault - if allocation of the bitset failed\n * char_string_too_large_error - if string was too large, or\n * char_string_invalid_error - if string had an invalid character. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status generic, public :: init => init_zero private interface init_zero_large() Arguments None procedure, public, pass(self) :: init_zero => init_zero_64 interface private module subroutine init_zero_64(self, bits, status) Creates the bitset, self , of size bits , with all bits initialized to\n zero. bits must be non-negative.  If an error occurs and status is\n absent then processing stops with an informative stop code. status will have one of the values:\n * success -  if no problems were found,\n * alloc_fault - if memory allocation failed\n * array_size_invalid_error - if bits is either negative or larger\n   than 64 with self of class bitset_64 . Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(out) :: self integer(kind=bits_kind), intent(in) :: bits integer, intent(out), optional :: status procedure, public, pass(self) :: input => input_64 interface private module subroutine input_64(self, unit, status) Reads the components of the bitset, self , from the unformatted I/O\n unit, unit , assuming that the components were written using output .\n If an error occurs and status is absent then processing stops with\n an informative stop code. status has one of the values:\n * success - if no problem was found\n * alloc_fault - if it failed allocating memory for self , or\n * array_size_invalid_error if the bits(self) in unit is negative\n   or greater than 64 for a bitset_64 input.\n * read_failure - if it failed during the reads from unit Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(out) :: self integer, intent(in) :: unit integer, intent(out), optional :: status procedure, public, pass(self) :: none => none_64 interface private elemental module function none_64(self) result(none) Returns .true. if none of the bits in self have the value 1. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self Return Value logical procedure, public, pass(self) :: not => not_64 interface private elemental module subroutine not_64(self) Sets the bits in self to their logical complement. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self procedure, public, pass(self) :: output => output_64 interface private module subroutine output_64(self, unit, status) Writes the components of the bitset, self , to the unformatted I/O\n unit, unit , in a unformatted sequence compatible with input . If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success , or the value write_failure if the write failed. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self integer, intent(in) :: unit integer, intent(out), optional :: status generic, public :: read_bitset => read_bitset_string , read_bitset_unit private interface read_bitset_string_large() Arguments None private interface read_bitset_unit_large() Arguments None procedure, public, pass(self) :: read_bitset_string => read_bitset_string_64 interface private module subroutine read_bitset_string_64(self, string, status) Uses the bitset literal in the default character string , to define\n the bitset, self . The literal may be preceded by an an arbitrary\n sequence of blank characters. If status is absent an error results\n in an error stop with an informative stop code. If status is present it has one of the values:\n * success - if no problems occurred,\n * alloc_fault - if allocation of memory for SELF failed,\n * array_size_invalid_error - if bits(self) in string is greater\n   than 64 for a bitset_64 ,\n * char_string_invalid_error - if the bitset literal has an invalid\n   character,\n * char_string_too_small_error - if the string ends before all the bits\n   are read.\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented, Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status procedure, public, pass(self) :: read_bitset_unit => read_bitset_unit_64 interface private module subroutine read_bitset_unit_64(self, unit, advance, status) Uses the bitset literal at the current position in the formatted\n file with I/O unit, unit , to define the bitset, self . The literal\n may be preceded by an an arbitrary sequence of blank characters.\n If advance is present it must be either 'YES' or 'NO'. If absent\n it has the default value of 'YES' to determine whether advancing\n I/O occurs. If status is absent an error results in an error stop\n with an informative stop code. If status is present it has one of\n the values:\n * success - if no problem occurred,\n * alloc_fault - if allocation of self failed,\n * array_size_invalid_error - if bits(self) in the bitset literal\n   is greater than 64 for a bitset_64 ,\n * char_string_invalid_error - if the read of the bitset literal found\n   an invalid character,\n * eof_failure - if a read statement reached an end-of-file before\n   completing the read of the bitset literal,\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented,\n * read_failure - if a read statement fails, Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(out) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status generic, public :: set => set_bit , set_range private interface set_bit_large() Arguments None private interface set_range_large() Arguments None procedure, public, pass(self) :: set_bit => set_bit_64 interface private elemental module subroutine set_bit_64(self, pos) Sets the value at the pos position in self , provided the position is\n valid. If the position is less than 0 or greater than bits(self)-1 then self is unchanged. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: set_range => set_range_64 interface private pure module subroutine set_range_64(self, start_pos, stop_pos) Sets all valid bits to 1 from the start_pos to the stop_pos positions\n in self . If stop_pos < start_pos no bits are changed. Positions outside\n the range 0 to bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure, public, pass(self) :: test => test_64 interface private elemental module function test_64(self, pos) result(test) Returns .true. if the pos position is set, .false. otherwise. If pos is negative or greater than bits(self)-1 the result is .false. . Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value logical procedure, public, pass(self) :: to_string => to_string_64 interface private module subroutine to_string_64(self, string, status) Represents the value of self as a binary literal in string .\n Status may have the values success or alloc_fault Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure, public, pass(self) :: value => value_64 interface private elemental module function value_64(self, pos) result(value) Returns 1 if the pos position is set, 0 otherwise. If pos is negative\n or greater than bits(set)-1 the result is 0. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value integer generic, public :: write_bitset => write_bitset_string , write_bitset_unit private interface write_bitset_string_large() Arguments None private interface write_bitset_unit_large() Arguments None procedure, public, pass(self) :: write_bitset_string => write_bitset_string_64 interface private module subroutine write_bitset_string_64(self, string, status) Writes a bitset literal to the allocatable default character string ,\n representing the individual bit values in the bitset_64 , self .\n If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success , or the value alloc_fault if allocation of\n the output string failed. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure, public, pass(self) :: write_bitset_unit => write_bitset_unit_64 interface private module subroutine write_bitset_unit_64(self, unit, advance, status) Writes a bitset literal to the I/O unit, unit , representing the\n individual bit values in the bitset, self . By default or if advance is present with the value 'YES', advancing output is used.\n If advance is present with the value 'NO', then the current record\n is not advanced by the write. If status is absent an error results\n in an error stop with an informative stop code. If status is\n present it has the default value of success , the value alloc_fault if allocation of the output string failed, or write_failure if the write statement outputting the literal failed. Arguments Type Intent Optional Attributes Name class( bitset_64 ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status Source Code type , extends ( bitset_type ) :: bitset_64 !! Version: experimental !! !! Type for bitsets with no more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( block_kind ), private :: block = 0 contains procedure , pass ( self ) :: all => all_64 procedure , pass ( self ) :: any => any_64 procedure , pass ( self ) :: bit_count => bit_count_64 procedure , pass ( self ) :: clear_bit => clear_bit_64 procedure , pass ( self ) :: clear_range => clear_range_64 procedure , pass ( self ) :: flip_bit => flip_bit_64 procedure , pass ( self ) :: flip_range => flip_range_64 procedure , pass ( self ) :: from_string => from_string_64 procedure , pass ( self ) :: init_zero => init_zero_64 procedure , pass ( self ) :: input => input_64 procedure , pass ( self ) :: none => none_64 procedure , pass ( self ) :: not => not_64 procedure , pass ( self ) :: output => output_64 procedure , pass ( self ) :: read_bitset_string => read_bitset_string_64 procedure , pass ( self ) :: read_bitset_unit => read_bitset_unit_64 procedure , pass ( self ) :: set_bit => set_bit_64 procedure , pass ( self ) :: set_range => set_range_64 procedure , pass ( self ) :: test => test_64 procedure , pass ( self ) :: to_string => to_string_64 procedure , pass ( self ) :: value => value_64 procedure , pass ( self ) :: write_bitset_string => write_bitset_string_64 procedure , pass ( self ) :: write_bitset_unit => write_bitset_unit_64 end type bitset_64","tags":"","loc":"type/bitset_64.html"},{"title":"bitset_large – Fortran-lang/stdlib ","text":"type, public, extends( bitset_type ) :: bitset_large Type for bitsets with more than 64 bits ( Specification ) Inherits type~~bitset_large~~InheritsGraph type~bitset_large bitset_large type~bitset_type bitset_type type~bitset_large->type~bitset_type Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures all any bit_count bits clear clear_bit clear_range flip flip_bit flip_range from_string init init_zero input none not output read_bitset read_bitset_string read_bitset_unit set set_bit set_range test to_string value write_bitset write_bitset_string write_bitset_unit Source Code bitset_large Type-Bound Procedures procedure, public, pass(self) :: all => all_large interface private elemental module function all_large(self) result(all) Returns .true. if all bits in self are 1, .false. otherwise. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self Return Value logical procedure, public, pass(self) :: any => any_large interface private elemental module function any_large(self) result(any) Returns .true. if any bit in self is 1, .false. otherwise. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self Return Value logical procedure, public, pass(self) :: bit_count => bit_count_large interface private elemental module function bit_count_large(self) result(bit_count) Returns the number of non-zero bits in self . Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self Return Value integer(kind=bits_kind) procedure, public, pass(self) :: bits public elemental function bits (self) Version experimental Returns the number of bit positions in self . Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) generic, public :: clear => clear_bit , clear_range private interface clear_bit_large() Arguments None private interface clear_range_large() Arguments None procedure, public, pass(self) :: clear_bit => clear_bit_large interface private elemental module subroutine clear_bit_large(self, pos) Sets to zero the bit at pos position in self . If pos is less than\n zero or greater than bits(self)-1 it is ignored. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: clear_range => clear_range_large interface private pure module subroutine clear_range_large(self, start_pos, stop_pos) Sets to zero all bits from the start_pos to stop_pos positions in self .\n If stop_pos < start_pos then no bits are modified. Positions outside\n the range 0 to bits(set)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos generic, public :: flip => flip_bit , flip_range private interface flip_bit_large() Arguments None private interface flip_range_large() Arguments None procedure, public, pass(self) :: flip_bit => flip_bit_large interface private elemental module subroutine flip_bit_large(self, pos) Flips the bit value at the pos position in self , provided the position is\n valid. If pos is less than 0 or greater than bits(self)-1 , no value is\n changed. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: flip_range => flip_range_large interface private pure module subroutine flip_range_large(self, start_pos, stop_pos) Flips all valid bits from the start_pos to the stop_pos positions in self . If stop_pos < start_pos no bits are flipped. Positions less than\n 0 or greater than bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure, public, pass(self) :: from_string => from_string_large interface private module subroutine from_string_large(self, string, status) Initializes the bitset self treating string as a binary literal status may have the values:\n * success - if no problems were found,\n * alloc_fault - if allocation of the bitset failed\n * char_string_too_large_error - if string was too large, or\n * char_string_invalid_error - if string had an invalid character. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status generic, public :: init => init_zero private interface init_zero_large() Arguments None procedure, public, pass(self) :: init_zero => init_zero_large interface private module subroutine init_zero_large(self, bits, status) Creates the bitset, self , of size bits , with all bits initialized to\n zero. bits must be non-negative.  If an error occurs and status is\n absent then processing stops with an informative stop code. status will have one of the values;\n * success -  if no problems were found,\n * alloc_fault - if memory allocation failed\n * array_size_invalid_error - if bits is either negative or larger\n   than 64 with self of class bitset_64 , or Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(out) :: self integer(kind=bits_kind), intent(in) :: bits integer, intent(out), optional :: status procedure, public, pass(self) :: input => input_large interface private module subroutine input_large(self, unit, status) Reads the components of the bitset, self , from the unformatted I/O\n unit, unit , assuming that the components were written using output .\n If an error occurs and status is absent then processing stops with\n an informative stop code. status has one of the values:\n * success - if no problem was found\n * alloc_fault - if it failed allocating memory for self , or\n * array_size_invalid_error if the bits(self) in unit is negative\n   or greater than 64 for a bitset_64 input.\n * read_failure - if it failed during the reads from unit Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(out) :: self integer, intent(in) :: unit integer, intent(out), optional :: status procedure, public, pass(self) :: none => none_large interface private elemental module function none_large(self) result(none) Returns .true. if none of the bits in self have the value 1. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self Return Value logical procedure, public, pass(self) :: not => not_large interface private elemental module subroutine not_large(self) Sets the bits in self to their logical complement Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self procedure, public, pass(self) :: output => output_large interface private module subroutine output_large(self, unit, status) Writes the components of the bitset, self , to the unformatted I/O\n unit, unit , in a unformatted sequence compatible with input . If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success , or the value write_failure if the write failed. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self integer, intent(in) :: unit integer, intent(out), optional :: status generic, public :: read_bitset => read_bitset_string , read_bitset_unit private interface read_bitset_string_large() Arguments None private interface read_bitset_unit_large() Arguments None procedure, public, pass(self) :: read_bitset_string => read_bitset_string_large interface private module subroutine read_bitset_string_large(self, string, status) Uses the bitset literal in the default character string , to define\n the bitset, self . The literal may be preceded by an an arbitrary\n sequence of blank characters. If status is absent an error results\n in an error stop with an informative stop code. If status is present it has one of the values\n * success - if no problems occurred,\n * alloc_fault - if allocation of memory for SELF failed,\n * array_size_invalid_error - if bits(self) in string is greater\n   than 64 for a bitset_64 ,\n * char_string_invalid_error - if the bitset literal has an invalid\n   character,\n * char_string_too_small_error - if the string ends before all the bits\n   are read.\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented, Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status procedure, public, pass(self) :: read_bitset_unit => read_bitset_unit_large interface private module subroutine read_bitset_unit_large(self, unit, advance, status) Uses the bitset literal at the current position in the formatted\n file with I/O unit, unit , to define the bitset, self . The literal\n may be preceded by an an arbitrary sequence of blank characters.\n If advance is present it must be either 'YES' or 'NO'. If absent\n it has the default value of 'YES' to determine whether advancing\n I/O occurs. If status is absent an error results in an error stop\n with an informative stop code. If status is present it has one of\n the values:\n * success - if no problem occurred,\n * alloc_fault - if allocation of self failed,\n * array_size_invalid_error - if bits(self) in the bitset literal\n   is greater than 64 for a bitset_64 ,\n * char_string_invalid_error - if the read of the bitset literal found\n   an invalid character,\n * eof_failure - if a read statement reached an end-of-file before\n   completing the read of the bitset literal,\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented,\n * read_failure - if a read statement fails, Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(out) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status generic, public :: set => set_bit , set_range private interface set_bit_large() Arguments None private interface set_range_large() Arguments None procedure, public, pass(self) :: set_bit => set_bit_large interface private elemental module subroutine set_bit_large(self, pos) Sets the value at the pos position in self , provided the position is\n valid. If the position is less than 0 or greater than bits(self)-1 then self is unchanged. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure, public, pass(self) :: set_range => set_range_large interface private pure module subroutine set_range_large(self, start_pos, stop_pos) Sets all valid bits to 1 from the start_pos to the stop_pos positions\n in self . If stop_pos < start_pos no bits are changed. Positions outside\n the range 0 to bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure, public, pass(self) :: test => test_large interface private elemental module function test_large(self, pos) result(test) Returns .true. if the pos position is set, .false. otherwise. If pos is negative or greater than bits(self) - 1 the result is .false. . Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value logical procedure, public, pass(self) :: to_string => to_string_large interface private module subroutine to_string_large(self, string, status) Represents the value of self as a binary literal in string Status may have the values success or alloc_fault . Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure, public, pass(self) :: value => value_large interface private elemental module function value_large(self, pos) result(value) Returns 1 if the pos position is set, 0 otherwise. If pos is negative\n or greater than bits(set) - 1 the result is 0. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value integer generic, public :: write_bitset => write_bitset_string , write_bitset_unit private interface write_bitset_string_large() Arguments None private interface write_bitset_unit_large() Arguments None procedure, public, pass(self) :: write_bitset_string => write_bitset_string_large interface private module subroutine write_bitset_string_large(self, string, status) Writes a bitset literal to the allocatable default character string ,\n representing the individual bit values in the bitset_large, self .\n If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success, or the value alloc_fault` if allocation of\n the output string failed. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure, public, pass(self) :: write_bitset_unit => write_bitset_unit_large interface private module subroutine write_bitset_unit_large(self, unit, advance, status) Writes a bitset literal to the I/O unit, unit , representing the\n individual bit values in the bitset, self . By default or if advance is present with the value 'YES', advancing output is used.\n If advance is present with the value 'NO', then the current record\n is not advanced by the write. If status is absent an error results\n in an error stop with an informative stop code. If status is\n present it has the default value of success , the value alloc_fault if allocation of the output string failed, or write_failure if the write statement outputting the literal failed. Arguments Type Intent Optional Attributes Name class( bitset_large ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status Source Code type , extends ( bitset_type ) :: bitset_large !! Version: experimental !! !! Type for bitsets with more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( block_kind ), private , allocatable :: blocks (:) contains procedure , pass ( self ) :: all => all_large procedure , pass ( self ) :: any => any_large procedure , pass ( self ) :: bit_count => bit_count_large procedure , pass ( self ) :: clear_bit => clear_bit_large procedure , pass ( self ) :: clear_range => clear_range_large procedure , pass ( self ) :: flip_bit => flip_bit_large procedure , pass ( self ) :: flip_range => flip_range_large procedure , pass ( self ) :: from_string => from_string_large procedure , pass ( self ) :: init_zero => init_zero_large procedure , pass ( self ) :: input => input_large procedure , pass ( self ) :: none => none_large procedure , pass ( self ) :: not => not_large procedure , pass ( self ) :: output => output_large procedure , pass ( self ) :: & read_bitset_string => read_bitset_string_large procedure , pass ( self ) :: read_bitset_unit => read_bitset_unit_large procedure , pass ( self ) :: set_bit => set_bit_large procedure , pass ( self ) :: set_range => set_range_large procedure , pass ( self ) :: test => test_large procedure , pass ( self ) :: to_string => to_string_large procedure , pass ( self ) :: value => value_large procedure , pass ( self ) :: & write_bitset_string => write_bitset_string_large procedure , pass ( self ) :: write_bitset_unit => write_bitset_unit_large end type bitset_large","tags":"","loc":"type/bitset_large.html"},{"title":"bitset_type – Fortran-lang/stdlib ","text":"type, public, abstract :: bitset_type Parent type for bitset_64 and bitset_large ( Specification ) Inherited by type~~bitset_type~~InheritedByGraph type~bitset_type bitset_type type~bitset_64 bitset_64 type~bitset_64->type~bitset_type type~bitset_large bitset_large type~bitset_large->type~bitset_type Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures all any bit_count bits clear clear_bit clear_range flip flip_bit flip_range from_string init init_zero input none not output read_bitset read_bitset_string read_bitset_unit set set_bit set_range test to_string value write_bitset write_bitset_string write_bitset_unit Source Code bitset_type Type-Bound Procedures procedure(all_abstract), public, deferred, pass(self) :: all elemental function all_abstract(self) result(all) Prototype Returns .true. if all bits in self are 1, .false. otherwise. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value logical procedure(any_abstract), public, deferred, pass(self) :: any elemental function any_abstract(self) result(any) Prototype Returns .true. if any bit in self is 1, .false. otherwise. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value logical procedure(bit_count_abstract), public, deferred, pass(self) :: bit_count elemental function bit_count_abstract(self) result(bit_count) Prototype Returns the number of non-zero bits in self . Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) procedure, public, pass(self) :: bits public elemental function bits (self) Version experimental Returns the number of bit positions in self . Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) generic, public :: clear => clear_bit , clear_range private interface clear_bit_large() Arguments None private interface clear_range_large() Arguments None procedure(clear_bit_abstract), public, deferred, pass(self) :: clear_bit elemental subroutine clear_bit_abstract(self, pos) Prototype Sets to zero the pos position in self . If pos is less than zero or\n greater than bits(self)-1 it is ignored. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure(clear_range_abstract), public, deferred, pass(self) :: clear_range pure subroutine clear_range_abstract(self, start_pos, stop_pos) Prototype Sets to zero all bits from the start_pos to stop_pos positions in set .\n If stop_pos < start_pos then no bits are modified. Positions outside\n the range 0 to bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos generic, public :: flip => flip_bit , flip_range private interface flip_bit_large() Arguments None private interface flip_range_large() Arguments None procedure(flip_bit_abstract), public, deferred, pass(self) :: flip_bit elemental subroutine flip_bit_abstract(self, pos) Prototype Flips the value at the pos position in self , provided the position is\n valid. If pos is less than 0 or greater than bits(self)-1 , no value is\n changed. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure(flip_range_abstract), public, deferred, pass(self) :: flip_range pure subroutine flip_range_abstract(self, start_pos, stop_pos) Prototype Flips all valid bits from the start_pos to the stop_pos positions in self . If stop_pos < start_pos no bits are flipped. Positions less than\n 0 or greater than bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure(from_string_abstract), public, deferred, pass(self) :: from_string subroutine from_string_abstract(self, string, status) Prototype Initializes the bitset self treating string as a binary literal status may have the values:\n * success - if no problems were found,\n * alloc_fault - if allocation of the bitset failed\n * char_string_too_large_error - if string was too large, or\n * char_string_invalid_error - if string had an invalid character. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status generic, public :: init => init_zero private interface init_zero_large() Arguments None procedure(init_zero_abstract), public, deferred, pass(self) :: init_zero subroutine init_zero_abstract(self, bits, status) Prototype Creates the bitset, self , of size bits , with all bits initialized to\n zero. bits must be non-negative.  If an error occurs and status is\n absent then processing stops with an informative stop code. status will have one of the values;\n * success -  if no problems were found,\n * alloc_fault - if memory allocation failed\n * array_size_invalid_error - if bits is either negative or larger\n   than 64 with self of class bitset_64 , or Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(out) :: self integer(kind=bits_kind), intent(in) :: bits integer, intent(out), optional :: status procedure(input_abstract), public, deferred, pass(self) :: input subroutine input_abstract(self, unit, status) Prototype Reads the components of the bitset, self , from the unformatted I/O\n unit, unit , assuming that the components were written using output .\n If an error occurs and status is absent then processing stops with\n an informative stop code. status has one of the values:\n * success - if no problem was found\n * alloc_fault - if it failed allocating memory for self , or\n * array_size_invalid_error if the bits(self) in unit is negative\n   or greater than 64 for a bitset_64 input.\n * read_failure - if it failed during the reads from unit Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(out) :: self integer, intent(in) :: unit integer, intent(out), optional :: status procedure(none_abstract), public, deferred, pass(self) :: none elemental function none_abstract(self) result(none) Prototype Returns .true. if none of the bits in self have the value 1. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value logical procedure(not_abstract), public, deferred, pass(self) :: not elemental subroutine not_abstract(self) Prototype Sets the bits in self to their logical complement Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self procedure(output_abstract), public, deferred, pass(self) :: output subroutine output_abstract(self, unit, status) Prototype Writes the components of the bitset, self , to the unformatted I/O\n unit, unit , in a unformatted sequence compatible with input . If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success , or the value write_failure if the write failed. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self integer, intent(in) :: unit integer, intent(out), optional :: status generic, public :: read_bitset => read_bitset_string , read_bitset_unit private interface read_bitset_string_large() Arguments None private interface read_bitset_unit_large() Arguments None procedure(read_bitset_string_abstract), public, deferred, pass(self) :: read_bitset_string subroutine read_bitset_string_abstract(self, string, status) Prototype Uses the bitset literal in the default character string , to define\n the bitset, self . The literal may be preceded by an an arbitrary\n sequence of blank characters. If status is absent an error results\n in an error stop with an informative stop code. If status is present it has one of the values\n * success - if no problems occurred,\n * alloc_fault - if allocation of memory for SELF failed,\n * array_size_invalid_error - if bits(self) in string is greater\n   than 64 for a bitset_64 ,\n * char_string_invalid_error - if the bitset literal has an invalid\n   character,\n * char_string_too_small_error - if the string ends before all the bits\n   are read.\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented, Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(out) :: self character(len=*), intent(in) :: string integer, intent(out), optional :: status procedure(read_bitset_unit_abstract), public, deferred, pass(self) :: read_bitset_unit subroutine read_bitset_unit_abstract(self, unit, advance, status) Prototype Uses the bitset literal at the current position in the formatted\n file with I/O unit, unit , to define the bitset, self . The literal\n may be preceded by an an arbitrary sequence of blank characters.\n If advance is present it must be either 'YES' or 'NO'. If absent\n it has the default value of 'YES' to determine whether advancing\n I/O occurs. If status is absent an error results in an error stop\n with an informative stop code. If status is present it has one of\n the values:\n * success - if no problem occurred,\n * alloc_fault - if allocation of self failed,\n * array_size_invalid_error - if bits(self) in the bitset literal\n   is greater than 64 for a bitset_64 ,\n * char_string_invalid_error - if the read of the bitset literal found\n   an invalid character,\n * eof_failure - if a read statement reached an end-of-file before\n   completing the read of the bitset literal,\n * integer_overflow_error - if the bitset literal has a bits(self) value too large to be represented,\n * read_failure - if a read statement fails, Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(out) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status generic, public :: set => set_bit , set_range private interface set_bit_large() Arguments None private interface set_range_large() Arguments None procedure(set_bit_abstract), public, deferred, pass(self) :: set_bit elemental subroutine set_bit_abstract(self, pos) Prototype Sets the value at the pos position in self , provided the position is\n valid. If the position is less than 0 or greater than bits(self)-1 then self is unchanged. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: pos procedure(set_range_abstract), public, deferred, pass(self) :: set_range pure subroutine set_range_abstract(self, start_pos, stop_pos) Prototype Sets all valid bits to 1 from the start_pos to the stop_pos positions\n in self . If stop_pos < start_pos no bits are changed. Positions outside\n the range 0 to bits(self)-1 are ignored. Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(inout) :: self integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos procedure(test_abstract), public, deferred, pass(self) :: test elemental function test_abstract(self, pos) result(test) Prototype Returns .true. if the pos position is set, .false. otherwise. If pos is negative or greater than bits(self) - 1 the result is .false. . Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value logical procedure(to_string_abstract), public, deferred, pass(self) :: to_string subroutine to_string_abstract(self, string, status) Prototype Represents the value of self as a binary literal in string Status may have the values success or alloc_fault . Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure(value_abstract), public, deferred, pass(self) :: value elemental function value_abstract(self, pos) result(value) Prototype Returns 1 if the pos position is set, 0 otherwise. If pos is negative\n or greater than bits(set) - 1 the result is 0. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self integer(kind=bits_kind), intent(in) :: pos Return Value integer generic, public :: write_bitset => write_bitset_string , write_bitset_unit private interface write_bitset_string_large() Arguments None private interface write_bitset_unit_large() Arguments None procedure(write_bitset_string_abstract), public, deferred, pass(self) :: write_bitset_string subroutine write_bitset_string_abstract(self, string, status) Prototype Writes a bitset literal to the allocatable default character string ,\n representing the individual bit values in the bitset_type , self .\n If status is absent an error results in an error stop with an\n informative stop code. If status is present it has the default\n value of success , or the value alloc_fault if allocation of\n the output string failed. Read more… Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self character(len=:), intent(out), allocatable :: string integer, intent(out), optional :: status procedure(write_bitset_unit_abstract), public, deferred, pass(self) :: write_bitset_unit subroutine write_bitset_unit_abstract(self, unit, advance, status) Prototype Writes a bitset literal to the I/O unit, unit , representing the\n individual bit values in the bitset_t , self . If an error occurs then\n processing stops with a message to error_unit . By default or if advance is present with the value 'YES', advancing output is used.\n If advance is present with the value 'NO', then the current record\n is not advanced by the write. If status is absent, an error results\n in an error stop with an informative stop code. If status is\n present it has the default value of success , the value alloc_fault if allocation of the output string failed, write_failure if the write statement outputting the literal failed. Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: advance integer, intent(out), optional :: status Source Code type , abstract :: bitset_type !! version: experimental !! !! Parent type for bitset_64 and bitset_large ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types)) private integer ( bits_kind ) :: num_bits contains procedure ( all_abstract ), deferred , pass ( self ) :: all procedure ( any_abstract ), deferred , pass ( self ) :: any procedure ( bit_count_abstract ), deferred , pass ( self ) :: bit_count procedure , pass ( self ) :: bits procedure ( clear_bit_abstract ), deferred , pass ( self ) :: clear_bit procedure ( clear_range_abstract ), deferred , pass ( self ) :: clear_range generic :: clear => clear_bit , clear_range procedure ( flip_bit_abstract ), deferred , pass ( self ) :: flip_bit procedure ( flip_range_abstract ), deferred , pass ( self ) :: flip_range generic :: flip => flip_bit , flip_range procedure ( from_string_abstract ), deferred , pass ( self ) :: from_string procedure ( init_zero_abstract ), deferred , pass ( self ) :: init_zero generic :: init => init_zero procedure ( input_abstract ), deferred , pass ( self ) :: input procedure ( none_abstract ), deferred , pass ( self ) :: none procedure ( not_abstract ), deferred , pass ( self ) :: not procedure ( output_abstract ), deferred , pass ( self ) :: output procedure ( read_bitset_string_abstract ), deferred , pass ( self ) :: & read_bitset_string procedure ( read_bitset_unit_abstract ), deferred , pass ( self ) :: & read_bitset_unit generic :: read_bitset => read_bitset_string , read_bitset_unit procedure ( set_bit_abstract ), deferred , pass ( self ) :: set_bit procedure ( set_range_abstract ), deferred , pass ( self ) :: set_range generic :: set => set_bit , set_range procedure ( test_abstract ), deferred , pass ( self ) :: test procedure ( to_string_abstract ), deferred , pass ( self ) :: to_string procedure ( value_abstract ), deferred , pass ( self ) :: value procedure ( write_bitset_string_abstract ), deferred , pass ( self ) :: & write_bitset_string procedure ( write_bitset_unit_abstract ), deferred , pass ( self ) :: & write_bitset_unit generic :: write_bitset => write_bitset_string , write_bitset_unit end type bitset_type","tags":"","loc":"type/bitset_type.html"},{"title":"logger_type – Fortran-lang/stdlib ","text":"type, public :: logger_type Public derived type ( Specification ) Contents Finalization Procedures final_logger Type-Bound Procedures add_log_file add_log_unit configuration configure log_debug log_error log_information log_io_error log_message log_text_error log_units_assigned log_warning remove_log_unit Source Code logger_type Finalization Procedures final :: final_logger private subroutine final_logger(self) Finalizes the logger_type entity self by flushing the units Arguments Type Intent Optional Attributes Name type( logger_type ), intent(in) :: self Type-Bound Procedures procedure, public, pass(self) :: add_log_file private subroutine add_log_file(self, filename, unit, action, position, status, stat) Opens a formatted sequential access output file, filename using newunit and adds the resulting unit number to self 's log_units array. action , if present, is the action specifier of the open statement, and has the default value of \"write\" . position , if present,\n is the position specifier, and has the default value of \"REWIND\" . status , if present, is the status specifier of the open statement,\n and has the default value of \"REPLACE\" . stat , if present, has the value success if filename could be opened, read_only_error if action is \"read\" , and open_failure otherwise.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable to which the file is to be added character(len=*), intent(in) :: filename The name of the file to be  added to the logger integer, intent(out), optional :: unit The resulting I/O unit number character(len=*), intent(in), optional :: action The action specifier for the `open`` statement character(len=*), intent(in), optional :: position The position specifier for the open statement character(len=*), intent(in), optional :: status The status specifier for the open statement integer, intent(out), optional :: stat The error status on exit with the possible values\n * success - no errors found\n * read_only_error - file unopened as action1 was \"read\" for an output\n   file\n * open_failure - the open` statement failed Example program main use stdlib_logger ... integer :: unit, stat ... call global_logger % add_log_file( 'error_log.txt', unit,      & position='asis', stat=stat ) if ( stat /= success ) then error stop 'Unable to open \"error_log.txt\".' end if ... end program main procedure, public, pass(self) :: add_log_unit private subroutine add_log_unit(self, unit, stat) Adds unit to the log file units in log_units . unit must be an open file, of form \"formatted\" , with \"sequential\" access , and an action of \"write\" or \"readwrite\" , otherwise either stat , if present, has a\n value other than success and unit is not entered into log_units ,\n or, if stat is not presecn, processing stops.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable to which the I/O unit is to be added integer, intent(in) :: unit The input logical unit number integer, intent(out), optional :: stat An error code with the possible values\n * success - no problems were found\n * non_sequential_error - unit did not have sequential access\n * read_only_error - unit was not writeable\n * unformatted_in_error - unit was an 'unformatted' file\n * unopened_in_error - unit was not opened Example program main use stdlib_logger ... character(256) :: iomsg integer :: iostat, unit, stat ... open( newunit=unit, 'error_log.txt', form='formatted', & status='replace', position='rewind', err=999,    & action='read', iostat=iostat, iomsg=iomsg ) ... call global_logger % add_log_unit( unit, stat ) select case ( stat ) ... case ( read_only_error ) error stop 'Unable to write to \"error_log.txt\".' ... end select ... 999 error stop 'Unable to open \"error_log.txt\". ... end program main procedure, public, pass(self) :: configuration private pure subroutine configuration(self, add_blank_line, indent, level, max_width, time_stamp, log_units) Reports the logging configuration of self . The following attributes are\n reported:\n 1. add_blank_line is a logical flag with .true. implying that output\n    starts with a blank line, and .false. implying no blank line.\n 2. indent is a logical flag with .true. implying that subsequent columns\n    will be indented 4 spaces and .false. implying no indentation.\n 3. level is the lowest level for printing a message\n 4. max_width is the maximum number of columns of output text with max_width == 0 => no bounds on output width.\n 5. time_stamp is a logical flag with .true. implying that the output\n    will have a time stamp, and .false. implying that there will be no\n    time stamp.\n 6. log_units is an array of the I/O unit numbers to which log output\n    will be written.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable whose configuration is being reported logical, intent(out), optional :: add_blank_line A logical flag to add a preceding blank line logical, intent(out), optional :: indent A logical flag to indent subsequent lines integer, intent(out), optional :: level The minimum level for printing a message integer, intent(out), optional :: max_width The maximum number of columns for most outputs logical, intent(out), optional :: time_stamp A logical flag to add a time stamp integer, intent(out), optional allocatable :: log_units (:) The I/O units used in output Example module example_mod use stdlib_logger ... contains ... subroutine example_sub(unit, ...) integer, intent(in) :: unit ... integer, allocatable :: log_units(:) ... call global_logger % configuration( log_units=log_units ) if ( size(log_units) == 0 ) then call add_logger_unit( unit ) end if .. end subroutine example_sub ... end module example_mod procedure, public, pass(self) :: configure private pure subroutine configure(self, add_blank_line, indent, level, max_width, time_stamp) Configures the logging process for SELF. The following attributes are\n configured:\n 1. add_blank_line is a logical flag with .true. implying that output\n    starts with a blank line, and .false. implying no blank line. add_blank_line has a startup value of .false. .\n 2. indent is a logical flag with .true. implying that subsequent lines\n    will be indented 4 spaces and .false. implying no indentation. indent has a startup value of .true. .\n 3. level is the lowest level for printing a message\n 4. max_width is the maximum number of columns of output text with max_width == 0 => no bounds on output width. max_width has a startup\n    value of 0.\n 5. time_stamp is a logical flag with .true. implying that the output\n    will have a time stamp, and .false. implying that there will be no\n    time stamp. time_stamp has a startup value of .true. .\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self logical, intent(in), optional :: add_blank_line logical, intent(in), optional :: indent integer, intent(in), optional :: level integer, intent(in), optional :: max_width logical, intent(in), optional :: time_stamp procedure, public, pass(self) :: log_debug private subroutine log_debug(self, message, module, procedure) Writes the string message to self % log_units with optional additional\n text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger used to send the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module containing the current invocation of log_information character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of log_information procedure, public, pass(self) :: log_error private subroutine log_error(self, message, module, procedure, stat, errmsg) Writes the string message to self % log_units with optional additional\n text.\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger to be used in logging the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module containing the current invocation of log_error character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of log_error integer, intent(in), optional :: stat The value of the stat specifier returned by a Fortran statement character(len=*), intent(in), optional :: errmsg The value of the errmsg specifier returned by a Fortran statement procedure, public, pass(self) :: log_information private subroutine log_information(self, message, module, procedure) Writes the string message to self % log_units with optional additional\n text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger used to send the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module containing the current invocation of log_information character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of log_information procedure, public, pass(self) :: log_io_error private subroutine log_io_error(self, message, module, procedure, iostat, iomsg) Writes the string message to the self % log_units with optional\n additional text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receivee the message character(len=*), intent(in) :: message A string to be written to LOG_UNIT character(len=*), intent(in), optional :: module The name of the module containing the current invocation of REPORT_ERROR character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of REPORT_ERROR integer, intent(in), optional :: iostat The value of the IOSTAT specifier returned by a Fortran I/O statement character(len=*), intent(in), optional :: iomsg The value of the IOMSG specifier returned by a Fortran I/O statement procedure, public, pass(self) :: log_message private subroutine log_message(self, message, module, procedure, prefix) Writes the string message to the self % log_units with optional\n additional text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receive the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module containing the current invocation of log_message character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of log_message character(len=*), intent(in), optional :: prefix To be prepended to message as prefix // ': ' // message . procedure, public, pass(self) :: log_text_error private subroutine log_text_error(self, line, column, summary, filename, line_number, caret, stat) Sends a message to self % log_units describing an error found\n in a line of text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receive the message character(len=*), intent(in) :: line The line of text in which the error was found. integer, intent(in) :: column The one's based column in LINE at which the error starts. character(len=*), intent(in) :: summary A brief description of the error. character(len=*), intent(in), optional :: filename The name of the file, if any, in which the error was found. integer, intent(in), optional :: line_number The one's based line number in the file where line was found. character(len=1), intent(in), optional :: caret The symbol used to mark the column wher the error was first detected integer, intent(out), optional :: stat Integer flag that an error has occurred. Has the value success if no\n error hass occurred, index_invalid_error if column is less than zero or\n greater than len(line) , and write_failure if any of the write statements has failed. procedure, public, pass(self) :: log_units_assigned private elemental function log_units_assigned(self) Returns the number of units assigned to self % log_units ( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger subject to the inquiry Return Value integer Read more… procedure, public, pass(self) :: log_warning private subroutine log_warning(self, message, module, procedure) Writes the string message to self % log_units with optional additional\n text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger to which the message is written character(len=*), intent(in) :: message A string to be written to LOG_UNIT character(len=*), intent(in), optional :: module The name of the module containing the current invocation of log_warning character(len=*), intent(in), optional :: procedure The name of the procedure containing the current invocation of log_warning procedure, public, pass(self) :: remove_log_unit private subroutine remove_log_unit(self, unit, close_unit, stat) Remove the I/O unit from the self % log_units list. If close_unit is\n present and .true. then the corresponding file is closed. If unit is\n not in log_units then nothing is done. If stat is present it, by\n default, has the value success . If closing the unit fails, then if stat is present it has the value close_failure , otherwise processing\n stops with an informative message.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable whose unit is to be removed integer, intent(in) :: unit The I/O unit to be removed from self logical, intent(in), optional :: close_unit A logical flag to close the unit while removing it from the SELF list integer, intent(out), optional :: stat An error status with the values\n * success - no problems found\n * close_failure - the close statement for unit failed Example module  example_mod use stdlib_logger ... type(logger_type) ::  alogger contains ... subroutine example_sub(unit, ...) integer, intent(in) :: unit ... call alogger % remove_log_unit( unit ) ... end subroutine example_sub ... end module example_mod Source Code type :: logger_type !! version: experimental !! Public derived type ([Specification](../page/specs/stdlib_logger.html#the-derived-type-logger_type)) private logical :: add_blank_line = . false . logical :: indent_lines = . true . integer :: level = information_level integer , allocatable :: log_units (:) integer :: max_width = 0 logical :: time_stamp = . true . integer :: units = 0 contains private procedure , public , pass ( self ) :: add_log_file procedure , public , pass ( self ) :: add_log_unit procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: log_debug procedure , public , pass ( self ) :: log_error procedure , public , pass ( self ) :: log_information procedure , public , pass ( self ) :: log_io_error procedure , public , pass ( self ) :: log_message procedure , public , pass ( self ) :: log_text_error procedure , public , pass ( self ) :: log_units_assigned procedure , public , pass ( self ) :: log_warning procedure , public , pass ( self ) :: remove_log_unit final :: final_logger end type logger_type","tags":"","loc":"type/logger_type.html"},{"title":"eye – Fortran-lang/stdlib","text":"public function eye(n) result(res) Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n) Contents Variables i Source Code eye Variables Type Visibility Attributes Name Initial integer, public :: i Source Code function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye","tags":"","loc":"proc/eye.html"},{"title":"diag – Fortran-lang/stdlib","text":"public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) Contents Functions diag_cdp diag_cdp_k diag_cdp_mat diag_cdp_mat_k diag_cqp diag_cqp_k diag_cqp_mat diag_cqp_mat_k diag_csp diag_csp_k diag_csp_mat diag_csp_mat_k diag_iint16 diag_iint16_k diag_iint16_mat diag_iint16_mat_k diag_iint32 diag_iint32_k diag_iint32_mat diag_iint32_mat_k diag_iint64 diag_iint64_k diag_iint64_mat diag_iint64_mat_k diag_iint8 diag_iint8_k diag_iint8_mat diag_iint8_mat_k diag_rdp diag_rdp_k diag_rdp_mat diag_rdp_mat_k diag_rqp diag_rqp_k diag_rqp_mat diag_rqp_mat_k diag_rsp diag_rsp_k diag_rsp_mat diag_rsp_mat_k Functions public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k))","tags":"","loc":"interface/diag.html"},{"title":"outer_product – Fortran-lang/stdlib","text":"public interface outer_product Computes the outer product of two vectors, returning a rank-2 array\n ( Specification ) Contents Functions outer_product_cdp outer_product_cqp outer_product_csp outer_product_iint16 outer_product_iint32 outer_product_iint64 outer_product_iint8 outer_product_rdp outer_product_rqp outer_product_rsp Functions public pure function outer_product_cdp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: u (:) complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(u),size(v)) public pure function outer_product_cqp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: u (:) complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(u),size(v)) public pure function outer_product_csp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: u (:) complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(u),size(v)) public pure function outer_product_iint16(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: u (:) integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(u),size(v)) public pure function outer_product_iint32(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: u (:) integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(u),size(v)) public pure function outer_product_iint64(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: u (:) integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(u),size(v)) public pure function outer_product_iint8(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: u (:) integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(u),size(v)) public pure function outer_product_rdp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u (:) real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(u),size(v)) public pure function outer_product_rqp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: u (:) real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(u),size(v)) public pure function outer_product_rsp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: u (:) real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(u),size(v))","tags":"","loc":"interface/outer_product.html"},{"title":"trace – Fortran-lang/stdlib","text":"public interface trace Computes the trace of a matrix\n ( Specification ) Contents Module Procedures trace_rsp trace_rdp trace_rqp trace_csp trace_cdp trace_cqp trace_iint8 trace_iint16 trace_iint32 trace_iint64 Module Procedures private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)","tags":"","loc":"interface/trace.html"},{"title":"adjustl – Fortran-lang/stdlib","text":"public interface adjustl Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Contents Module Procedures adjustl_string Module Procedures private elemental function adjustl_string(string) result(adjusted_string) Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr – Fortran-lang/stdlib","text":"public interface adjustr Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Contents Module Procedures adjustr_string Module Procedures private elemental function adjustr_string(string) result(adjusted_string) Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/adjustr.html"},{"title":"assignment(=) – Fortran-lang/stdlib","text":"public interface assignment(=) Assign a character sequence to a string. Contents Module Procedures assign_string_char Module Procedures private elemental subroutine assign_string_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs","tags":"","loc":"interface/assignment(=)~2.html"},{"title":"char – Fortran-lang/stdlib","text":"public interface char Return the character sequence represented by the string. This method is elemental and returns a scalar character value. Contents Module Procedures char_string char_string_pos char_string_range Module Procedures private pure function char_string(string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) private elemental function char_string_pos(string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private pure function char_string_range(string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last-start+1)","tags":"","loc":"interface/char.html"},{"title":"iachar – Fortran-lang/stdlib","text":"public interface iachar Code in ASCII collating sequence. This method is elemental and returns a default integer scalar value. Contents Module Procedures iachar_string Module Procedures private elemental function iachar_string(string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/iachar.html"},{"title":"ichar – Fortran-lang/stdlib","text":"public interface ichar Character-to-integer conversion function. This method is elemental and returns a default integer scalar value. Contents Module Procedures ichar_string Module Procedures private elemental function ichar_string(string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/ichar.html"},{"title":"index – Fortran-lang/stdlib","text":"public interface index Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\n of string substring in string , counting from one. If substring is not\n present in string , zero is returned. This method is elemental and returns a default integer scalar value. Contents Module Procedures index_string_string index_string_char index_char_string Module Procedures private elemental function index_string_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/index.html"},{"title":"len – Fortran-lang/stdlib","text":"public interface len Returns the length of the character sequence represented by the string. This method is elemental and returns a default integer scalar value. Contents Module Procedures len_string Module Procedures private elemental function len_string(string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len.html"},{"title":"len_trim – Fortran-lang/stdlib","text":"public interface len_trim Returns the length of the character sequence without trailing spaces\n represented by the string. This method is elemental and returns a default integer scalar value. Contents Module Procedures len_trim_string Module Procedures private elemental function len_trim_string(string) result(length) Returns the length of the character sequence without trailing spaces\n represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len_trim.html"},{"title":"lge – Fortran-lang/stdlib","text":"public interface lge Lexically compare the order of two character sequences being greater equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lge_string_string lge_string_char lge_char_string Module Procedures private elemental function lge_string_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lge.html"},{"title":"lgt – Fortran-lang/stdlib","text":"public interface lgt Lexically compare the order of two character sequences being greater,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lgt_string_string lgt_string_char lgt_char_string Module Procedures private elemental function lgt_string_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lgt.html"},{"title":"lle – Fortran-lang/stdlib","text":"public interface lle Lexically compare the order of two character sequences being less equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lle_string_string lle_string_char lle_char_string Module Procedures private elemental function lle_string_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lle.html"},{"title":"llt – Fortran-lang/stdlib","text":"public interface llt Lexically compare the order of two character sequences being less,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures llt_string_string llt_string_char llt_char_string Module Procedures private elemental function llt_string_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/llt.html"},{"title":"operator(//) – Fortran-lang/stdlib","text":"public interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\n or both character sequences can be represented by a string. This operator is elemental and returns a scalar character value. Contents Module Procedures concat_string_string concat_string_char concat_char_string Module Procedures private elemental function concat_string_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_char(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_char_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type )","tags":"","loc":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) – Fortran-lang/stdlib","text":"public interface operator(/=) Compare two character sequences for inequality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures ne_string_string ne_string_char ne_char_string Module Procedures private elemental function ne_string_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"operator(<) – Fortran-lang/stdlib","text":"public interface operator(<) Compare two character sequences for being less, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures lt_string_string lt_string_char lt_char_string Module Procedures private elemental function lt_string_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(lt).html"},{"title":"operator(<=) – Fortran-lang/stdlib","text":"public interface operator(<=) Compare two character sequences for being less than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures le_string_string le_string_char le_char_string Module Procedures private elemental function le_string_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(lt=).html"},{"title":"operator(==) – Fortran-lang/stdlib","text":"public interface operator(==) Compare two character sequences for equality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures eq_string_string eq_string_char eq_char_string Module Procedures private elemental function eq_string_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(>) – Fortran-lang/stdlib","text":"public interface operator(>) Compare two character sequences for being greater, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures gt_string_string gt_string_char gt_char_string Module Procedures private elemental function gt_string_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(gt).html"},{"title":"operator(>=) – Fortran-lang/stdlib","text":"public interface operator(>=) Compare two character sequences for being greater than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures ge_string_string ge_string_char ge_char_string Module Procedures private elemental function ge_string_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(gt=).html"},{"title":"read(formatted) – Fortran-lang/stdlib","text":"public interface read(formatted) Read a character sequence from a connected unformatted unit into the string. Contents Module Procedures read_formatted Module Procedures private subroutine read_formatted(string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/read(formatted).html"},{"title":"read(unformatted) – Fortran-lang/stdlib","text":"public interface read(unformatted) Read a character sequence from a connected unformatted unit into the string. Contents Module Procedures read_unformatted Module Procedures private subroutine read_unformatted(string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/read(unformatted).html"},{"title":"repeat – Fortran-lang/stdlib","text":"public interface repeat Repeats the character sequence hold by the string by the number of\n specified copies. This method is elemental and returns a scalar character value. Contents Module Procedures repeat_string Module Procedures private elemental function repeat_string(string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\n specified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type )","tags":"","loc":"interface/repeat.html"},{"title":"reverse – Fortran-lang/stdlib","text":"public interface reverse Reverses the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\n reverse character sequence Contents Module Procedures reverse_string Module Procedures private elemental function reverse_string(string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/reverse.html"},{"title":"scan – Fortran-lang/stdlib","text":"public interface scan Scan a string for the presence of a set of characters. Scans a string for\n any of the characters in a set of characters. If back is either absent or false , this function returns the position\n of the leftmost character of string that is in set . If back is true ,\n the rightmost position is returned. If no character of set is found in string , the result is zero. This method is elemental and returns a default integer scalar value. Contents Module Procedures scan_string_string scan_string_char scan_char_string Module Procedures private elemental function scan_string_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version both the character sequence and the character set are\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/scan.html"},{"title":"string_type – Fortran-lang/stdlib","text":"public interface string_type Constructor for new string instances Contents Module Procedures new_string new_string_from_integer_int8 new_string_from_integer_int16 new_string_from_integer_int32 new_string_from_integer_int64 new_string_from_logical_lk new_string_from_logical_c_bool Module Procedures private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental function new_string_from_integer_int8(val) result(new) Constructor for new string instances from an integer of kind int8. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int16(val) result(new) Constructor for new string instances from an integer of kind int16. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int32(val) result(new) Constructor for new string instances from an integer of kind int32. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int64(val) result(new) Constructor for new string instances from an integer of kind int64. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_lk(val) result(new) Constructor for new string instances from a logical of kind lk. Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_c_bool(val) result(new) Constructor for new string instances from a logical of kind c_bool. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: val Return Value type( string_type )","tags":"","loc":"interface/string_type.html"},{"title":"to_lower – Fortran-lang/stdlib","text":"public interface to_lower Returns the lowercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\n lowercase character sequence Contents Module Procedures to_lower_string Module Procedures private elemental function to_lower_string(string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/to_lower.html"},{"title":"to_sentence – Fortran-lang/stdlib","text":"public interface to_sentence Returns the sentencecase version of the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\n sentencecase character sequence Contents Module Procedures to_sentence_string Module Procedures private elemental function to_sentence_string(string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/to_sentence.html"},{"title":"to_title – Fortran-lang/stdlib","text":"public interface to_title Returns the titlecase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\n titlecase character sequence Contents Module Procedures to_title_string Module Procedures private elemental function to_title_string(string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/to_title.html"},{"title":"to_upper – Fortran-lang/stdlib","text":"public interface to_upper Returns the uppercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\n uppercase character sequence Contents Module Procedures to_upper_string Module Procedures private elemental function to_upper_string(string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/to_upper.html"},{"title":"trim – Fortran-lang/stdlib","text":"public interface trim Returns the character sequence hold by the string without trailing spaces. This method is elemental and returns a scalar character value. Contents Module Procedures trim_string Module Procedures private elemental function trim_string(string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","loc":"interface/trim.html"},{"title":"verify – Fortran-lang/stdlib","text":"public interface verify Scan a string for the absence of a set of characters. Verifies that all\n the characters in string belong to the set of characters in set. If back is either absent or false , this function returns the position\n of the leftmost character of string that is not in set . If back is true ,\n the rightmost position is returned. If all characters of string are found\n in set , the result is zero. This method is elemental and returns a default integer scalar value. Contents Module Procedures verify_string_string verify_string_char verify_char_string Module Procedures private elemental function verify_string_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version both the character sequence and\n the character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the character sequences is\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the set of characters is\n represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/verify.html"},{"title":"write(formatted) – Fortran-lang/stdlib","text":"public interface write(formatted) Write the character sequence hold by the string to a connected formatted\n unit. Contents Module Procedures write_formatted Module Procedures private subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write(formatted).html"},{"title":"write(unformatted) – Fortran-lang/stdlib","text":"public interface write(unformatted) Write the character sequence hold by the string to a connected unformatted\n unit. Contents Module Procedures write_unformatted Module Procedures private subroutine write_unformatted(string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write(unformatted).html"},{"title":"dist_rand – Fortran-lang/stdlib","text":"public interface dist_rand Version experimental Generation of random integers with different kinds\n ( Specification ) Contents Module Procedures dist_rand_iint8 dist_rand_iint16 dist_rand_iint32 dist_rand_iint64 Module Procedures private function dist_rand_iint8(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Return Value integer(kind=int8) private function dist_rand_iint16(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: n Return Value integer(kind=int16) private function dist_rand_iint32(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Return Value integer(kind=int32) private function dist_rand_iint64(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Return Value integer(kind=int64)","tags":"","loc":"interface/dist_rand.html"},{"title":"random_seed – Fortran-lang/stdlib","text":"public interface random_seed Version experimental Set seed value for random number generator\n ( Specification ) Contents Module Procedures random_distribution_seed_iint8 random_distribution_seed_iint16 random_distribution_seed_iint32 random_distribution_seed_iint64 Module Procedures private subroutine random_distribution_seed_iint8(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: put integer(kind=int8), intent(out) :: get private subroutine random_distribution_seed_iint16(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: put integer(kind=int16), intent(out) :: get private subroutine random_distribution_seed_iint32(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: put integer(kind=int32), intent(out) :: get private subroutine random_distribution_seed_iint64(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: put integer(kind=int64), intent(out) :: get","tags":"","loc":"interface/random_seed.html"},{"title":"dlegendre – Fortran-lang/stdlib","text":"public interface dlegendre First derivative Legendre polynomial Contents Functions dlegendre_fp64 Functions public pure elemental function dlegendre_fp64(n, x) result(dleg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp)","tags":"","loc":"interface/dlegendre.html"},{"title":"legendre – Fortran-lang/stdlib","text":"public interface legendre Legendre polynomial Contents Functions legendre_fp64 Functions public pure elemental function legendre_fp64(n, x) result(leg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp)","tags":"","loc":"interface/legendre.html"},{"title":"bits – Fortran-lang/stdlib","text":"public elemental function bits(self) Returns the number of bit positions in self . Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) Contents Source Code bits Source Code elemental function bits ( self ) !! Version: experimental !! !! Returns the number of bit positions in `self`. integer ( bits_kind ) :: bits class ( bitset_type ), intent ( in ) :: self bits = self % num_bits return end function bits","tags":"","loc":"proc/bits.html"},{"title":"error_handler – Fortran-lang/stdlib","text":"public subroutine error_handler(message, error, status, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: error integer, intent(out), optional :: status character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Contents Source Code error_handler Source Code module subroutine error_handler ( message , error , status , & module , procedure ) character ( * ), intent ( in ) :: message integer , intent ( in ) :: error integer , intent ( out ), optional :: status character ( * ), intent ( in ), optional :: module character ( * ), intent ( in ), optional :: procedure end subroutine error_handler","tags":"","loc":"proc/error_handler.html"},{"title":"and – Fortran-lang/stdlib","text":"public interface and Sets the bits in set1 to the bitwise and of the original bits in set1 and set2 . The sets must have the same number of bits\n otherwise the result is undefined.\n ( Specification ) Example program demo_and use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call and ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of AND worked.' call set0 % not () call and ( set0 , set1 ) ! all none if ( none ( set0 ) ) write ( * , * ) 'Second test of AND worked.' call set1 % not () call and ( set0 , set1 ) ! none all if ( none ( set0 ) ) write ( * , * ) 'Third test of AND worked.' call set0 % not () call and ( set0 , set1 ) ! all all if ( all ( set0 ) ) write ( * , * ) 'Fourth test of AND worked.' end program demo_and Contents Subroutines and_64 and_large Subroutines public elemental subroutine and_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine and_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2","tags":"","loc":"interface/and.html"},{"title":"and_not – Fortran-lang/stdlib","text":"public interface and_not Sets the bits in set1 to the bitwise and of the original bits in set1 with the bitwise negation of set2 . The sets must have the same\n number of bits otherwise the result is undefined. ( Specification ) Example program demo_and_not use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call and_not ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of AND_NOT worked.' call set0 % not () call and_not ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of AND_NOT worked.' call set0 % not () call set1 % not () call and_not ( set0 , set1 ) ! none all if ( none ( set0 ) ) write ( * , * ) 'Third test of AND_NOT worked.' call set0 % not () call and_not ( set0 , set1 ) ! all all if ( none ( set0 ) ) write ( * , * ) 'Fourth test of AND_NOT worked.' end program demo_and_not Contents Subroutines and_not_64 and_not_large Subroutines public elemental subroutine and_not_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine and_not_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2","tags":"","loc":"interface/and_not.html"},{"title":"assignment(=) – Fortran-lang/stdlib","text":"public interface assignment(=) Used to define assignment for bitset_large .\n ( Specification ) Example program demo_assignment use stdlib_bitsets logical ( int8 ) :: logical1 ( 64 ) = . true . logical ( int32 ), allocatable :: logical2 (:) type ( bitset_64 ) :: set0 , set1 set0 = logical1 if ( set0 % bits () /= 64 ) then error stop procedure // & ' initialization with logical(int8) failed to set' // & ' the right size.' else if ( . not . set0 % all () ) then error stop procedure // ' initialization with' // & ' logical(int8) failed to set the right values.' else write ( * , * ) 'Initialization with logical(int8) succeeded.' end if set1 = set0 if ( set1 == set0 ) & write ( * , * ) 'Initialization by assignment succeeded' logical2 = set1 if ( all ( logical2 ) ) then write ( * , * ) 'Initialization of logical(int32) succeeded.' end if end program demo_assignment Contents Subroutines assign_large assign_logint16_large assign_logint32_large assign_logint64_large assign_logint8_large logint16_assign_large logint32_assign_large logint64_assign_large logint8_assign_large Subroutines public pure subroutine assign_large(set1, set2) Used to define assignment for bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: set1 type( bitset_large ), intent(in) :: set2 public pure subroutine assign_logint16_large(self, logical_vector) Used to define assignment from an array of type logical(int16) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int16), intent(in) :: logical_vector (:) public pure subroutine assign_logint32_large(self, logical_vector) Used to define assignment from an array of type logical(int32) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int32), intent(in) :: logical_vector (:) public pure subroutine assign_logint64_large(self, logical_vector) Used to define assignment from an array of type logical(int64) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int64), intent(in) :: logical_vector (:) public pure subroutine assign_logint8_large(self, logical_vector) Used to define assignment from an array of type logical(int8) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int8), intent(in) :: logical_vector (:) public pure subroutine logint16_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int16) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int16), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint32_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int32) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int32), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint64_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int64) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int64), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint8_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int8) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int8), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set","tags":"","loc":"interface/assignment(=).html"},{"title":"extract – Fortran-lang/stdlib","text":"public interface extract Creates a new bitset, new , from a range, start_pos to stop_pos , in\n bitset old . If start_pos is greater than stop_pos the new bitset is\n empty. If start_pos is less than zero or stop_pos is greater than bits(old)-1 then if status is present it has the value index_invalid_error and new is undefined, otherwise processing stops\n with an informative message.\n ( Specification ) Example program demo_extract use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set0 % set ( 100 , 150 ) call extract ( set1 , set0 , 100 , 150 ) if ( set1 % bits () == 51 ) & write ( * , * ) 'SET1 has the proper size.' if ( set1 % all () ) write ( * , * ) 'SET1 has the proper values.' end program demo_extract Contents Subroutines extract_64 extract_large Subroutines public subroutine extract_64(new, old, start_pos, stop_pos, status) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(out) :: new type( bitset_64 ), intent(in) :: old integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos integer, intent(out), optional :: status public subroutine extract_large(new, old, start_pos, stop_pos, status) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: new type( bitset_large ), intent(in) :: old integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos integer, intent(out), optional :: status","tags":"","loc":"interface/extract.html"},{"title":"operator(/=) – Fortran-lang/stdlib","text":"public interface operator(/=) Returns .true. if not all bits in set1 and set2 have the same value, .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_inequality use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 /= set1 . and . set0 /= set2 . and . set1 /= set2 . and . & . not . set0 /= set0 . and . . not . set1 /= set1 . and . . not . & set2 /= set2 ) then write ( * , * ) 'Passed 64 bit inequality tests.' else error stop 'Failed 64 bit inequality tests.' end if end program demo_inequality Contents Functions neqv_64 neqv_large Functions public elemental function neqv_64(set1, set2) result(neqv) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function neqv_large(set1, set2) result(neqv) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(SLASH=)~2.html"},{"title":"operator(<) – Fortran-lang/stdlib","text":"public interface operator(<) Returns .true. if the bits in set1 and set2 differ and the\n highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_lt use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 < set1 . and . set1 < set2 . and . set0 < set2 . and . & . not . set0 < set0 . and . . not . set2 < set0 . and . . not . & set2 < set1 ) then write ( * , * ) 'Passed 64 bit less than tests.' else error stop 'Failed 64 bit less than tests.' end if end program demo_lt Contents Functions lt_64 lt_large Functions public elemental function lt_64(set1, set2) result(lt) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function lt_large(set1, set2) result(lt) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(lt)~2.html"},{"title":"operator(<=) – Fortran-lang/stdlib","text":"public interface operator(<=) Returns .true. if the bits in set1 and set2 are the same or the\n highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_le use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 <= set1 . and . set1 <= set2 . and . set0 <= set2 . and . & set0 <= set0 . and . set1 <= set1 . and . set2 <= set2 . and . & . not . set1 <= set0 . and . . not . set2 <= set0 . and . . not . & set2 <= set1 ) then write ( * , * ) 'Passed 64 bit less than or equal tests.' else error stop 'Failed 64 bit less than or equal tests.' end if end program demo_le Contents Functions le_64 le_large Functions public elemental function le_64(set1, set2) result(le) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function le_large(set1, set2) result(le) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(lt=)~2.html"},{"title":"operator(==) – Fortran-lang/stdlib","text":"public interface operator(==) Returns .true. if all bits in set1 and set2 have the same value, .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_equality use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 == set0 . and . set1 == set1 . and . set2 == set2 . and . & . not . set0 == set1 . and . . not . set0 == set2 . and . . not . & set1 == set2 ) then write ( * , * ) 'Passed 64 bit equality tests.' else error stop 'Failed 64 bit equality tests.' end if end program demo_equality Contents Functions eqv_64 eqv_large Functions public elemental function eqv_64(set1, set2) result(eqv) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function eqv_large(set1, set2) result(eqv) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(==)~2.html"},{"title":"operator(>) – Fortran-lang/stdlib","text":"public interface operator(>) Returns .true. if the bits in set1 and set2 differ and the\n highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_gt use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set1 > set0 . and . set2 > set1 . and . set2 > set0 . and . & . not . set0 > set0 . and . . not . set0 > set1 . and . . not . & set1 > set2 ) then write ( * , * ) 'Passed 64 bit greater than tests.' else error stop 'Failed 64 bit greater than tests.' end if end program demo_gt Contents Functions gt_64 gt_large Functions public elemental function gt_64(set1, set2) result(gt) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function gt_large(set1, set2) result(gt) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(gt)~2.html"},{"title":"operator(>=) – Fortran-lang/stdlib","text":"public interface operator(>=) Returns .true. if the bits in set1 and set2 are the same or the\n highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n ( Specification ) Example program demo_ge use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set1 >= set0 . and . set2 >= set1 . and . set2 >= set0 . and . & set0 >= set0 . and . set1 >= set1 . and . set2 >= set2 . and . & . not . set0 >= set1 . and . . not . set0 >= set2 . and . . not . & set1 >= set2 ) then write ( * , * ) 'Passed 64 bit greater than or equals tests.' else error stop 'Failed 64 bit greater than or equals tests.' end if end program demo_ge Contents Functions ge_64 ge_large Functions public elemental function ge_64(set1, set2) result(ge) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function ge_large(set1, set2) result(ge) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical","tags":"","loc":"interface/operator(gt=)~2.html"},{"title":"or – Fortran-lang/stdlib","text":"public interface or Sets the bits in set1 to the bitwise or of the original bits in set1 and set2 . The sets must have the same number of bits otherwise\n the result is undefined.\n ( Specification ) Example program demo_or use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call or ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of OR worked.' call set0 % not () call or ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of OR worked.' call set0 % not () call set1 % not () call or ( set0 , set1 ) ! none all if ( all ( set0 ) ) write ( * , * ) 'Third test of OR worked.' call set0 % not () call or ( set0 , set1 ) ! all all if ( all ( set0 ) ) write ( * , * ) 'Fourth test of OR worked.' end program demo_or Contents Subroutines or_64 or_large Subroutines public elemental subroutine or_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine or_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2","tags":"","loc":"interface/or.html"},{"title":"xor – Fortran-lang/stdlib","text":"public interface xor Sets the bits in set1 to the bitwise xor of the original bits in set1 and set2 . The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Example program demo_xor use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call xor ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of XOR worked.' call set0 % not () call xor ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of XOR worked.' call set0 % not () call set1 % not () call xor ( set0 , set1 ) ! none all if ( all ( set0 ) ) write ( * , * ) 'Third test of XOR worked.' call set0 % not () call xor ( set0 , set1 ) ! all all if ( none ( set0 ) ) write ( * , * ) 'Fourth test of XOR worked.' end program demo_xor Contents Subroutines xor_64 xor_large Subroutines public elemental subroutine xor_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine xor_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2","tags":"","loc":"interface/xor.html"},{"title":"optval – Fortran-lang/stdlib","text":"public interface optval Fallback value for optional arguments\n ( Specification ) Called by interface~~optval~~CalledByGraph interface~optval optval proc~check check proc~check->interface~optval proc~open open proc~open->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures optval_rsp optval_rdp optval_rqp optval_iint8 optval_iint16 optval_iint32 optval_iint64 optval_csp optval_cdp optval_cqp optval_ll1 optval_character Module Procedures private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/optval.html"},{"title":"is_alpha – Fortran-lang/stdlib","text":"public pure function is_alpha(c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_alpha.html"},{"title":"is_alphanum – Fortran-lang/stdlib","text":"public pure function is_alphanum(c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_alphanum~~CalledByGraph proc~is_alphanum is_alphanum proc~to_sentence to_sentence proc~to_sentence->proc~is_alphanum proc~is_punctuation is_punctuation proc~is_punctuation->proc~is_alphanum proc~to_title to_title proc~to_title->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_alphanum.html"},{"title":"is_ascii – Fortran-lang/stdlib","text":"public pure function is_ascii(c) Checks whether or not c is in the ASCII character set -\n i.e. in the range 0 .. 0x7F. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_ascii.html"},{"title":"is_blank – Fortran-lang/stdlib","text":"public pure function is_blank(c) Checks whether or not c is a blank character. That includes the\n only the space and tab characters Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_blank.html"},{"title":"is_control – Fortran-lang/stdlib","text":"public pure function is_control(c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_control.html"},{"title":"is_digit – Fortran-lang/stdlib","text":"public pure function is_digit(c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_digit.html"},{"title":"is_graphical – Fortran-lang/stdlib","text":"public pure function is_graphical(c) Checks whether or not c is a printable character other than the\n space character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_graphical.html"},{"title":"is_hex_digit – Fortran-lang/stdlib","text":"public pure function is_hex_digit(c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_hex_digit.html"},{"title":"is_lower – Fortran-lang/stdlib","text":"public pure function is_lower(c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_lower.html"},{"title":"is_octal_digit – Fortran-lang/stdlib","text":"public pure function is_octal_digit(c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_octal_digit.html"},{"title":"is_printable – Fortran-lang/stdlib","text":"public pure function is_printable(c) Checks whether or not c is a printable character - including the\n space character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_printable.html"},{"title":"is_punctuation – Fortran-lang/stdlib","text":"public pure function is_punctuation(c) Checks whether or not c is a punctuation character. That includes\n all ASCII characters which are not control characters, letters,\n digits, or whitespace. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Calls proc~~is_punctuation~~CallsGraph proc~is_punctuation is_punctuation proc~is_alphanum is_alphanum proc~is_punctuation->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_punctuation.html"},{"title":"is_upper – Fortran-lang/stdlib","text":"public pure function is_upper(c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_upper.html"},{"title":"is_white – Fortran-lang/stdlib","text":"public pure function is_white(c) Checks whether or not c is a whitespace character. That includes the\n space, tab, vertical tab, form feed, carriage return, and linefeed\n characters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_white.html"},{"title":"reverse – Fortran-lang/stdlib","text":"public pure function reverse(string) result(reverse_string) Reverse the character order in the input character variable\n ( Specification ) Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Contents Variables i n Source Code reverse Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n Source Code pure function reverse ( string ) result ( reverse_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: reverse_string integer :: i , n n = len ( string ) do i = 1 , n reverse_string ( n - i + 1 : n - i + 1 ) = string ( i : i ) end do end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"to_lower – Fortran-lang/stdlib","text":"public pure function to_lower(string) result(lower_string) Convert character variable to lower case\n ( Specification ) Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Contents Variables i Source Code to_lower Variables Type Visibility Attributes Name Initial integer, public :: i Source Code pure function to_lower ( string ) result ( lower_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lower_string integer :: i do i = 1 , len ( string ) lower_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_lower","tags":"","loc":"proc/to_lower.html"},{"title":"to_sentence – Fortran-lang/stdlib","text":"public pure function to_sentence(string) result(sentence_string) Converts character sequence to sentence case\n ( Specification ) Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Calls proc~~to_sentence~~CallsGraph proc~to_sentence to_sentence proc~is_alphanum is_alphanum proc~to_sentence->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i n Source Code to_sentence Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n Source Code pure function to_sentence ( string ) result ( sentence_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: sentence_string integer :: i , n n = len ( string ) do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then sentence_string ( i : i ) = char_to_upper ( string ( i : i )) n = i exit else sentence_string ( i : i ) = string ( i : i ) end if end do do i = n + 1 , len ( string ) sentence_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_sentence","tags":"","loc":"proc/to_sentence.html"},{"title":"to_title – Fortran-lang/stdlib","text":"public pure function to_title(string) result(title_string) Converts character sequence to title case\n ( Specification ) Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Calls proc~~to_title~~CallsGraph proc~to_title to_title proc~is_alphanum is_alphanum proc~to_title->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables capitalize_switch i Source Code to_title Variables Type Visibility Attributes Name Initial logical, public :: capitalize_switch integer, public :: i Source Code pure function to_title ( string ) result ( title_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: title_string integer :: i logical :: capitalize_switch capitalize_switch = . true . do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then if ( capitalize_switch ) then title_string ( i : i ) = char_to_upper ( string ( i : i )) capitalize_switch = . false . else title_string ( i : i ) = char_to_lower ( string ( i : i )) end if else title_string ( i : i ) = string ( i : i ) capitalize_switch = . true . end if end do end function to_title","tags":"","loc":"proc/to_title.html"},{"title":"to_upper – Fortran-lang/stdlib","text":"public pure function to_upper(string) result(upper_string) Convert character variable to upper case\n ( Specification ) Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Contents Variables i Source Code to_upper Variables Type Visibility Attributes Name Initial integer, public :: i Source Code pure function to_upper ( string ) result ( upper_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: upper_string integer :: i do i = 1 , len ( string ) upper_string ( i : i ) = char_to_upper ( string ( i : i )) end do end function to_upper","tags":"","loc":"proc/to_upper.html"},{"title":"to_string – Fortran-lang/stdlib","text":"public interface to_string Create a character string representing the value of the provided variable. Contents Module Procedures to_string_integer_int8 to_string_integer_int16 to_string_integer_int32 to_string_integer_int64 to_string_logical_lk to_string_logical_c_bool Module Procedures private pure function to_string_integer_int8(val) result(string) Represent an integer of kind int8 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int16(val) result(string) Represent an integer of kind int16 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int32(val) result(string) Represent an integer of kind int32 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int64(val) result(string) Represent an integer of kind int64 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_logical_lk(val) result(string) Represent an logical of kind lk as character sequence Arguments Type Intent Optional Attributes Name logical(kind=ik), intent(in) :: val Return Value character(len=1) private pure function to_string_logical_c_bool(val) result(string) Represent an logical of kind c_bool as character sequence Arguments Type Intent Optional Attributes Name logical(kind=ik), intent(in) :: val Return Value character(len=1)","tags":"","loc":"interface/to_string.html"},{"title":"chomp – Fortran-lang/stdlib","text":"public interface chomp Remove trailing characters in set from string.\n If no character set is provided trailing whitespace is removed. Version: experimental Contents Module Procedures chomp_string chomp_char chomp_set_string_char chomp_set_char_char chomp_substring_string_string chomp_substring_char_string chomp_substring_string_char chomp_substring_char_char Module Procedures private pure function chomp_string(string) result(chomped_string) Remove trailing characters in set from string.\n Default character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function chomp_char(string) result(chomped_string) Remove trailing characters in set from string.\n Default character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable private pure function chomp_set_string_char(string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) private pure function chomp_set_char_char(string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:),\n  allocatable private pure function chomp_substring_string_string(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_string(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:),\n  allocatable private pure function chomp_substring_string_char(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_char(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/chomp.html"},{"title":"count – Fortran-lang/stdlib","text":"public interface count Returns the number of times substring 'pattern' has appeared in the\n input string 'string' Specifications Contents Module Procedures count_string_string count_string_char count_char_string count_char_char Module Procedures private elemental function count_string_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer","tags":"","loc":"interface/count.html"},{"title":"ends_with – Fortran-lang/stdlib","text":"public interface ends_with Check whether a string ends with substring or not Version: experimental Contents Module Procedures ends_with_string_string ends_with_string_char ends_with_char_string ends_with_char_char Module Procedures private elemental function ends_with_string_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function ends_with_string_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_char_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function ends_with_char_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical","tags":"","loc":"interface/ends_with.html"},{"title":"find – Fortran-lang/stdlib","text":"public interface find Finds the starting index of substring 'pattern' in the input 'string' Specifications Version: experimental Contents Module Procedures find_string_string find_string_char find_char_string find_char_char Module Procedures private elemental function find_string_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer","tags":"","loc":"interface/find.html"},{"title":"padl – Fortran-lang/stdlib","text":"public interface padl Left pad the input string Specifications Contents Module Procedures padl_string_default padl_string_pad_with padl_char_default padl_char_pad_with Module Procedures private pure function padl_string_default(string, output_length) result(res) Left pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padl_string_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padl_char_default(string, output_length) result(res) Left pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(len=max(len(string),output_length)) private pure function padl_char_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(len=max(len(string),output_length))","tags":"","loc":"interface/padl.html"},{"title":"padr – Fortran-lang/stdlib","text":"public interface padr Right pad the input string Specifications Contents Module Procedures padr_string_default padr_string_pad_with padr_char_default padr_char_pad_with Module Procedures private pure function padr_string_default(string, output_length) result(res) Right pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padr_string_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padr_char_default(string, output_length) result(res) Right pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(len=max(len(string),output_length)) private pure function padr_char_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(len=max(len(string),output_length))","tags":"","loc":"interface/padr.html"},{"title":"replace_all – Fortran-lang/stdlib","text":"public interface replace_all Replaces all the occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Version: experimental Contents Module Procedures replace_all_string_string_string replace_all_string_string_char replace_all_string_char_string replace_all_char_string_string replace_all_string_char_char replace_all_char_string_char replace_all_char_char_string replace_all_char_char_char Module Procedures private pure function replace_all_string_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_string_char_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_char_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_char_char_char(string, pattern, replacement) result(res) Replaces all the occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/replace_all.html"},{"title":"slice – Fortran-lang/stdlib","text":"public interface slice Extracts characters from the input string to return a new string Version: experimental Contents Module Procedures slice_string slice_char Module Procedures private elemental function slice_string(string, first, last, stride) result(sliced_string) Extract the characters from the region between 'first' and 'last' index (both inclusive)\n of the input 'string' by taking strides of length 'stride'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) private pure function slice_char(string, first, last, stride) result(sliced_string) Extract the characters from the region between 'first' and 'last' index (both inclusive)\n of the input 'string' by taking strides of length 'stride'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/slice.html"},{"title":"starts_with – Fortran-lang/stdlib","text":"public interface starts_with Check whether a string starts with substring or not Version: experimental Contents Module Procedures starts_with_string_string starts_with_string_char starts_with_char_string starts_with_char_char Module Procedures private elemental function starts_with_string_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function starts_with_string_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_char_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function starts_with_char_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical","tags":"","loc":"interface/starts_with.html"},{"title":"strip – Fortran-lang/stdlib","text":"public interface strip Remove leading and trailing whitespace characters. Version: experimental Contents Module Procedures strip_string strip_char Module Procedures private pure function strip_string(string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function strip_char(string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/strip.html"},{"title":"corr – Fortran-lang/stdlib","text":"public interface corr Pearson correlation of array elements\n ( Specification ) Contents Functions corr_1_cdp_cdp corr_1_cqp_cqp corr_1_csp_csp corr_1_iint16_dp corr_1_iint32_dp corr_1_iint64_dp corr_1_iint8_dp corr_1_rdp_rdp corr_1_rqp_rqp corr_1_rsp_rsp corr_2_cdp_cdp corr_2_cqp_cqp corr_2_csp_csp corr_2_iint16_dp corr_2_iint32_dp corr_2_iint64_dp corr_2_iint8_dp corr_2_rdp_rdp corr_2_rqp_rqp corr_2_rsp_rsp corr_mask_1_cdp_cdp corr_mask_1_cqp_cqp corr_mask_1_csp_csp corr_mask_1_iint16_dp corr_mask_1_iint32_dp corr_mask_1_iint64_dp corr_mask_1_iint8_dp corr_mask_1_rdp_rdp corr_mask_1_rqp_rqp corr_mask_1_rsp_rsp corr_mask_2_cdp_cdp corr_mask_2_cqp_cqp corr_mask_2_csp_csp corr_mask_2_iint16_dp corr_mask_2_iint32_dp corr_mask_2_iint64_dp corr_mask_2_iint8_dp corr_mask_2_rdp_rdp corr_mask_2_rqp_rqp corr_mask_2_rsp_rsp Functions public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/corr.html"},{"title":"cov – Fortran-lang/stdlib","text":"public interface cov Covariance of array elements\n ( Specification ) Contents Functions cov_1_cdp_cdp cov_1_cqp_cqp cov_1_csp_csp cov_1_iint16_dp cov_1_iint32_dp cov_1_iint64_dp cov_1_iint8_dp cov_1_rdp_rdp cov_1_rqp_rqp cov_1_rsp_rsp cov_2_cdp_cdp cov_2_cqp_cqp cov_2_csp_csp cov_2_iint16_dp cov_2_iint32_dp cov_2_iint64_dp cov_2_iint8_dp cov_2_rdp_rdp cov_2_rqp_rqp cov_2_rsp_rsp cov_mask_1_cdp_cdp cov_mask_1_cqp_cqp cov_mask_1_csp_csp cov_mask_1_iint16_dp cov_mask_1_iint32_dp cov_mask_1_iint64_dp cov_mask_1_iint8_dp cov_mask_1_rdp_rdp cov_mask_1_rqp_rqp cov_mask_1_rsp_rsp cov_mask_2_cdp_cdp cov_mask_2_cqp_cqp cov_mask_2_csp_csp cov_mask_2_iint16_dp cov_mask_2_iint32_dp cov_mask_2_iint64_dp cov_mask_2_iint8_dp cov_mask_2_rdp_rdp cov_mask_2_rqp_rqp cov_mask_2_rsp_rsp Functions public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/cov.html"},{"title":"mean – Fortran-lang/stdlib","text":"public interface mean Mean of array elements\n ( Specification ) Contents Functions mean_1_cdp_cdp mean_1_cqp_cqp mean_1_csp_csp mean_1_iint16_dp mean_1_iint32_dp mean_1_iint64_dp mean_1_iint8_dp mean_1_rdp_rdp mean_1_rqp_rqp mean_1_rsp_rsp mean_2_cdp_cdp mean_2_cqp_cqp mean_2_csp_csp mean_2_iint16_dp mean_2_iint32_dp mean_2_iint64_dp mean_2_iint8_dp mean_2_rdp_rdp mean_2_rqp_rqp mean_2_rsp_rsp mean_3_cdp_cdp mean_3_cqp_cqp mean_3_csp_csp mean_3_iint16_dp mean_3_iint32_dp mean_3_iint64_dp mean_3_iint8_dp mean_3_rdp_rdp mean_3_rqp_rqp mean_3_rsp_rsp mean_all_1_cdp_cdp mean_all_1_cqp_cqp mean_all_1_csp_csp mean_all_1_iint16_dp mean_all_1_iint32_dp mean_all_1_iint64_dp mean_all_1_iint8_dp mean_all_1_rdp_rdp mean_all_1_rqp_rqp mean_all_1_rsp_rsp mean_all_2_cdp_cdp mean_all_2_cqp_cqp mean_all_2_csp_csp mean_all_2_iint16_dp mean_all_2_iint32_dp mean_all_2_iint64_dp mean_all_2_iint8_dp mean_all_2_rdp_rdp mean_all_2_rqp_rqp mean_all_2_rsp_rsp mean_all_3_cdp_cdp mean_all_3_cqp_cqp mean_all_3_csp_csp mean_all_3_iint16_dp mean_all_3_iint32_dp mean_all_3_iint64_dp mean_all_3_iint8_dp mean_all_3_rdp_rdp mean_all_3_rqp_rqp mean_all_3_rsp_rsp mean_mask_1_cdp_cdp mean_mask_1_cqp_cqp mean_mask_1_csp_csp mean_mask_1_iint16_dp mean_mask_1_iint32_dp mean_mask_1_iint64_dp mean_mask_1_iint8_dp mean_mask_1_rdp_rdp mean_mask_1_rqp_rqp mean_mask_1_rsp_rsp mean_mask_2_cdp_cdp mean_mask_2_cqp_cqp mean_mask_2_csp_csp mean_mask_2_iint16_dp mean_mask_2_iint32_dp mean_mask_2_iint64_dp mean_mask_2_iint8_dp mean_mask_2_rdp_rdp mean_mask_2_rqp_rqp mean_mask_2_rsp_rsp mean_mask_3_cdp_cdp mean_mask_3_cqp_cqp mean_mask_3_csp_csp mean_mask_3_iint16_dp mean_mask_3_iint32_dp mean_mask_3_iint64_dp mean_mask_3_iint8_dp mean_mask_3_rdp_rdp mean_mask_3_rqp_rqp mean_mask_3_rsp_rsp mean_mask_all_1_cdp_cdp mean_mask_all_1_cqp_cqp mean_mask_all_1_csp_csp mean_mask_all_1_iint16_dp mean_mask_all_1_iint32_dp mean_mask_all_1_iint64_dp mean_mask_all_1_iint8_dp mean_mask_all_1_rdp_rdp mean_mask_all_1_rqp_rqp mean_mask_all_1_rsp_rsp mean_mask_all_2_cdp_cdp mean_mask_all_2_cqp_cqp mean_mask_all_2_csp_csp mean_mask_all_2_iint16_dp mean_mask_all_2_iint32_dp mean_mask_all_2_iint64_dp mean_mask_all_2_iint8_dp mean_mask_all_2_rdp_rdp mean_mask_all_2_rqp_rqp mean_mask_all_2_rsp_rsp mean_mask_all_3_cdp_cdp mean_mask_all_3_cqp_cqp mean_mask_all_3_csp_csp mean_mask_all_3_iint16_dp mean_mask_all_3_iint32_dp mean_mask_all_3_iint64_dp mean_mask_all_3_iint8_dp mean_mask_all_3_rdp_rdp mean_mask_all_3_rqp_rqp mean_mask_all_3_rsp_rsp Functions public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)","tags":"","loc":"interface/mean.html"},{"title":"moment – Fortran-lang/stdlib","text":"public interface moment Central moment of array elements\n ( Specification ) Contents Functions moment_1_cdp_cdp moment_1_cqp_cqp moment_1_csp_csp moment_1_iint16_dp moment_1_iint32_dp moment_1_iint64_dp moment_1_iint8_dp moment_1_rdp_rdp moment_1_rqp_rqp moment_1_rsp_rsp moment_2_cdp_cdp moment_2_cqp_cqp moment_2_csp_csp moment_2_iint16_dp moment_2_iint32_dp moment_2_iint64_dp moment_2_iint8_dp moment_2_rdp_rdp moment_2_rqp_rqp moment_2_rsp_rsp moment_3_cdp_cdp moment_3_cqp_cqp moment_3_csp_csp moment_3_iint16_dp moment_3_iint32_dp moment_3_iint64_dp moment_3_iint8_dp moment_3_rdp_rdp moment_3_rqp_rqp moment_3_rsp_rsp moment_all_1_cdp_cdp moment_all_1_cqp_cqp moment_all_1_csp_csp moment_all_1_iint16_dp moment_all_1_iint32_dp moment_all_1_iint64_dp moment_all_1_iint8_dp moment_all_1_rdp_rdp moment_all_1_rqp_rqp moment_all_1_rsp_rsp moment_all_2_cdp_cdp moment_all_2_cqp_cqp moment_all_2_csp_csp moment_all_2_iint16_dp moment_all_2_iint32_dp moment_all_2_iint64_dp moment_all_2_iint8_dp moment_all_2_rdp_rdp moment_all_2_rqp_rqp moment_all_2_rsp_rsp moment_all_3_cdp_cdp moment_all_3_cqp_cqp moment_all_3_csp_csp moment_all_3_iint16_dp moment_all_3_iint32_dp moment_all_3_iint64_dp moment_all_3_iint8_dp moment_all_3_rdp_rdp moment_all_3_rqp_rqp moment_all_3_rsp_rsp moment_mask_1_cdp_cdp moment_mask_1_cqp_cqp moment_mask_1_csp_csp moment_mask_1_iint16_dp moment_mask_1_iint32_dp moment_mask_1_iint64_dp moment_mask_1_iint8_dp moment_mask_1_rdp_rdp moment_mask_1_rqp_rqp moment_mask_1_rsp_rsp moment_mask_2_cdp_cdp moment_mask_2_cqp_cqp moment_mask_2_csp_csp moment_mask_2_iint16_dp moment_mask_2_iint32_dp moment_mask_2_iint64_dp moment_mask_2_iint8_dp moment_mask_2_rdp_rdp moment_mask_2_rqp_rqp moment_mask_2_rsp_rsp moment_mask_3_cdp_cdp moment_mask_3_cqp_cqp moment_mask_3_csp_csp moment_mask_3_iint16_dp moment_mask_3_iint32_dp moment_mask_3_iint64_dp moment_mask_3_iint8_dp moment_mask_3_rdp_rdp moment_mask_3_rqp_rqp moment_mask_3_rsp_rsp moment_mask_all_1_cdp_cdp moment_mask_all_1_cqp_cqp moment_mask_all_1_csp_csp moment_mask_all_1_iint16_dp moment_mask_all_1_iint32_dp moment_mask_all_1_iint64_dp moment_mask_all_1_iint8_dp moment_mask_all_1_rdp_rdp moment_mask_all_1_rqp_rqp moment_mask_all_1_rsp_rsp moment_mask_all_2_cdp_cdp moment_mask_all_2_cqp_cqp moment_mask_all_2_csp_csp moment_mask_all_2_iint16_dp moment_mask_all_2_iint32_dp moment_mask_all_2_iint64_dp moment_mask_all_2_iint8_dp moment_mask_all_2_rdp_rdp moment_mask_all_2_rqp_rqp moment_mask_all_2_rsp_rsp moment_mask_all_3_cdp_cdp moment_mask_all_3_cqp_cqp moment_mask_all_3_csp_csp moment_mask_all_3_iint16_dp moment_mask_all_3_iint32_dp moment_mask_all_3_iint64_dp moment_mask_all_3_iint8_dp moment_mask_all_3_rdp_rdp moment_mask_all_3_rqp_rqp moment_mask_all_3_rsp_rsp moment_mask_scalar_2_cdp_cdp moment_mask_scalar_2_cqp_cqp moment_mask_scalar_2_csp_csp moment_mask_scalar_2_iint16_dp moment_mask_scalar_2_iint32_dp moment_mask_scalar_2_iint64_dp moment_mask_scalar_2_iint8_dp moment_mask_scalar_2_rdp_rdp moment_mask_scalar_2_rqp_rqp moment_mask_scalar_2_rsp_rsp moment_mask_scalar_3_cdp_cdp moment_mask_scalar_3_cqp_cqp moment_mask_scalar_3_csp_csp moment_mask_scalar_3_iint16_dp moment_mask_scalar_3_iint32_dp moment_mask_scalar_3_iint64_dp moment_mask_scalar_3_iint8_dp moment_mask_scalar_3_rdp_rdp moment_mask_scalar_3_rqp_rqp moment_mask_scalar_3_rsp_rsp moment_scalar_2_cdp_cdp moment_scalar_2_cqp_cqp moment_scalar_2_csp_csp moment_scalar_2_iint16_dp moment_scalar_2_iint32_dp moment_scalar_2_iint64_dp moment_scalar_2_iint8_dp moment_scalar_2_rdp_rdp moment_scalar_2_rqp_rqp moment_scalar_2_rsp_rsp moment_scalar_3_cdp_cdp moment_scalar_3_cqp_cqp moment_scalar_3_csp_csp moment_scalar_3_iint16_dp moment_scalar_3_iint32_dp moment_scalar_3_iint64_dp moment_scalar_3_iint8_dp moment_scalar_3_rdp_rdp moment_scalar_3_rqp_rqp moment_scalar_3_rsp_rsp Functions public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/moment.html"},{"title":"var – Fortran-lang/stdlib","text":"public interface var Variance of array elements\n ( Specification ) Contents Functions var_1_cdp_cdp var_1_cqp_cqp var_1_csp_csp var_1_iint16_dp var_1_iint32_dp var_1_iint64_dp var_1_iint8_dp var_1_rdp_rdp var_1_rqp_rqp var_1_rsp_rsp var_2_cdp_cdp var_2_cqp_cqp var_2_csp_csp var_2_iint16_dp var_2_iint32_dp var_2_iint64_dp var_2_iint8_dp var_2_rdp_rdp var_2_rqp_rqp var_2_rsp_rsp var_3_cdp_cdp var_3_cqp_cqp var_3_csp_csp var_3_iint16_dp var_3_iint32_dp var_3_iint64_dp var_3_iint8_dp var_3_rdp_rdp var_3_rqp_rqp var_3_rsp_rsp var_all_1_cdp_cdp var_all_1_cqp_cqp var_all_1_csp_csp var_all_1_iint16_dp var_all_1_iint32_dp var_all_1_iint64_dp var_all_1_iint8_dp var_all_1_rdp_rdp var_all_1_rqp_rqp var_all_1_rsp_rsp var_all_2_cdp_cdp var_all_2_cqp_cqp var_all_2_csp_csp var_all_2_iint16_dp var_all_2_iint32_dp var_all_2_iint64_dp var_all_2_iint8_dp var_all_2_rdp_rdp var_all_2_rqp_rqp var_all_2_rsp_rsp var_all_3_cdp_cdp var_all_3_cqp_cqp var_all_3_csp_csp var_all_3_iint16_dp var_all_3_iint32_dp var_all_3_iint64_dp var_all_3_iint8_dp var_all_3_rdp_rdp var_all_3_rqp_rqp var_all_3_rsp_rsp var_mask_1_cdp_cdp var_mask_1_cqp_cqp var_mask_1_csp_csp var_mask_1_iint16_dp var_mask_1_iint32_dp var_mask_1_iint64_dp var_mask_1_iint8_dp var_mask_1_rdp_rdp var_mask_1_rqp_rqp var_mask_1_rsp_rsp var_mask_2_cdp_cdp var_mask_2_cqp_cqp var_mask_2_csp_csp var_mask_2_iint16_dp var_mask_2_iint32_dp var_mask_2_iint64_dp var_mask_2_iint8_dp var_mask_2_rdp_rdp var_mask_2_rqp_rqp var_mask_2_rsp_rsp var_mask_3_cdp_cdp var_mask_3_cqp_cqp var_mask_3_csp_csp var_mask_3_iint16_dp var_mask_3_iint32_dp var_mask_3_iint64_dp var_mask_3_iint8_dp var_mask_3_rdp_rdp var_mask_3_rqp_rqp var_mask_3_rsp_rsp var_mask_all_1_cdp_cdp var_mask_all_1_cqp_cqp var_mask_all_1_csp_csp var_mask_all_1_iint16_dp var_mask_all_1_iint32_dp var_mask_all_1_iint64_dp var_mask_all_1_iint8_dp var_mask_all_1_rdp_rdp var_mask_all_1_rqp_rqp var_mask_all_1_rsp_rsp var_mask_all_2_cdp_cdp var_mask_all_2_cqp_cqp var_mask_all_2_csp_csp var_mask_all_2_iint16_dp var_mask_all_2_iint32_dp var_mask_all_2_iint64_dp var_mask_all_2_iint8_dp var_mask_all_2_rdp_rdp var_mask_all_2_rqp_rqp var_mask_all_2_rsp_rsp var_mask_all_3_cdp_cdp var_mask_all_3_cqp_cqp var_mask_all_3_csp_csp var_mask_all_3_iint16_dp var_mask_all_3_iint32_dp var_mask_all_3_iint64_dp var_mask_all_3_iint8_dp var_mask_all_3_rdp_rdp var_mask_all_3_rqp_rqp var_mask_all_3_rsp_rsp Functions public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"interface/var.html"},{"title":"open – Fortran-lang/stdlib","text":"public function open(filename, mode, iostat) result(u) Opens a file\n ( Specification ) Behavior To open a file to read: u = open ( \"somefile.txt\" ) ! The default `mode` is \"rt\" u = open ( \"somefile.txt\" , \"r\" ) To open a file to write: u = open ( \"somefile.txt\" , \"w\" ) To append to the end of the file if it exists: u = open ( \"somefile.txt\" , \"a\" ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer Calls proc~~open~~CallsGraph proc~open open interface~optval optval proc~open->interface~optval proc~parse_mode parse_mode proc~open->proc~parse_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables access_ action_ form_ mode_ position_ status_ Source Code open Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: access_ character(len=:), public, allocatable :: action_ character(len=:), public, allocatable :: form_ character(len=3), public :: mode_ character(len=:), public, allocatable :: position_ character(len=:), public, allocatable :: status_ Source Code integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open","tags":"","loc":"proc/open.html"},{"title":"parse_mode – Fortran-lang/stdlib","text":"public function parse_mode(mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3) Called by proc~~parse_mode~~CalledByGraph proc~parse_mode parse_mode proc~open open proc~open->proc~parse_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a i lfirst Source Code parse_mode Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: a integer, public :: i logical, public :: lfirst (3) Source Code character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode","tags":"","loc":"proc/parse_mode.html"},{"title":"loadtxt – Fortran-lang/stdlib","text":"public interface loadtxt Loads a 2D array from a text file\n ( Specification ) Contents Module Procedures loadtxt_rsp loadtxt_rdp loadtxt_rqp loadtxt_iint8 loadtxt_iint16 loadtxt_iint32 loadtxt_iint64 loadtxt_csp loadtxt_cdp loadtxt_cqp Module Procedures private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ...","tags":"","loc":"interface/loadtxt.html"},{"title":"savetxt – Fortran-lang/stdlib","text":"public interface savetxt Saves a 2D array into a text file\n ( Specification ) Contents Module Procedures savetxt_rsp savetxt_rdp savetxt_rqp savetxt_iint8 savetxt_iint16 savetxt_iint32 savetxt_iint64 savetxt_csp savetxt_cdp savetxt_cqp Module Procedures private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data )","tags":"","loc":"interface/savetxt.html"},{"title":"check – Fortran-lang/stdlib","text":"public subroutine check(condition, msg, code, warn) Checks the value of a logical condition\n ( Specification ) Behavior If condition == .false. and: No other arguments are provided, it stops the program with the default\n     message and exit code 1 ; msg is provided, it prints the value of msg ; code is provided, it stops the program with the given exit code; warn is provided and .true. , it doesn't stop the program and prints\n     the message. Examples If a /= 5 , stops the program with exit code 1 and prints Check failed. call check ( a == 5 ) As above, but prints a == 5 failed . call check ( a == 5 , msg = 'a == 5 failed.' ) As above, but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) As example #2, but stops the program with exit code 77 call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn Calls proc~~check~~CallsGraph proc~check check interface~optval optval proc~check->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables msg_default Source Code check Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: msg_default = 'Check failed.' Source Code subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check","tags":"","loc":"proc/check.html"},{"title":"error_stop – Fortran-lang/stdlib","text":"interface public module subroutine error_stop(msg, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Description Provides a call to error stop and allows the user to specify a code and message\n ( Specification )","tags":"","loc":"interface/error_stop.html"},{"title":"gauss_legendre – Fortran-lang/stdlib","text":"public interface gauss_legendre Computes Gauss-Legendre quadrature nodes and weights. Contents Subroutines gauss_legendre_fp64 Subroutines public pure subroutine gauss_legendre_fp64(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(out) :: w (:) real(kind=dp), intent(in), optional :: interval (2)","tags":"","loc":"interface/gauss_legendre.html"},{"title":"gauss_legendre_lobatto – Fortran-lang/stdlib","text":"public interface gauss_legendre_lobatto Computes Gauss-Legendre-Lobatto quadrature nodes and weights. Contents Subroutines gauss_legendre_lobatto_fp64 Subroutines public pure subroutine gauss_legendre_lobatto_fp64(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(out) :: w (:) real(kind=dp), intent(in), optional :: interval (2)","tags":"","loc":"interface/gauss_legendre_lobatto.html"},{"title":"simps – Fortran-lang/stdlib","text":"public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) Contents Functions simps_dx_dp simps_dx_qp simps_dx_sp simps_x_dp simps_x_qp simps_x_sp Functions public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp)","tags":"","loc":"interface/simps.html"},{"title":"simps_weights – Fortran-lang/stdlib","text":"public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions simps_weights_dp simps_weights_qp simps_weights_sp Functions public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/simps_weights.html"},{"title":"trapz – Fortran-lang/stdlib","text":"public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) Contents Functions trapz_dx_dp trapz_dx_qp trapz_dx_sp trapz_x_dp trapz_x_qp trapz_x_sp Functions public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp)","tags":"","loc":"interface/trapz.html"},{"title":"trapz_weights – Fortran-lang/stdlib","text":"public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions trapz_weights_dp trapz_weights_qp trapz_weights_sp Functions public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/trapz_weights.html"},{"title":"ord_sort – Fortran-lang/stdlib","text":"public interface ord_sort The generic subroutine interface implementing the ORD_SORT algorithm,\n a translation to Fortran 2008, of the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\n and insertion sort .\n ( Specification ) It is always at worst O(N Ln(N)) in sorting random\n data, having a performance about 25% slower than SORT on such\n data, but has much better performance than SORT on partially\n sorted data, having O(N) performance on uniformly non-increasing or\n non-decreasing data. Contents Subroutines char_ord_sort dp_ord_sort int16_ord_sort int32_ord_sort int64_ord_sort int8_ord_sort qp_ord_sort sp_ord_sort string_type_ord_sort Subroutines public subroutine char_ord_sort(array, work, reverse) char_ord_sort( array[, work, reverse] ) sorts the input ARRAY of type CHARACTER(*) using a hybrid sort based on the 'Rust\" sort algorithm\n found in slice.rs Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len(array)), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine dp_ord_sort(array, work, reverse) dp_ord_sort( array ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int16_ord_sort(array, work, reverse) int16_ord_sort( array ) sorts the input ARRAY of type integer(int16) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) integer(kind=int16), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int32_ord_sort(array, work, reverse) int32_ord_sort( array ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int64_ord_sort(array, work, reverse) int64_ord_sort( array ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int8_ord_sort(array, work, reverse) int8_ord_sort( array ) sorts the input ARRAY of type integer(int8) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) integer(kind=int8), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine qp_ord_sort(array, work, reverse) qp_ord_sort( array ) sorts the input ARRAY of type real(qp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) real(kind=qp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine sp_ord_sort(array, work, reverse) sp_ord_sort( array ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine string_type_ord_sort(array, work, reverse) string_type_ord_sort( array ) sorts the input ARRAY of type type(string_type) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) type( string_type ), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse","tags":"","loc":"interface/ord_sort.html"},{"title":"sort – Fortran-lang/stdlib","text":"public interface sort The generic subroutine interface implementing the SORT algorithm, based\n on the introsort of David Musser.\n ( Specification ) Contents Subroutines char_sort dp_sort int16_sort int32_sort int64_sort int8_sort qp_sort sp_sort string_type_sort Subroutines public pure subroutine char_sort(array, reverse) char_sort( array[, reverse] ) sorts the input ARRAY of type CHARACTER(*) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine dp_sort(array, reverse) dp_sort( array[, reverse] ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int16_sort(array, reverse) int16_sort( array[, reverse] ) sorts the input ARRAY of type integer(int16) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int32_sort(array, reverse) int32_sort( array[, reverse] ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int64_sort(array, reverse) int64_sort( array[, reverse] ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int8_sort(array, reverse) int8_sort( array[, reverse] ) sorts the input ARRAY of type integer(int8) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine qp_sort(array, reverse) qp_sort( array[, reverse] ) sorts the input ARRAY of type real(qp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine sp_sort(array, reverse) sp_sort( array[, reverse] ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine string_type_sort(array, reverse) string_type_sort( array[, reverse] ) sorts the input ARRAY of type type(string_type) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) logical, intent(in), optional :: reverse","tags":"","loc":"interface/sort.html"},{"title":"sort_index – Fortran-lang/stdlib","text":"public interface sort_index The generic subroutine interface implementing the SORT_INDEX algorithm,\n based on the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\n but modified to return an array of indices that would provide a stable\n sort of the rank one ARRAY input.\n ( Specification ) The indices by default correspond to a\n non-decreasing sort, but if the optional argument REVERSE is present\n with a value of .TRUE. the indices correspond to a non-increasing sort. Contents Subroutines char_sort_index dp_sort_index int16_sort_index int32_sort_index int64_sort_index int8_sort_index qp_sort_index sp_sort_index string_type_sort_index Subroutines public subroutine char_sort_index(array, index, work, iwork, reverse) char_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type CHARACTER(*) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) character(len=len(array)), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine dp_sort_index(array, index, work, iwork, reverse) dp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(dp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int16_sort_index(array, index, work, iwork, reverse) int16_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int16) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int16), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int32_sort_index(array, index, work, iwork, reverse) int32_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int32) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int64_sort_index(array, index, work, iwork, reverse) int64_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int64) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int8_sort_index(array, index, work, iwork, reverse) int8_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int8) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int8), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine qp_sort_index(array, index, work, iwork, reverse) qp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(qp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=qp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine sp_sort_index(array, index, work, iwork, reverse) sp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(sp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine string_type_sort_index(array, index, work, iwork, reverse) string_type_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type type(string_type) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) type( string_type ), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse","tags":"","loc":"interface/sort_index.html"},{"title":"clip – Fortran-lang/stdlib","text":"public interface clip Contents Module Procedures clip_int8 clip_int16 clip_int32 clip_int64 clip_sp clip_dp clip_qp Module Procedures private elemental function clip_int8(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x integer(kind=int8), intent(in) :: xmin integer(kind=int8), intent(in) :: xmax Return Value integer(kind=int8) private elemental function clip_int16(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x integer(kind=int16), intent(in) :: xmin integer(kind=int16), intent(in) :: xmax Return Value integer(kind=int16) private elemental function clip_int32(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: xmin integer(kind=int32), intent(in) :: xmax Return Value integer(kind=int32) private elemental function clip_int64(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: xmin integer(kind=int64), intent(in) :: xmax Return Value integer(kind=int64) private elemental function clip_sp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x real(kind=sp), intent(in) :: xmin real(kind=sp), intent(in) :: xmax Return Value real(kind=sp) private elemental function clip_dp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: xmin real(kind=dp), intent(in) :: xmax Return Value real(kind=dp) private elemental function clip_qp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x real(kind=qp), intent(in) :: xmin real(kind=qp), intent(in) :: xmax Return Value real(kind=qp)","tags":"","loc":"interface/clip.html"},{"title":"linspace – Fortran-lang/stdlib","text":"public interface linspace Create rank 1 array of linearly spaced elements\n If the number of elements is not specified, create an array with size 100. If n is a negative value,\n return an array with size 0. If n = 1, return an array whose only element is end\n( Specification ) When dealing with integers as the start and end parameters, the return type is always a real(dp) . Contents Functions linspace_default_1_cdp_cdp linspace_default_1_cqp_cqp linspace_default_1_csp_csp linspace_default_1_iint16_iint16 linspace_default_1_iint32_iint32 linspace_default_1_iint64_iint64 linspace_default_1_iint8_iint8 linspace_default_1_rdp_rdp linspace_default_1_rqp_rqp linspace_default_1_rsp_rsp linspace_n_1_cdp_cdp linspace_n_1_cqp_cqp linspace_n_1_csp_csp linspace_n_1_iint16_iint16 linspace_n_1_iint32_iint32 linspace_n_1_iint64_iint64 linspace_n_1_iint8_iint8 linspace_n_1_rdp_rdp linspace_n_1_rqp_rqp linspace_n_1_rsp_rsp Functions public function linspace_default_1_cdp_cdp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end Return Value complex(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_cqp_cqp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end Return Value complex(kind=qp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_csp_csp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end Return Value complex(kind=sp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint16_iint16(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint32_iint32(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint64_iint64(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint8_iint8(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rdp_rdp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rqp_rqp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rsp_rsp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_n_1_cdp_cdp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=dp)\n  (n) public function linspace_n_1_cqp_cqp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=qp)\n  (n) public function linspace_n_1_csp_csp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=sp)\n  (n) public function linspace_n_1_iint16_iint16(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint32_iint32(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint64_iint64(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint8_iint8(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_rdp_rdp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_rqp_rqp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=qp)\n  (n) public function linspace_n_1_rsp_rsp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=sp)\n  (n)","tags":"","loc":"interface/linspace.html"},{"title":"logspace – Fortran-lang/stdlib","text":"public interface logspace Create rank 1 array of logarithmically spaced elements from base start to base end.\n If the number of elements is not specified, create an array with size 50. If n is a negative value,\n return an array with size 0. If n = 1, return an array whose only element is base**end. If no base\n is specified, logspace will default to using a base of 10 ( Specification ) Contents Functions logspace_1_cdp_default logspace_1_cdp_n logspace_1_cdp_n_cbase logspace_1_cdp_n_ibase logspace_1_cdp_n_rbase logspace_1_cqp_default logspace_1_cqp_n logspace_1_cqp_n_cbase logspace_1_cqp_n_ibase logspace_1_cqp_n_rbase logspace_1_csp_default logspace_1_csp_n logspace_1_csp_n_cbase logspace_1_csp_n_ibase logspace_1_csp_n_rbase logspace_1_iint32_default logspace_1_iint32_n logspace_1_iint32_n_cdpbase logspace_1_iint32_n_cqpbase logspace_1_iint32_n_cspbase logspace_1_iint32_n_ibase logspace_1_iint32_n_rdpbase logspace_1_iint32_n_rqpbase logspace_1_iint32_n_rspbase logspace_1_rdp_default logspace_1_rdp_n logspace_1_rdp_n_cbase logspace_1_rdp_n_ibase logspace_1_rdp_n_rbase logspace_1_rqp_default logspace_1_rqp_n logspace_1_rqp_n_cbase logspace_1_rqp_n_ibase logspace_1_rqp_n_rbase logspace_1_rsp_default logspace_1_rsp_n logspace_1_rsp_n_cbase logspace_1_rsp_n_ibase logspace_1_rsp_n_rbase Functions public function logspace_1_cdp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end Return Value complex(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_cdp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cqp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end Return Value complex(kind=qp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_cqp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_csp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end Return Value complex(kind=sp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_csp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_iint32_default(start, end) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_iint32_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function logspace_1_iint32_n_cdpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_iint32_n_cqpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_iint32_n_cspbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_iint32_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value integer\n  (n) public function logspace_1_iint32_n_rdpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_iint32_n_rqpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_iint32_n_rspbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rdp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rdp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rqp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rqp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rsp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rsp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n)","tags":"","loc":"interface/logspace.html"},{"title":"stdlib_linalg – Fortran-lang/stdlib","text":"Provides a support for various linear algebra procedures\n ( Specification ) Uses stdlib_kinds module~~stdlib_linalg~~UsesGraph module~stdlib_linalg stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_linalg_diag stdlib_linalg_outer_product module~~stdlib_linalg~~UsedByGraph module~stdlib_linalg stdlib_linalg module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_linalg_outer_product stdlib_linalg_outer_product module~stdlib_linalg_outer_product->module~stdlib_linalg module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces diag outer_product trace Functions eye Interfaces public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k)) public interface outer_product Computes the outer product of two vectors, returning a rank-2 array\n ( Specification ) public pure function outer_product_cdp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: u (:) complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(u),size(v)) public pure function outer_product_cqp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: u (:) complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(u),size(v)) public pure function outer_product_csp(u, v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: u (:) complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(u),size(v)) public pure function outer_product_iint16(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: u (:) integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(u),size(v)) public pure function outer_product_iint32(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: u (:) integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(u),size(v)) public pure function outer_product_iint64(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: u (:) integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(u),size(v)) public pure function outer_product_iint8(u, v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: u (:) integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(u),size(v)) public pure function outer_product_rdp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u (:) real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(u),size(v)) public pure function outer_product_rqp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: u (:) real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(u),size(v)) public pure function outer_product_rsp(u, v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: u (:) real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(u),size(v)) public interface trace Computes the trace of a matrix\n ( Specification ) private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64) Functions public function eye (n) result(res) Version experimental Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n)","tags":"","loc":"module/stdlib_linalg.html"},{"title":"stdlib_string_type – Fortran-lang/stdlib","text":"Implementation of a string type to hold an arbitrary sequence of characters. This module provides string type compatible with all Fortran instrinsic character\n procedures as well as overloaded operators for working with character variables. A string type can be easily constructed by creating a new instance from a\n character variable or literal by invoking its constructor or by assigning it\n to a string type. Generally, the string type behaves similar to a deferred\n length character in most regards but adds memory access safety. The specification of this module is available here . Uses stdlib_ascii stdlib_kinds module~~stdlib_string_type~~UsesGraph module~stdlib_string_type stdlib_string_type module~stdlib_ascii stdlib_ascii module~stdlib_string_type->module~stdlib_ascii module~stdlib_kinds stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_ascii->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_string_type~~UsedByGraph module~stdlib_string_type stdlib_string_type module~stdlib_sorting stdlib_sorting module~stdlib_sorting->module~stdlib_string_type module~stdlib_strings stdlib_strings module~stdlib_strings->module~stdlib_string_type module~stdlib_sorting_sort_index stdlib_sorting_sort_index module~stdlib_sorting_sort_index->module~stdlib_sorting module~stdlib_sorting_sort stdlib_sorting_sort module~stdlib_sorting_sort->module~stdlib_sorting module~stdlib_sorting_ord_sort stdlib_sorting_ord_sort module~stdlib_sorting_ord_sort->module~stdlib_sorting Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces adjustl adjustr assignment(=) char iachar ichar index len len_trim lge lgt lle llt operator(//) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) read(formatted) read(unformatted) repeat reverse scan string_type to_lower to_sentence to_title to_upper trim verify write(formatted) write(unformatted) Derived Types string_type Interfaces public interface adjustl Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Read more… private elemental function adjustl_string(string) result(adjusted_string) Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface adjustr Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Read more… private elemental function adjustr_string(string) result(adjusted_string) Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface assignment(=) Assign a character sequence to a string. private elemental subroutine assign_string_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs public interface char Return the character sequence represented by the string. Read more… private pure function char_string(string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) private elemental function char_string_pos(string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private pure function char_string_range(string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last-start+1) public interface iachar Code in ASCII collating sequence. Read more… private elemental function iachar_string(string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface ichar Character-to-integer conversion function. Read more… private elemental function ichar_string(string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface index Position of a substring within a string . Read more… private elemental function index_string_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public interface len Returns the length of the character sequence represented by the string. Read more… private elemental function len_string(string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface len_trim Returns the length of the character sequence without trailing spaces\n represented by the string. Read more… private elemental function len_trim_string(string) result(length) Returns the length of the character sequence without trailing spaces\n represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface lge Lexically compare the order of two character sequences being greater equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read more… private elemental function lge_string_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface lgt Lexically compare the order of two character sequences being greater,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read more… private elemental function lgt_string_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface lle Lexically compare the order of two character sequences being less equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read more… private elemental function lle_string_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface llt Lexically compare the order of two character sequences being less,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read more… private elemental function llt_string_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\n or both character sequences can be represented by a string. Read more… private elemental function concat_string_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_char(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_char_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) public interface operator(/=) Compare two character sequences for inequality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function ne_string_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(<) Compare two character sequences for being less, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function lt_string_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(<=) Compare two character sequences for being less than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function le_string_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(==) Compare two character sequences for equality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function eq_string_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(>) Compare two character sequences for being greater, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function gt_string_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(>=) Compare two character sequences for being greater than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read more… private elemental function ge_string_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface read(formatted) Read a character sequence from a connected unformatted unit into the string. private subroutine read_formatted(string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface read(unformatted) Read a character sequence from a connected unformatted unit into the string. private subroutine read_unformatted(string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface repeat Repeats the character sequence hold by the string by the number of\n specified copies. Read more… private elemental function repeat_string(string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\n specified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type ) public interface reverse Reverses the character sequence hold by the input string Read more… private elemental function reverse_string(string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface scan Scan a string for the presence of a set of characters. Scans a string for\n any of the characters in a set of characters. Read more… private elemental function scan_string_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version both the character sequence and the character set are\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface string_type Constructor for new string instances private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental function new_string_from_integer_int8(val) result(new) Constructor for new string instances from an integer of kind int8. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int16(val) result(new) Constructor for new string instances from an integer of kind int16. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int32(val) result(new) Constructor for new string instances from an integer of kind int32. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_integer_int64(val) result(new) Constructor for new string instances from an integer of kind int64. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_lk(val) result(new) Constructor for new string instances from a logical of kind lk. Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: val Return Value type( string_type ) private elemental function new_string_from_logical_c_bool(val) result(new) Constructor for new string instances from a logical of kind c_bool. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: val Return Value type( string_type ) public interface to_lower Returns the lowercase version of the character sequence hold by the input string Read more… private elemental function to_lower_string(string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface to_sentence Returns the sentencecase version of the character sequence hold by the input string Read more… private elemental function to_sentence_string(string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface to_title Returns the titlecase version of the character sequence hold by the input string Read more… private elemental function to_title_string(string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface to_upper Returns the uppercase version of the character sequence hold by the input string Read more… private elemental function to_upper_string(string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface trim Returns the character sequence hold by the string without trailing spaces. Read more… private elemental function trim_string(string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public interface verify Scan a string for the absence of a set of characters. Verifies that all\n the characters in string belong to the set of characters in set. Read more… private elemental function verify_string_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version both the character sequence and\n the character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the character sequences is\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the set of characters is\n represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface write(formatted) Write the character sequence hold by the string to a connected formatted\n unit. private subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface write(unformatted) Write the character sequence hold by the string to a connected unformatted\n unit. private subroutine write_unformatted(string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, sequence  :: string_type String type holding an arbitrary sequence of characters. Constructor Constructor for new string instances private elemental function new_string (string) Constructor for new string instances from a scalar character value. private elemental function new_string_from_integer_int8 (val) Constructor for new string instances from an integer of kind int8. private elemental function new_string_from_integer_int16 (val) Constructor for new string instances from an integer of kind int16. private elemental function new_string_from_integer_int32 (val) Constructor for new string instances from an integer of kind int32. private elemental function new_string_from_integer_int64 (val) Constructor for new string instances from an integer of kind int64. private elemental function new_string_from_logical_lk (val) Constructor for new string instances from a logical of kind lk. private elemental function new_string_from_logical_c_bool (val) Constructor for new string instances from a logical of kind c_bool.","tags":"","loc":"module/stdlib_string_type.html"},{"title":"stdlib_stats_distribution_PRNG – Fortran-lang/stdlib","text":"Uses stdlib_kinds stdlib_error module~~stdlib_stats_distribution_prng~~UsesGraph module~stdlib_stats_distribution_prng stdlib_stats_distribution_PRNG module~stdlib_error stdlib_error module~stdlib_stats_distribution_prng->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_stats_distribution_prng->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding module~stdlib_kinds->iso_fortran_env module~stdlib_optval->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces dist_rand random_seed Interfaces public interface dist_rand Version experimental Read more… private function dist_rand_iint8(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Return Value integer(kind=int8) private function dist_rand_iint16(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: n Return Value integer(kind=int16) private function dist_rand_iint32(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Return Value integer(kind=int32) private function dist_rand_iint64(n) result(res) Random integer generation for various kinds\n result = [-2&#94;k, 2&#94;k - 1], k = 7, 15, 31, 63, depending on input kind\n Result will be operated by bitwise operators to generate desired integer\n and real pseudorandom numbers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Return Value integer(kind=int64) public interface random_seed Version experimental Read more… private subroutine random_distribution_seed_iint8(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: put integer(kind=int8), intent(out) :: get private subroutine random_distribution_seed_iint16(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: put integer(kind=int16), intent(out) :: get private subroutine random_distribution_seed_iint32(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: put integer(kind=int32), intent(out) :: get private subroutine random_distribution_seed_iint64(put, get) Set seed value for random number generator Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: put integer(kind=int64), intent(out) :: get","tags":"","loc":"module/stdlib_stats_distribution_prng.html"},{"title":"stdlib_specialfunctions – Fortran-lang/stdlib","text":"Uses stdlib_kinds module~~stdlib_specialfunctions~~UsesGraph module~stdlib_specialfunctions stdlib_specialfunctions module~stdlib_kinds stdlib_kinds module~stdlib_specialfunctions->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_specialfunctions_legendre module~~stdlib_specialfunctions~~UsedByGraph module~stdlib_specialfunctions stdlib_specialfunctions module~stdlib_specialfunctions_legendre stdlib_specialfunctions_legendre module~stdlib_specialfunctions_legendre->module~stdlib_specialfunctions module~stdlib_quadrature_gauss stdlib_quadrature_gauss module~stdlib_quadrature_gauss->module~stdlib_specialfunctions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces dlegendre legendre Interfaces public interface dlegendre First derivative Legendre polynomial public pure elemental function dlegendre_fp64(n, x) result(dleg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) public interface legendre Legendre polynomial public pure elemental function legendre_fp64(n, x) result(leg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp)","tags":"","loc":"module/stdlib_specialfunctions.html"},{"title":"stdlib_bitsets – Fortran-lang/stdlib","text":"Implements zero based bitsets of size up to huge(0_int32) .\n The current code uses 64 bit integers to store the bits and uses all 64 bits.\n The code assumes two's complement integers, and treats negative integers as\n having the sign bit set.\n( Specification ) Public procedures Uses stdlib_kinds iso_fortran_env module~~stdlib_bitsets~~UsesGraph module~stdlib_bitsets stdlib_bitsets module~stdlib_kinds stdlib_kinds module~stdlib_bitsets->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_bitsets->iso_fortran_env module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_bitsets_64 stdlib_bitsets_large module~~stdlib_bitsets~~UsedByGraph module~stdlib_bitsets stdlib_bitsets module~stdlib_bitsets_large stdlib_bitsets_large module~stdlib_bitsets_large->module~stdlib_bitsets module~stdlib_bitsets_64 stdlib_bitsets_64 module~stdlib_bitsets_64->module~stdlib_bitsets Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables alloc_fault array_size_invalid_error char_string_invalid_error char_string_too_large_error char_string_too_small_error eof_failure index_invalid_error integer_overflow_error max_digits overflow_bits read_failure success write_failure Interfaces and and_not assignment(=) extract operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) or xor Derived Types bitset_64 bitset_large bitset_type Functions bits Subroutines error_handler Variables Type Visibility Attributes Name Initial integer, public, parameter :: alloc_fault = 1 Error flag indicating a memory allocation failure integer, public, parameter :: array_size_invalid_error = 2 Error flag indicating an invalid bits value integer, public, parameter :: char_string_invalid_error = 3 Error flag indicating an invalid character string integer, public, parameter :: char_string_too_large_error = 4 Error flag indicating a too large character string integer, public, parameter :: char_string_too_small_error = 5 Error flag indicating a too small character string integer, public, parameter :: eof_failure = 6 Error flag indicating unexpected End-of-File on a READ integer, public, parameter :: index_invalid_error = 7 Error flag indicating an invalid index integer, public, parameter :: integer_overflow_error = 8 Error flag indicating integer overflow integer, public, parameter :: max_digits = 10 integer(kind=bits_kind), public, parameter :: overflow_bits = 2_bits_kind**30/5 integer, public, parameter :: read_failure = 9 Error flag indicating failure of a READ statement integer, public, parameter :: success = 0 Error flag indicating no errors integer, public, parameter :: write_failure = 10 Error flag indicating a failure on a WRITE statement Interfaces public interface and Sets the bits in set1 to the bitwise and of the original bits in set1 and set2 . The sets must have the same number of bits\n otherwise the result is undefined.\n ( Specification ) Read more… public elemental subroutine and_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine and_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2 public interface and_not Sets the bits in set1 to the bitwise and of the original bits in set1 with the bitwise negation of set2 . The sets must have the same\n number of bits otherwise the result is undefined. Read more… public elemental subroutine and_not_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine and_not_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2 public interface assignment(=) Used to define assignment for bitset_large .\n ( Specification ) Read more… public pure subroutine assign_large(set1, set2) Used to define assignment for bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: set1 type( bitset_large ), intent(in) :: set2 public pure subroutine assign_logint16_large(self, logical_vector) Used to define assignment from an array of type logical(int16) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int16), intent(in) :: logical_vector (:) public pure subroutine assign_logint32_large(self, logical_vector) Used to define assignment from an array of type logical(int32) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int32), intent(in) :: logical_vector (:) public pure subroutine assign_logint64_large(self, logical_vector) Used to define assignment from an array of type logical(int64) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int64), intent(in) :: logical_vector (:) public pure subroutine assign_logint8_large(self, logical_vector) Used to define assignment from an array of type logical(int8) to a bitset_large . Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: self logical(kind=int8), intent(in) :: logical_vector (:) public pure subroutine logint16_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int16) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int16), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint32_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int32) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int32), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint64_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int64) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int64), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public pure subroutine logint8_assign_large(logical_vector, set) Used to define assignment to an array of type logical(int8) from a bitset_large . Arguments Type Intent Optional Attributes Name logical(kind=int8), intent(out), allocatable :: logical_vector (:) type( bitset_large ), intent(in) :: set public interface extract Creates a new bitset, new , from a range, start_pos to stop_pos , in\n bitset old . If start_pos is greater than stop_pos the new bitset is\n empty. If start_pos is less than zero or stop_pos is greater than bits(old)-1 then if status is present it has the value index_invalid_error and new is undefined, otherwise processing stops\n with an informative message.\n ( Specification ) Read more… public subroutine extract_64(new, old, start_pos, stop_pos, status) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(out) :: new type( bitset_64 ), intent(in) :: old integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos integer, intent(out), optional :: status public subroutine extract_large(new, old, start_pos, stop_pos, status) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(out) :: new type( bitset_large ), intent(in) :: old integer(kind=bits_kind), intent(in) :: start_pos integer(kind=bits_kind), intent(in) :: stop_pos integer, intent(out), optional :: status public interface operator(/=) Returns .true. if not all bits in set1 and set2 have the same value, .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental function neqv_64(set1, set2) result(neqv) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function neqv_large(set1, set2) result(neqv) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface operator(<) Returns .true. if the bits in set1 and set2 differ and the\n highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental function lt_64(set1, set2) result(lt) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function lt_large(set1, set2) result(lt) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface operator(<=) Returns .true. if the bits in set1 and set2 are the same or the\n highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental function le_64(set1, set2) result(le) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function le_large(set1, set2) result(le) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface operator(==) Returns .true. if all bits in set1 and set2 have the same value, .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental function eqv_64(set1, set2) result(eqv) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function eqv_large(set1, set2) result(eqv) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface operator(>) Returns .true. if the bits in set1 and set2 differ and the\n highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental function gt_64(set1, set2) result(gt) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function gt_large(set1, set2) result(gt) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface operator(>=) Returns .true. if the bits in set1 and set2 are the same or the\n highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must have the same number of bits\n otherwise the result is undefined.\n ( Specification ) Read more… public elemental function ge_64(set1, set2) result(ge) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(in) :: set1 type( bitset_64 ), intent(in) :: set2 Return Value logical public elemental function ge_large(set1, set2) result(ge) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(in) :: set1 type( bitset_large ), intent(in) :: set2 Return Value logical public interface or Sets the bits in set1 to the bitwise or of the original bits in set1 and set2 . The sets must have the same number of bits otherwise\n the result is undefined.\n ( Specification ) Read more… public elemental subroutine or_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine or_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2 public interface xor Sets the bits in set1 to the bitwise xor of the original bits in set1 and set2 . The sets must have the same number of bits\n otherwise the result is undefined.\n( Specification ) Read more… public elemental subroutine xor_64(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_64 ), intent(inout) :: set1 type( bitset_64 ), intent(in) :: set2 public elemental subroutine xor_large(set1, set2) Arguments Type Intent Optional Attributes Name type( bitset_large ), intent(inout) :: set1 type( bitset_large ), intent(in) :: set2 Derived Types type, public, extends( bitset_type ) :: bitset_64 Type for bitsets with no more than 64 bits ( Specification ) Type-Bound Procedures procedure, public, pass(self) :: all => all_64 procedure, public, pass(self) :: any => any_64 procedure, public, pass(self) :: bit_count => bit_count_64 procedure, public, pass(self) :: bits generic, public :: clear => clear_bit, clear_range procedure, public, pass(self) :: clear_bit => clear_bit_64 procedure, public, pass(self) :: clear_range => clear_range_64 generic, public :: flip => flip_bit, flip_range procedure, public, pass(self) :: flip_bit => flip_bit_64 procedure, public, pass(self) :: flip_range => flip_range_64 procedure, public, pass(self) :: from_string => from_string_64 generic, public :: init => init_zero procedure, public, pass(self) :: init_zero => init_zero_64 procedure, public, pass(self) :: input => input_64 procedure, public, pass(self) :: none => none_64 procedure, public, pass(self) :: not => not_64 procedure, public, pass(self) :: output => output_64 generic, public :: read_bitset => read_bitset_string, read_bitset_unit procedure, public, pass(self) :: read_bitset_string => read_bitset_string_64 procedure, public, pass(self) :: read_bitset_unit => read_bitset_unit_64 generic, public :: set => set_bit, set_range procedure, public, pass(self) :: set_bit => set_bit_64 procedure, public, pass(self) :: set_range => set_range_64 procedure, public, pass(self) :: test => test_64 procedure, public, pass(self) :: to_string => to_string_64 procedure, public, pass(self) :: value => value_64 generic, public :: write_bitset => write_bitset_string, write_bitset_unit procedure, public, pass(self) :: write_bitset_string => write_bitset_string_64 procedure, public, pass(self) :: write_bitset_unit => write_bitset_unit_64 type, public, extends( bitset_type ) :: bitset_large Type for bitsets with more than 64 bits ( Specification ) Type-Bound Procedures procedure, public, pass(self) :: all => all_large procedure, public, pass(self) :: any => any_large procedure, public, pass(self) :: bit_count => bit_count_large procedure, public, pass(self) :: bits generic, public :: clear => clear_bit, clear_range procedure, public, pass(self) :: clear_bit => clear_bit_large procedure, public, pass(self) :: clear_range => clear_range_large generic, public :: flip => flip_bit, flip_range procedure, public, pass(self) :: flip_bit => flip_bit_large procedure, public, pass(self) :: flip_range => flip_range_large procedure, public, pass(self) :: from_string => from_string_large generic, public :: init => init_zero procedure, public, pass(self) :: init_zero => init_zero_large procedure, public, pass(self) :: input => input_large procedure, public, pass(self) :: none => none_large procedure, public, pass(self) :: not => not_large procedure, public, pass(self) :: output => output_large generic, public :: read_bitset => read_bitset_string, read_bitset_unit procedure, public, pass(self) :: read_bitset_string => read_bitset_string_large procedure, public, pass(self) :: read_bitset_unit => read_bitset_unit_large generic, public :: set => set_bit, set_range procedure, public, pass(self) :: set_bit => set_bit_large procedure, public, pass(self) :: set_range => set_range_large procedure, public, pass(self) :: test => test_large procedure, public, pass(self) :: to_string => to_string_large procedure, public, pass(self) :: value => value_large generic, public :: write_bitset => write_bitset_string, write_bitset_unit procedure, public, pass(self) :: write_bitset_string => write_bitset_string_large procedure, public, pass(self) :: write_bitset_unit => write_bitset_unit_large type, public, abstract :: bitset_type Parent type for bitset_64 and bitset_large ( Specification ) Type-Bound Procedures procedure(all_abstract), public, pass(self) :: all procedure(any_abstract), public, pass(self) :: any procedure(bit_count_abstract), public, pass(self) :: bit_count procedure, public, pass(self) :: bits generic, public :: clear => clear_bit, clear_range procedure(clear_bit_abstract), public, pass(self) :: clear_bit procedure(clear_range_abstract), public, pass(self) :: clear_range generic, public :: flip => flip_bit, flip_range procedure(flip_bit_abstract), public, pass(self) :: flip_bit procedure(flip_range_abstract), public, pass(self) :: flip_range procedure(from_string_abstract), public, pass(self) :: from_string generic, public :: init => init_zero procedure(init_zero_abstract), public, pass(self) :: init_zero procedure(input_abstract), public, pass(self) :: input procedure(none_abstract), public, pass(self) :: none procedure(not_abstract), public, pass(self) :: not procedure(output_abstract), public, pass(self) :: output generic, public :: read_bitset => read_bitset_string, read_bitset_unit procedure(read_bitset_string_abstract), public, pass(self) :: read_bitset_string procedure(read_bitset_unit_abstract), public, pass(self) :: read_bitset_unit generic, public :: set => set_bit, set_range procedure(set_bit_abstract), public, pass(self) :: set_bit procedure(set_range_abstract), public, pass(self) :: set_range procedure(test_abstract), public, pass(self) :: test procedure(to_string_abstract), public, pass(self) :: to_string procedure(value_abstract), public, pass(self) :: value generic, public :: write_bitset => write_bitset_string, write_bitset_unit procedure(write_bitset_string_abstract), public, pass(self) :: write_bitset_string procedure(write_bitset_unit_abstract), public, pass(self) :: write_bitset_unit Functions public elemental function bits (self) Version experimental Returns the number of bit positions in self . Arguments Type Intent Optional Attributes Name class( bitset_type ), intent(in) :: self Return Value integer(kind=bits_kind) Subroutines public subroutine error_handler (message, error, status, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: error integer, intent(out), optional :: status character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure","tags":"","loc":"module/stdlib_bitsets.html"},{"title":"stdlib_optval – Fortran-lang/stdlib","text":"Provides a generic function optval , which can be used to\n conveniently implement fallback values for optional arguments\n to subprograms\n ( Specification ) If x is an optional parameter of a\n subprogram, then the expression optval(x, default) inside that\n subprogram evaluates to x if it is present, otherwise default . It is an error to call optval with a single actual argument. Uses stdlib_kinds module~~stdlib_optval~~UsesGraph module~stdlib_optval stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_optval~~UsedByGraph module~stdlib_optval stdlib_optval module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_optval module~stdlib_error stdlib_error module~stdlib_stats_var->module~stdlib_error module~stdlib_stats_moment_scalar stdlib_stats_moment_scalar module~stdlib_stats_moment_scalar->module~stdlib_optval module~stdlib_stats_moment_scalar->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_optval module~stdlib_io->module~stdlib_error module~stdlib_strings stdlib_strings module~stdlib_strings->module~stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_error module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_optval module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_error module~stdlib_stats_moment_mask stdlib_stats_moment_mask module~stdlib_stats_moment_mask->module~stdlib_optval module~stdlib_stats_moment_mask->module~stdlib_error module~stdlib_stats_moment_all stdlib_stats_moment_all module~stdlib_stats_moment_all->module~stdlib_optval module~stdlib_stats_moment_all->module~stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats_cov->module~stdlib_error module~estop estop module~estop->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_stats_distribution_prng stdlib_stats_distribution_PRNG module~stdlib_stats_distribution_prng->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces optval Interfaces public interface optval Fallback value for optional arguments\n ( Specification ) private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"module/stdlib_optval.html"},{"title":"stdlib_ascii – Fortran-lang/stdlib","text":"The stdlib_ascii module provides procedures for handling and manipulating\n intrinsic character variables and constants. The specification of this module is available here . Uses stdlib_kinds module~~stdlib_ascii~~UsesGraph module~stdlib_ascii stdlib_ascii module~stdlib_kinds stdlib_kinds module~stdlib_ascii->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_ascii~~UsedByGraph module~stdlib_ascii stdlib_ascii module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_ascii module~stdlib_string_type stdlib_string_type module~stdlib_string_type->module~stdlib_ascii module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_ascii module~stdlib_strings stdlib_strings module~stdlib_strings->module~stdlib_ascii module~stdlib_strings->module~stdlib_string_type module~stdlib_sorting stdlib_sorting module~stdlib_sorting->module~stdlib_string_type module~stdlib_sorting_sort_index stdlib_sorting_sort_index module~stdlib_sorting_sort_index->module~stdlib_sorting module~stdlib_sorting_sort stdlib_sorting_sort module~stdlib_sorting_sort->module~stdlib_sorting module~stdlib_sorting_ord_sort stdlib_sorting_ord_sort module~stdlib_sorting_ord_sort->module~stdlib_sorting Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ACK BEL BS CAN CR DC1 DC2 DC3 DC4 DEL DLE EM ENQ EOT ESC ETB ETX FF FS GS LF NAK NUL RS SI SO SOH STX SUB SYN TAB US VT digits fullhex_digits hex_digits letters lowercase lowerhex_digits octal_digits uppercase whitespace Interfaces to_string Functions is_alpha is_alphanum is_ascii is_blank is_control is_digit is_graphical is_hex_digit is_lower is_octal_digit is_printable is_punctuation is_upper is_white reverse to_lower to_sentence to_title to_upper Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: ACK = achar(int(z'06')) Acknowledge character(len=1), public, parameter :: BEL = achar(int(z'07')) Bell character(len=1), public, parameter :: BS = achar(int(z'08')) Backspace character(len=1), public, parameter :: CAN = achar(int(z'18')) Cancel character(len=1), public, parameter :: CR = achar(int(z'0D')) Carriage return character(len=1), public, parameter :: DC1 = achar(int(z'11')) Device control 1 character(len=1), public, parameter :: DC2 = achar(int(z'12')) Device control 2 character(len=1), public, parameter :: DC3 = achar(int(z'13')) Device control 3 character(len=1), public, parameter :: DC4 = achar(int(z'14')) Device control 4 character(len=1), public, parameter :: DEL = achar(int(z'7F')) Delete character(len=1), public, parameter :: DLE = achar(int(z'10')) Data link escape character(len=1), public, parameter :: EM = achar(int(z'19')) End of medium character(len=1), public, parameter :: ENQ = achar(int(z'05')) Enquiry character(len=1), public, parameter :: EOT = achar(int(z'04')) End of transmission character(len=1), public, parameter :: ESC = achar(int(z'1B')) Escape character(len=1), public, parameter :: ETB = achar(int(z'17')) End of transmission block character(len=1), public, parameter :: ETX = achar(int(z'03')) End of text character(len=1), public, parameter :: FF = achar(int(z'0C')) NP form feed, new page character(len=1), public, parameter :: FS = achar(int(z'1C')) File separator character(len=1), public, parameter :: GS = achar(int(z'1D')) Group separator character(len=1), public, parameter :: LF = achar(int(z'0A')) NL line feed, new line character(len=1), public, parameter :: NAK = achar(int(z'15')) Negative acknowledge character(len=1), public, parameter :: NUL = achar(int(z'00')) Null character(len=1), public, parameter :: RS = achar(int(z'1E')) Record separator character(len=1), public, parameter :: SI = achar(int(z'0F')) Shift in character(len=1), public, parameter :: SO = achar(int(z'0E')) Shift out character(len=1), public, parameter :: SOH = achar(int(z'01')) Start of heading character(len=1), public, parameter :: STX = achar(int(z'02')) Start of text character(len=1), public, parameter :: SUB = achar(int(z'1A')) Substitute character(len=1), public, parameter :: SYN = achar(int(z'16')) Synchronous idle character(len=1), public, parameter :: TAB = achar(int(z'09')) Horizontal tab character(len=1), public, parameter :: US = achar(int(z'1F')) Unit separator character(len=1), public, parameter :: VT = achar(int(z'0B')) Vertical tab character(len=*), public, parameter :: digits = hex_digits(1:10) 0 .. 9 character(len=*), public, parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" 0 .. 9A .. Fa .. f character(len=*), public, parameter :: hex_digits = fullhex_digits(1:16) 0 .. 9A .. F character(len=*), public, parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" A .. Za .. z character(len=*), public, parameter :: lowercase = letters(27:) a .. z character(len=*), public, parameter :: lowerhex_digits = \"0123456789abcdef\" 0 .. 9a .. f character(len=*), public, parameter :: octal_digits = digits(1:8) 0 .. 7 character(len=*), public, parameter :: uppercase = letters(1:26) A .. Z character(len=*), public, parameter :: whitespace = \" \"//TAB//VT//CR//LF//FF ASCII _whitespace Interfaces public interface to_string Create a character string representing the value of the provided variable. private pure function to_string_integer_int8(val) result(string) Represent an integer of kind int8 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int16(val) result(string) Represent an integer of kind int16 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int32(val) result(string) Represent an integer of kind int32 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_integer_int64(val) result(string) Represent an integer of kind int64 as character sequence Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Return Value character(len=:),\n  allocatable private pure function to_string_logical_lk(val) result(string) Represent an logical of kind lk as character sequence Arguments Type Intent Optional Attributes Name logical(kind=ik), intent(in) :: val Return Value character(len=1) private pure function to_string_logical_c_bool(val) result(string) Represent an logical of kind c_bool as character sequence Arguments Type Intent Optional Attributes Name logical(kind=ik), intent(in) :: val Return Value character(len=1) Functions public pure function is_alpha (c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_alphanum (c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_ascii (c) Checks whether or not c is in the ASCII character set -\n i.e. in the range 0 .. 0x7F. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_blank (c) Checks whether or not c is a blank character. That includes the\n only the space and tab characters Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_control (c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_digit (c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_graphical (c) Checks whether or not c is a printable character other than the\n space character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_hex_digit (c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_lower (c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_octal_digit (c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_printable (c) Checks whether or not c is a printable character - including the\n space character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_punctuation (c) Checks whether or not c is a punctuation character. That includes\n all ASCII characters which are not control characters, letters,\n digits, or whitespace. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_upper (c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_white (c) Checks whether or not c is a whitespace character. That includes the\n space, tab, vertical tab, form feed, carriage return, and linefeed\n characters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function reverse (string) result(reverse_string) Reverse the character order in the input character variable\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) public pure function to_lower (string) result(lower_string) Convert character variable to lower case\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) public pure function to_sentence (string) result(sentence_string) Converts character sequence to sentence case\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) public pure function to_title (string) result(title_string) Converts character sequence to title case\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) public pure function to_upper (string) result(upper_string) Convert character variable to upper case\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string))","tags":"","loc":"module/stdlib_ascii.html"},{"title":"stdlib_strings – Fortran-lang/stdlib","text":"This module implements basic string handling routines. The specification of this module is available here . Uses stdlib_ascii stdlib_string_type stdlib_optval module~~stdlib_strings~~UsesGraph module~stdlib_strings stdlib_strings module~stdlib_ascii stdlib_ascii module~stdlib_strings->module~stdlib_ascii module~stdlib_string_type stdlib_string_type module~stdlib_strings->module~stdlib_string_type module~stdlib_optval stdlib_optval module~stdlib_strings->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_ascii->module~stdlib_kinds module~stdlib_string_type->module~stdlib_ascii module~stdlib_string_type->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces chomp count ends_with find padl padr replace_all slice starts_with strip Interfaces public interface chomp Remove trailing characters in set from string.\n If no character set is provided trailing whitespace is removed. Read more… private pure function chomp_string(string) result(chomped_string) Remove trailing characters in set from string.\n Default character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function chomp_char(string) result(chomped_string) Remove trailing characters in set from string.\n Default character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable private pure function chomp_set_string_char(string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) private pure function chomp_set_char_char(string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:),\n  allocatable private pure function chomp_substring_string_string(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_string(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:),\n  allocatable private pure function chomp_substring_string_char(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_char(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:),\n  allocatable public interface count Returns the number of times substring 'pattern' has appeared in the\n input string 'string' Specifications private elemental function count_string_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring 'pattern' has appeared in the\n input string 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer public interface ends_with Check whether a string ends with substring or not Read more… private elemental function ends_with_string_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function ends_with_string_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_char_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function ends_with_char_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical public interface find Finds the starting index of substring 'pattern' in the input 'string' Specifications Read more… private elemental function find_string_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the 'occurrence'th occurrence of substring 'pattern'\n in input 'string'\n Returns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer public interface padl Left pad the input string Specifications private pure function padl_string_default(string, output_length) result(res) Left pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padl_string_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padl_char_default(string, output_length) result(res) Left pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(len=max(len(string),output_length)) private pure function padl_char_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(len=max(len(string),output_length)) public interface padr Right pad the input string Specifications private pure function padr_string_default(string, output_length) result(res) Right pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padr_string_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padr_char_default(string, output_length) result(res) Right pad the input string with \" \" (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(len=max(len(string),output_length)) private pure function padr_char_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the 'pad_with' character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(len=max(len(string),output_length)) public interface replace_all Replaces all the occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Version: experimental private pure function replace_all_string_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_string_char_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_char_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:),\n  allocatable private pure function replace_all_char_char_char(string, pattern, replacement) result(res) Replaces all the occurrences of substring 'pattern' in the input 'string'\n with the replacement 'replacement'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:),\n  allocatable public interface slice Extracts characters from the input string to return a new string Read more… private elemental function slice_string(string, first, last, stride) result(sliced_string) Extract the characters from the region between 'first' and 'last' index (both inclusive)\n of the input 'string' by taking strides of length 'stride'\n Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) private pure function slice_char(string, first, last, stride) result(sliced_string) Extract the characters from the region between 'first' and 'last' index (both inclusive)\n of the input 'string' by taking strides of length 'stride'\n Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:),\n  allocatable public interface starts_with Check whether a string starts with substring or not Read more… private elemental function starts_with_string_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function starts_with_string_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_char_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function starts_with_char_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical public interface strip Remove leading and trailing whitespace characters. Read more… private pure function strip_string(string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function strip_char(string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable","tags":"","loc":"module/stdlib_strings.html"},{"title":"stdlib_logger – Fortran-lang/stdlib","text":"Module stdlib_logger This module defines a derived type, procedures, a variable, and\n constants to be used for logging information and reporting errors\n in Fortran applications.\n( Specification ) The derived type, logger_type , is to be used to define variables to\n serve as both local and global loggers. A logger directs its messages\n to selected I/O units so the user has a record (a log) of major events.\n For each entity of logger_type the reports go to a list of I/O units\n represented by the private internal array, log_units . If log_units is\n empty then output by default goes to output_unit . Otherwise reports\n go to output_unit only if it has been explicitly added to log_units .\n Each entity of type logger_type also maintains an internal state\n controlling the formatting of output. The procedures are as follows. The logical function log_units_assigned returns the number of I/O units in log_units . The\n subroutines add_log_file and add_log_unit include the specified file\n in log_units . remove_log_units removes the specified logical unit from\n the log_units array and optionally closes the file. configure configures the details of the logging process. configuration reports the details of that configuration. The subroutines log_error , log_information , log_io_error , log_message , log_text_error , and log_warning send messages to the log units. The variable global_logger of type logger_type can be used\n as a default global logger anywhere in the source code. The constants are used to report errors by some of the subroutines\n in their optional stat arguments. The constants are as follows. success indicates that no error has occurred. close_failure indicates that a close statement for an I/O unit failed. index_invalid_error indicates that column was invalid for\n the given line . open_failure indicates that an open statement\n failed. read_only_error indicates that an output unit did not have a \"write\" or \"readwrite\" action. non_sequential_error indicates\n that the unit did not have sequential access. unformatted_in_error indicates that the unit did not have a form of \"formatted\" . unopened_in_error indicates that the unit was not opened. write_failure indicates that at least one of the writes to log_units failed. public constants used as error flags\n Variable of type logger_type to be used as a global logger Uses iso_fortran_env stdlib_ascii stdlib_optval module~~stdlib_logger~~UsesGraph module~stdlib_logger stdlib_logger module~stdlib_ascii stdlib_ascii module~stdlib_logger->module~stdlib_ascii module~stdlib_optval stdlib_optval module~stdlib_logger->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_logger->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_ascii->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables all_level close_failure debug_level error_level global_logger index_invalid_error information_level io_error_level non_sequential_error none_level open_failure read_only_error success text_error_level unformatted_in_error unopened_in_error warning_level write_failure Derived Types logger_type Variables Type Visibility Attributes Name Initial integer, public, parameter :: all_level = -10+min(debug_level, information_level, warning_level, error_level, io_error_level, text_error_level) integer, public, parameter :: close_failure = 1 integer, public, parameter :: debug_level = 10 integer, public, parameter :: error_level = 40 type( logger_type ), public :: global_logger integer, public, parameter :: index_invalid_error = 2 integer, public, parameter :: information_level = 20 integer, public, parameter :: io_error_level = 40 integer, public, parameter :: non_sequential_error = 3 integer, public, parameter :: none_level = 10+max(debug_level, information_level, warning_level, error_level, io_error_level, text_error_level) integer, public, parameter :: open_failure = 4 integer, public, parameter :: read_only_error = 5 integer, public, parameter :: success = 0 integer, public, parameter :: text_error_level = 50 integer, public, parameter :: unformatted_in_error = 6 integer, public, parameter :: unopened_in_error = 7 integer, public, parameter :: warning_level = 30 integer, public, parameter :: write_failure = 8 Derived Types type, public :: logger_type Public derived type ( Specification ) Finalizations Procedures final :: final_logger","tags":"","loc":"module/stdlib_logger.html"},{"title":"stdlib_stats – Fortran-lang/stdlib","text":"Provides support for various statistical methods. This includes currently\n descriptive statistics\n ( Specification ) Uses stdlib_kinds module~~stdlib_stats~~UsesGraph module~stdlib_stats stdlib_stats module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_stats_corr stdlib_stats_cov stdlib_stats_mean stdlib_stats_moment stdlib_stats_moment_all stdlib_stats_moment_mask stdlib_stats_moment_scalar stdlib_stats_var module~~stdlib_stats~~UsedByGraph module~stdlib_stats stdlib_stats module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_moment_scalar stdlib_stats_moment_scalar module~stdlib_stats_moment_scalar->module~stdlib_stats module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_stats module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_stats module~stdlib_stats_moment_mask stdlib_stats_moment_mask module~stdlib_stats_moment_mask->module~stdlib_stats module~stdlib_stats_moment_all stdlib_stats_moment_all module~stdlib_stats_moment_all->module~stdlib_stats module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_stats Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces corr cov mean moment var Interfaces public interface corr Pearson correlation of array elements\n ( Specification ) public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface cov Covariance of array elements\n ( Specification ) public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface mean Mean of array elements\n ( Specification ) public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public interface moment Central moment of array elements\n ( Specification ) public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface var Variance of array elements\n ( Specification ) public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"module/stdlib_stats.html"},{"title":"stdlib_io – Fortran-lang/stdlib","text":"Provides a support for file handling\n ( Specification ) Uses stdlib_kinds stdlib_error stdlib_optval stdlib_ascii module~~stdlib_io~~UsesGraph module~stdlib_io stdlib_io module~stdlib_error stdlib_error module~stdlib_io->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_io->module~stdlib_optval module~stdlib_ascii stdlib_ascii module~stdlib_io->module~stdlib_ascii module~stdlib_kinds stdlib_kinds module~stdlib_io->module~stdlib_kinds module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval->module~stdlib_kinds module~stdlib_ascii->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces loadtxt savetxt Functions open parse_mode Interfaces public interface loadtxt Loads a 2D array from a text file\n ( Specification ) private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... public interface savetxt Saves a 2D array into a text file\n ( Specification ) private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) Functions public function open (filename, mode, iostat) result(u) Version experimental Opens a file\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer public function parse_mode (mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3)","tags":"","loc":"module/stdlib_io.html"},{"title":"stdlib_error – Fortran-lang/stdlib","text":"Provides support for catching and handling errors\n ( Specification ) Uses iso_fortran_env stdlib_optval module~~stdlib_error~~UsesGraph module~stdlib_error stdlib_error module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: estop estop module~~stdlib_error~~UsedByGraph module~stdlib_error stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_error module~estop estop module~estop->module~stdlib_error module~stdlib_stats_moment_scalar stdlib_stats_moment_scalar module~stdlib_stats_moment_scalar->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_error module~stdlib_stats_distribution_prng stdlib_stats_distribution_PRNG module~stdlib_stats_distribution_prng->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_error module~stdlib_stats_moment_mask stdlib_stats_moment_mask module~stdlib_stats_moment_mask->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~stdlib_stats_moment_all stdlib_stats_moment_all module~stdlib_stats_moment_all->module~stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces error_stop Subroutines check Interfaces interface public module subroutine error_stop(msg, code) Provides a call to error stop and allows the user to specify a code and message\n ( Specification ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Subroutines public subroutine check (condition, msg, code, warn) Version experimental Checks the value of a logical condition\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn","tags":"","loc":"module/stdlib_error.html"},{"title":"stdlib_quadrature – Fortran-lang/stdlib","text":"( Specification ) Uses stdlib_kinds module~~stdlib_quadrature~~UsesGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_quadrature_gauss stdlib_quadrature_simps stdlib_quadrature_trapz module~~stdlib_quadrature~~UsedByGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_gauss stdlib_quadrature_gauss module~stdlib_quadrature_gauss->module~stdlib_quadrature module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces gauss_legendre gauss_legendre_lobatto simps simps_weights trapz trapz_weights Interfaces public interface gauss_legendre Computes Gauss-Legendre quadrature nodes and weights. public pure subroutine gauss_legendre_fp64(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(out) :: w (:) real(kind=dp), intent(in), optional :: interval (2) public interface gauss_legendre_lobatto Computes Gauss-Legendre-Lobatto quadrature nodes and weights. public pure subroutine gauss_legendre_lobatto_fp64(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(out) :: w (:) real(kind=dp), intent(in), optional :: interval (2) public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp) public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x)) public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp) public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"module/stdlib_quadrature.html"},{"title":"stdlib_kinds – Fortran-lang/stdlib","text":"Uses iso_fortran_env iso_fortran_env iso_c_binding module~~stdlib_kinds~~UsesGraph module~stdlib_kinds stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_kinds~~UsedByGraph module~stdlib_kinds stdlib_kinds module~stdlib_bitsets stdlib_bitsets module~stdlib_bitsets->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_optval->module~stdlib_kinds module~stdlib_sorting stdlib_sorting module~stdlib_sorting->module~stdlib_kinds module~stdlib_string_type stdlib_string_type module~stdlib_sorting->module~stdlib_string_type module~stdlib_ascii stdlib_ascii module~stdlib_ascii->module~stdlib_kinds module~stdlib_stats_distribution_prng stdlib_stats_distribution_PRNG module~stdlib_stats_distribution_prng->module~stdlib_kinds module~stdlib_error stdlib_error module~stdlib_stats_distribution_prng->module~stdlib_error module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature->module~stdlib_kinds module~stdlib_math stdlib_math module~stdlib_math->module~stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_string_type->module~stdlib_ascii module~stdlib_stats stdlib_stats module~stdlib_stats->module~stdlib_kinds module~stdlib_specialfunctions stdlib_specialfunctions module~stdlib_specialfunctions->module~stdlib_kinds module~stdlib_linalg stdlib_linalg module~stdlib_linalg->module~stdlib_kinds module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_kinds module~stdlib_io->module~stdlib_optval module~stdlib_io->module~stdlib_ascii module~stdlib_io->module~stdlib_error module~stdlib_math_logspace stdlib_math_logspace module~stdlib_math_logspace->module~stdlib_math module~stdlib_sorting_sort stdlib_sorting_sort module~stdlib_sorting_sort->module~stdlib_sorting module~stdlib_quadrature_gauss stdlib_quadrature_gauss module~stdlib_quadrature_gauss->module~stdlib_quadrature module~stdlib_quadrature_gauss->module~stdlib_specialfunctions module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_linalg_outer_product stdlib_linalg_outer_product module~stdlib_linalg_outer_product->module~stdlib_linalg module~stdlib_sorting_ord_sort stdlib_sorting_ord_sort module~stdlib_sorting_ord_sort->module~stdlib_sorting module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_stats module~stdlib_stats_moment->module~stdlib_error module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_optval module~stdlib_logger->module~stdlib_ascii module~stdlib_bitsets_64 stdlib_bitsets_64 module~stdlib_bitsets_64->module~stdlib_bitsets module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_stats module~stdlib_stats_mean->module~stdlib_error module~stdlib_sorting_sort_index stdlib_sorting_sort_index module~stdlib_sorting_sort_index->module~stdlib_sorting module~stdlib_stats_moment_mask stdlib_stats_moment_mask module~stdlib_stats_moment_mask->module~stdlib_optval module~stdlib_stats_moment_mask->module~stdlib_stats module~stdlib_stats_moment_mask->module~stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats_cov->module~stdlib_stats module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_var->module~stdlib_error module~stdlib_stats_moment_scalar stdlib_stats_moment_scalar module~stdlib_stats_moment_scalar->module~stdlib_optval module~stdlib_stats_moment_scalar->module~stdlib_stats module~stdlib_stats_moment_scalar->module~stdlib_error module~stdlib_bitsets_large stdlib_bitsets_large module~stdlib_bitsets_large->module~stdlib_bitsets module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_strings stdlib_strings module~stdlib_strings->module~stdlib_optval module~stdlib_strings->module~stdlib_ascii module~stdlib_strings->module~stdlib_string_type module~stdlib_error->module~stdlib_optval module~stdlib_specialfunctions_legendre stdlib_specialfunctions_legendre module~stdlib_specialfunctions_legendre->module~stdlib_specialfunctions module~stdlib_stats_moment_all stdlib_stats_moment_all module~stdlib_stats_moment_all->module~stdlib_optval module~stdlib_stats_moment_all->module~stdlib_stats module~stdlib_stats_moment_all->module~stdlib_error module~stdlib_math_linspace stdlib_math_linspace module~stdlib_math_linspace->module~stdlib_math module~estop estop module~estop->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lk Variables Type Visibility Attributes Name Initial integer, public, parameter :: lk = kind(.true.)","tags":"","loc":"module/stdlib_kinds.html"},{"title":"stdlib_sorting – Fortran-lang/stdlib","text":"This module implements overloaded sorting subroutines named ORD_SORT , SORT_INDEX , and SORT , that each can be used to sort four kinds\n of INTEGER arrays, three kinds of REAL arrays, character(len=*) arrays,\n and arrays of type(string_type) .\n ( Specification ) By default sorting is in order of \n increasing value, but there is an option to sort in decreasing order. \n All the subroutines have worst case run time performance of O(N Ln(N)) , \n but on largely sorted data ORD_SORT and SORT_INDEX can have a run time \n performance of O(N) . ORD_SORT is a translation of the \"Rust\" sort sorting algorithm in slice.rs :\n https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs\n which in turn is inspired by the timsort algorithm of Tim Peters,\n http://svn.python.org/projects/python/trunk/Objects/listsort.txt. ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\n and insertion sort . It is always at worst O(N Ln(N)) in sorting random\n data, having a performance about 25% slower than SORT on such\n data, but has much better performance than SORT on partially\n sorted data, having O(N) performance on uniformly non-increasing or\n non-decreasing data. SORT_INDEX is a modification of ORD_SORT so that in addition to\n sorting the input array, it returns the indices that map to a\n stable sort of the original array. These indices are\n intended to be used to sort data that is correlated with the input\n array, e.g., different arrays in a database, different columns of a\n rank 2 array, different elements of a derived type. It is less\n efficient than ORD_SORT at sorting a simple array. SORT uses the INTROSORT sorting algorithm of David Musser,\n http://www.cs.rpi.edu/~musser/gp/introsort.ps. introsort is a hybrid\n unstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm is always O(N Ln(N)) it is relatively\n fast on randomly ordered data, but inconsistent in performance on partly\n sorted data, sometimes having merge sort performance, sometimes having\n better than quicksort performance. UNORD_SOORT is about 25%\n more efficient than ORD_SORT at sorting purely random data, but af an\n order of Ln(N) less efficient at sorting partially sorted data. Version: experimental The generic subroutine implementing the ORD_SORT algorithm to return\n an input array with its elements sorted in order of (non-)decreasing\n value. Its use has the syntax: call ord_sort( array[, work, reverse] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) . If both the \n   type of array is real and at least one of the elements is a NaN , then the ordering of the result is undefined. Otherwise it \n   is defined to be the original elements in non-decreasing order. work (optional): shall be a rank 1 array of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as \"scratch\" memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in stable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in stable order. Example ... ! Read arrays from sorted files call read_sorted_file ( 'dummy_file1' , array1 ) call read_sorted_file ( 'dummy_file2' , array2 ) ! Concatenate the arrays allocate ( array ( size ( array1 ) + size ( array2 ) ) ) array ( 1 : size ( array1 ) ) = array1 (:) array ( size ( array1 ) + 1 : size ( array1 ) + size ( array2 ) ) = array2 (:) ! Sort the resulting array call ord_sort ( array , work ) ! Process the sorted array call array_search ( array , values ) ... Version: experimental The generic subroutine implementing the SORT algorithm to return\n an input array with its elements sorted in order of (non-)decreasing\n value. Its use has the syntax: call sort( array[, reverse] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) . If both the type\n   of array is real and at least one of the elements is a NaN , then\n   the ordering of the result is undefined. Otherwise it is defined to be the\n   original elements in non-decreasing order. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in unstable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in unstable order. Example ... ! Read random data from a file call read_file ( 'dummy_file' , array ) ! Sort the random data call sort ( array ) ! Process the sorted data call array_search ( array , values ) ... Version: experimental The generic subroutine implementing the SORT_INDEX algorithm to\n return an index array whose elements would sort the input array in the\n desired direction. It is primarily intended to be used to sort a\n derived type array based on the values of a component of the array.\n Its use has the syntax: call sort_index( array, index[, work, iwork, reverse ] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) . If both the \n   type of array is real and at least one of the elements is a NaN , \n   then the ordering of the array and index results is undefined. \n   Otherwise it is defined to be as specified by reverse. index: a rank 1 array of sorting indices. It is an intent(out) argument of the type integer(int_size) . Its size shall be the\n   same as array . On return, if defined, its elements would\n   sort the input array in the direction specified by reverse . work (optional): shall be a rank 1 array of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as \"scratch\" memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. iwork (optional): shall be a rank 1 integer array of kind int_size ,\n   and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as \"scratch\" memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then index will sort array in order of non-increasing values in stable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in stable order. Examples Sorting a related rank one array: subroutine sort_related_data ( a , b , work , index , iwork ) ! Sort `b` in terms or its related array `a` integer , intent ( inout ) :: a (:) integer ( int32 ), intent ( inout ) :: b (:) ! The same size as a integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) ! Find the indices to sort a call sort_index ( a , index ( 1 : size ( a )),& work ( 1 : size ( a ) / 2 ), iwork ( 1 : size ( a ) / 2 )) ! Sort b based on the sorting of a b (:) = b ( index ( 1 : size ( a )) ) end subroutine sort_related_data Sorting a rank 2 array based on the data in a column subroutine sort_related_data ( array , column , work , index , iwork ) ! Sort `a_data` in terms or its component `a` integer , intent ( inout ) :: a (:,:) integer ( int32 ), intent ( in ) :: column integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) integer , allocatable :: dummy (:) integer :: i allocate ( dummy ( size ( a , dim = 1 ))) ! Extract a component of `a_data` dummy (:) = a (:, column ) ! Find the indices to sort the column call sort_index ( dummy , index ( 1 : size ( dummy )),& work ( 1 : size ( dummy ) / 2 ), iwork ( 1 : size ( dummy ) / 2 )) ! Sort a based on the sorting of its column do i = 1 , size ( a , dim = 2 ) a (:, i ) = a ( index ( 1 : size ( a , dim = 1 )), i ) end do end subroutine sort_related_data Sorting an array of a derived type based on the dsta in one component subroutine sort_a_data ( a_data , a , work , index , iwork ) ! Sort `a_data` in terms or its component `a` type ( a_type ), intent ( inout ) :: a_data (:) integer ( int32 ), intent ( inout ) :: a (:) integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) ! Extract a component of `a_data` a ( 1 : size ( a_data )) = a_data (:) % a ! Find the indices to sort the component call sort_index ( a ( 1 : size ( a_data )), index ( 1 : size ( a_data )),& work ( 1 : size ( a_data ) / 2 ), iwork ( 1 : size ( a_data ) / 2 )) ! Sort a_data based on the sorting of that component a_data (:) = a_data ( index ( 1 : size ( a_data )) ) end subroutine sort_a_data Uses stdlib_kinds stdlib_string_type module~~stdlib_sorting~~UsesGraph module~stdlib_sorting stdlib_sorting module~stdlib_string_type stdlib_string_type module~stdlib_sorting->module~stdlib_string_type module~stdlib_kinds stdlib_kinds module~stdlib_sorting->module~stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_ascii stdlib_ascii module~stdlib_string_type->module~stdlib_ascii iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_ascii->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_sorting_ord_sort stdlib_sorting_sort stdlib_sorting_sort_index module~~stdlib_sorting~~UsedByGraph module~stdlib_sorting stdlib_sorting module~stdlib_sorting_sort_index stdlib_sorting_sort_index module~stdlib_sorting_sort_index->module~stdlib_sorting module~stdlib_sorting_sort stdlib_sorting_sort module~stdlib_sorting_sort->module~stdlib_sorting module~stdlib_sorting_ord_sort stdlib_sorting_ord_sort module~stdlib_sorting_ord_sort->module~stdlib_sorting Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables int_size Interfaces ord_sort sort sort_index Variables Type Visibility Attributes Name Initial integer, public, parameter :: int_size = int64 Integer kind for indexing Interfaces public interface ord_sort The generic subroutine interface implementing the ORD_SORT algorithm,\n a translation to Fortran 2008, of the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\n and insertion sort .\n ( Specification ) Read more… public subroutine char_ord_sort(array, work, reverse) char_ord_sort( array[, work, reverse] ) sorts the input ARRAY of type CHARACTER(*) using a hybrid sort based on the 'Rust\" sort algorithm\n found in slice.rs Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len(array)), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine dp_ord_sort(array, work, reverse) dp_ord_sort( array ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int16_ord_sort(array, work, reverse) int16_ord_sort( array ) sorts the input ARRAY of type integer(int16) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) integer(kind=int16), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int32_ord_sort(array, work, reverse) int32_ord_sort( array ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int64_ord_sort(array, work, reverse) int64_ord_sort( array ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine int8_ord_sort(array, work, reverse) int8_ord_sort( array ) sorts the input ARRAY of type integer(int8) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) integer(kind=int8), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine qp_ord_sort(array, work, reverse) qp_ord_sort( array ) sorts the input ARRAY of type real(qp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) real(kind=qp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine sp_ord_sort(array, work, reverse) sp_ord_sort( array ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public subroutine string_type_ord_sort(array, work, reverse) string_type_ord_sort( array ) sorts the input ARRAY of type type(string_type) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) type( string_type ), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse public interface sort The generic subroutine interface implementing the SORT algorithm, based\n on the introsort of David Musser.\n ( Specification ) public pure subroutine char_sort(array, reverse) char_sort( array[, reverse] ) sorts the input ARRAY of type CHARACTER(*) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine dp_sort(array, reverse) dp_sort( array[, reverse] ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int16_sort(array, reverse) int16_sort( array[, reverse] ) sorts the input ARRAY of type integer(int16) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int32_sort(array, reverse) int32_sort( array[, reverse] ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int64_sort(array, reverse) int64_sort( array[, reverse] ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine int8_sort(array, reverse) int8_sort( array[, reverse] ) sorts the input ARRAY of type integer(int8) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine qp_sort(array, reverse) qp_sort( array[, reverse] ) sorts the input ARRAY of type real(qp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine sp_sort(array, reverse) sp_sort( array[, reverse] ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public pure subroutine string_type_sort(array, reverse) string_type_sort( array[, reverse] ) sorts the input ARRAY of type type(string_type) using a hybrid sort based on the introsort of David Musser.\n The algorithm is of order O(N Ln(N)) for all inputs.\n Because it relies on quicksort , the coefficient of the O(N Ln(N))\n behavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) logical, intent(in), optional :: reverse public interface sort_index The generic subroutine interface implementing the SORT_INDEX algorithm,\n based on the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\n but modified to return an array of indices that would provide a stable\n sort of the rank one ARRAY input.\n ( Specification ) Read more… public subroutine char_sort_index(array, index, work, iwork, reverse) char_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type CHARACTER(*) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) character(len=len(array)), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine dp_sort_index(array, index, work, iwork, reverse) dp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(dp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int16_sort_index(array, index, work, iwork, reverse) int16_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int16) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int16), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int32_sort_index(array, index, work, iwork, reverse) int32_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int32) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int64_sort_index(array, index, work, iwork, reverse) int64_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int64) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine int8_sort_index(array, index, work, iwork, reverse) int8_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type integer(int8) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) integer(kind=int8), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine qp_sort_index(array, index, work, iwork, reverse) qp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(qp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=qp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine sp_sort_index(array, index, work, iwork, reverse) sp_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type real(sp) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse public subroutine string_type_sort_index(array, index, work, iwork, reverse) string_type_sort_index( array, index[, work, iwork, reverse] ) sorts\n an input ARRAY of type type(string_type) using a hybrid sort based on the 'Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\n order that would sort the input ARRAY` in the desired direction. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: array (0:) integer(kind=int_size), intent(out) :: index (0:) type( string_type ), intent(out), optional :: work (0:) integer(kind=int_size), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse","tags":"","loc":"module/stdlib_sorting.html"},{"title":"stdlib_math – Fortran-lang/stdlib","text":"Uses stdlib_kinds module~~stdlib_math~~UsesGraph module~stdlib_math stdlib_math module~stdlib_kinds stdlib_kinds module~stdlib_math->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_math_linspace stdlib_math_logspace module~~stdlib_math~~UsedByGraph module~stdlib_math stdlib_math module~stdlib_math_logspace stdlib_math_logspace module~stdlib_math_logspace->module~stdlib_math module~stdlib_math_linspace stdlib_math_linspace module~stdlib_math_linspace->module~stdlib_math Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables DEFAULT_LINSPACE_LENGTH DEFAULT_LOGSPACE_BASE DEFAULT_LOGSPACE_LENGTH EULERS_NUMBER_DP EULERS_NUMBER_QP EULERS_NUMBER_SP Interfaces clip linspace logspace Variables Type Visibility Attributes Name Initial integer, public, parameter :: DEFAULT_LINSPACE_LENGTH = 100 integer, public, parameter :: DEFAULT_LOGSPACE_BASE = 10 integer, public, parameter :: DEFAULT_LOGSPACE_LENGTH = 50 real(kind=dp), public, parameter :: EULERS_NUMBER_DP = exp(1.0_dp) real(kind=qp), public, parameter :: EULERS_NUMBER_QP = exp(1.0_qp) real(kind=sp), public, parameter :: EULERS_NUMBER_SP = exp(1.0_sp) Interfaces public interface clip private elemental function clip_int8(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x integer(kind=int8), intent(in) :: xmin integer(kind=int8), intent(in) :: xmax Return Value integer(kind=int8) private elemental function clip_int16(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x integer(kind=int16), intent(in) :: xmin integer(kind=int16), intent(in) :: xmax Return Value integer(kind=int16) private elemental function clip_int32(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: xmin integer(kind=int32), intent(in) :: xmax Return Value integer(kind=int32) private elemental function clip_int64(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: xmin integer(kind=int64), intent(in) :: xmax Return Value integer(kind=int64) private elemental function clip_sp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x real(kind=sp), intent(in) :: xmin real(kind=sp), intent(in) :: xmax Return Value real(kind=sp) private elemental function clip_dp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: xmin real(kind=dp), intent(in) :: xmax Return Value real(kind=dp) private elemental function clip_qp(x, xmin, xmax) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x real(kind=qp), intent(in) :: xmin real(kind=qp), intent(in) :: xmax Return Value real(kind=qp) public interface linspace Create rank 1 array of linearly spaced elements\n If the number of elements is not specified, create an array with size 100. If n is a negative value,\n return an array with size 0. If n = 1, return an array whose only element is end\n( Specification ) Read more… public function linspace_default_1_cdp_cdp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end Return Value complex(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_cqp_cqp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end Return Value complex(kind=qp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_csp_csp(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end Return Value complex(kind=sp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint16_iint16(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint32_iint32(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint64_iint64(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_iint8_iint8(start, end) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rdp_rdp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rqp_rqp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_default_1_rsp_rsp(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp)\n  (DEFAULT_LINSPACE_LENGTH) public function linspace_n_1_cdp_cdp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=dp)\n  (n) public function linspace_n_1_cqp_cqp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=qp)\n  (n) public function linspace_n_1_csp_csp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=sp)\n  (n) public function linspace_n_1_iint16_iint16(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint32_iint32(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint64_iint64(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_iint8_iint8(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_rdp_rdp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function linspace_n_1_rqp_rqp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=qp)\n  (n) public function linspace_n_1_rsp_rsp(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=sp)\n  (n) public interface logspace Create rank 1 array of logarithmically spaced elements from base start to base end.\n If the number of elements is not specified, create an array with size 50. If n is a negative value,\n return an array with size 0. If n = 1, return an array whose only element is base**end. If no base\n is specified, logspace will default to using a base of 10 Read more… public function logspace_1_cdp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end Return Value complex(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_cdp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cdp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: start complex(kind=dp), intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_cqp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end Return Value complex(kind=qp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_cqp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_cqp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: start complex(kind=qp), intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_csp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end Return Value complex(kind=sp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_csp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_csp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: start complex(kind=sp), intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_iint32_default(start, end) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_iint32_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function logspace_1_iint32_n_cdpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value complex(kind=dp)\n  (n) public function logspace_1_iint32_n_cqpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value complex(kind=qp)\n  (n) public function logspace_1_iint32_n_cspbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value complex(kind=sp)\n  (n) public function logspace_1_iint32_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value integer\n  (n) public function logspace_1_iint32_n_rdpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_iint32_n_rqpbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_iint32_n_rspbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rdp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rdp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n complex(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rdp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: n real(kind=dp), intent(in) :: base Return Value real(kind=dp)\n  (n) public function logspace_1_rqp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rqp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n complex(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rqp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: n real(kind=qp), intent(in) :: base Return Value real(kind=qp)\n  (n) public function logspace_1_rsp_default(start, end) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp)\n  (DEFAULT_LOGSPACE_LENGTH) public function logspace_1_rsp_n(start, end, n) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_cbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n complex(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_ibase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n integer, intent(in) :: base Return Value real(kind=sp)\n  (n) public function logspace_1_rsp_n_rbase(start, end, n, base) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: n real(kind=sp), intent(in) :: base Return Value real(kind=sp)\n  (n)","tags":"","loc":"module/stdlib_math.html"},{"title":"stdlib_bitsets_64 – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_bitsets module~~stdlib_bitsets_64~~UsesGraph module~stdlib_bitsets_64 stdlib_bitsets_64 module~stdlib_bitsets stdlib_bitsets module~stdlib_bitsets_64->module~stdlib_bitsets module~stdlib_kinds stdlib_kinds module~stdlib_bitsets->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_bitsets->iso_fortran_env module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_bitsets_64.html"},{"title":"stdlib_stats_corr – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_linalg stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_corr~~UsesGraph module~stdlib_stats_corr stdlib_stats_corr module~stdlib_optval stdlib_optval module~stdlib_stats_corr->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_corr->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats stdlib_stats module~stdlib_stats_corr->module~stdlib_stats module~stdlib_linalg stdlib_linalg module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_stats->module~stdlib_kinds module~stdlib_linalg->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_corr.html"},{"title":"stdlib_stats_cov – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_cov~~UsesGraph module~stdlib_stats_cov stdlib_stats_cov module~stdlib_error stdlib_error module~stdlib_stats_cov->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_cov->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_cov->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_cov->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_cov.html"},{"title":"stdlib_stats_moment – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment~~UsesGraph module~stdlib_stats_moment stdlib_stats_moment module~stdlib_error stdlib_error module~stdlib_stats_moment->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_moment->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_moment->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment.html"},{"title":"stdlib_stats_moment_all – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment_all~~UsesGraph module~stdlib_stats_moment_all stdlib_stats_moment_all module~stdlib_error stdlib_error module~stdlib_stats_moment_all->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_moment_all->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment_all->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_moment_all->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment_all.html"},{"title":"stdlib_math_logspace – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_math module~~stdlib_math_logspace~~UsesGraph module~stdlib_math_logspace stdlib_math_logspace module~stdlib_math stdlib_math module~stdlib_math_logspace->module~stdlib_math module~stdlib_kinds stdlib_kinds module~stdlib_math->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_math_logspace.html"},{"title":"stdlib_math_linspace – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_math module~~stdlib_math_linspace~~UsesGraph module~stdlib_math_linspace stdlib_math_linspace module~stdlib_math stdlib_math module~stdlib_math_linspace->module~stdlib_math module~stdlib_kinds stdlib_kinds module~stdlib_math->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_math_linspace.html"},{"title":"stdlib_specialfunctions_legendre – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_specialfunctions module~~stdlib_specialfunctions_legendre~~UsesGraph module~stdlib_specialfunctions_legendre stdlib_specialfunctions_legendre module~stdlib_specialfunctions stdlib_specialfunctions module~stdlib_specialfunctions_legendre->module~stdlib_specialfunctions module~stdlib_kinds stdlib_kinds module~stdlib_specialfunctions->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_specialfunctions_legendre.html"},{"title":"stdlib_bitsets_large – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_bitsets module~~stdlib_bitsets_large~~UsesGraph module~stdlib_bitsets_large stdlib_bitsets_large module~stdlib_bitsets stdlib_bitsets module~stdlib_bitsets_large->module~stdlib_bitsets module~stdlib_kinds stdlib_kinds module~stdlib_bitsets->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_bitsets->iso_fortran_env module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_bitsets_large.html"},{"title":"stdlib_sorting_ord_sort – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_sorting module~~stdlib_sorting_ord_sort~~UsesGraph module~stdlib_sorting_ord_sort stdlib_sorting_ord_sort module~stdlib_sorting stdlib_sorting module~stdlib_sorting_ord_sort->module~stdlib_sorting module~stdlib_string_type stdlib_string_type module~stdlib_sorting->module~stdlib_string_type module~stdlib_kinds stdlib_kinds module~stdlib_sorting->module~stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_ascii stdlib_ascii module~stdlib_string_type->module~stdlib_ascii iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_ascii->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_sorting_ord_sort.html"},{"title":"stdlib_stats_moment_scalar – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment_scalar~~UsesGraph module~stdlib_stats_moment_scalar stdlib_stats_moment_scalar module~stdlib_error stdlib_error module~stdlib_stats_moment_scalar->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_moment_scalar->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment_scalar->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_moment_scalar->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment_scalar.html"},{"title":"stdlib_sorting_sort – Fortran-lang/stdlib","text":"This submodule implements the overloaded sorting subroutine SORT that can be used to sort four kinds of INTEGER arrays and three kinds\n of REAL arrays. Sorting is in order of increasing value, with the worst\n case run time performance of O(N Ln(N)) . SORT uses the INTROSORT sorting algorithm of David Musser,\n http://www.cs.rpi.edu/~musser/gp/introsort.ps. introsort is a hybrid\n unstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm is always O(N Ln(N)) it is relatively\n fast on randomly ordered data, but inconsistent in performance on partly\n sorted data, sometimes having merge sort performance, sometimes having\n better than quicksort performance. Uses Ancestors: stdlib_sorting module~~stdlib_sorting_sort~~UsesGraph module~stdlib_sorting_sort stdlib_sorting_sort module~stdlib_sorting stdlib_sorting module~stdlib_sorting_sort->module~stdlib_sorting module~stdlib_string_type stdlib_string_type module~stdlib_sorting->module~stdlib_string_type module~stdlib_kinds stdlib_kinds module~stdlib_sorting->module~stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_ascii stdlib_ascii module~stdlib_string_type->module~stdlib_ascii iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_ascii->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_sorting_sort.html"},{"title":"stdlib_quadrature_simps – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_simps~~UsesGraph module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_error stdlib_error module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_simps.html"},{"title":"stdlib_linalg_diag – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_linalg module~~stdlib_linalg_diag~~UsesGraph module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg stdlib_linalg module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_linalg_diag.html"},{"title":"stdlib_quadrature_gauss – Fortran-lang/stdlib","text":"Uses stdlib_specialfunctions Ancestors: stdlib_quadrature module~~stdlib_quadrature_gauss~~UsesGraph module~stdlib_quadrature_gauss stdlib_quadrature_gauss module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_gauss->module~stdlib_quadrature module~stdlib_specialfunctions stdlib_specialfunctions module~stdlib_quadrature_gauss->module~stdlib_specialfunctions module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds module~stdlib_specialfunctions->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_gauss.html"},{"title":"stdlib_stats_moment_mask – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment_mask~~UsesGraph module~stdlib_stats_moment_mask stdlib_stats_moment_mask module~stdlib_error stdlib_error module~stdlib_stats_moment_mask->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_moment_mask->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment_mask->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_moment_mask->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment_mask.html"},{"title":"stdlib_stats_mean – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_mean~~UsesGraph module~stdlib_stats_mean stdlib_stats_mean module~stdlib_error stdlib_error module~stdlib_stats_mean->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_mean->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_mean->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_mean->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_mean.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~~UsesGraph module~estop estop module~stdlib_error stdlib_error module~estop->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop.html"},{"title":"stdlib_quadrature_trapz – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_trapz~~UsesGraph module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_error stdlib_error module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_trapz.html"},{"title":"stdlib_stats_var – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_var~~UsesGraph module~stdlib_stats_var stdlib_stats_var module~stdlib_error stdlib_error module~stdlib_stats_var->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_var->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_var->ieee_arithmetic module~stdlib_stats stdlib_stats module~stdlib_stats_var->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_var.html"},{"title":"stdlib_linalg_outer_product – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_linalg module~~stdlib_linalg_outer_product~~UsesGraph module~stdlib_linalg_outer_product stdlib_linalg_outer_product module~stdlib_linalg stdlib_linalg module~stdlib_linalg_outer_product->module~stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_linalg_outer_product.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~2~~UsesGraph module~estop~2 estop module~stdlib_error stdlib_error module~estop~2->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop~2.html"},{"title":"stdlib_sorting_sort_index – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_sorting module~~stdlib_sorting_sort_index~~UsesGraph module~stdlib_sorting_sort_index stdlib_sorting_sort_index module~stdlib_sorting stdlib_sorting module~stdlib_sorting_sort_index->module~stdlib_sorting module~stdlib_string_type stdlib_string_type module~stdlib_sorting->module~stdlib_string_type module~stdlib_kinds stdlib_kinds module~stdlib_sorting->module~stdlib_kinds module~stdlib_string_type->module~stdlib_kinds module~stdlib_ascii stdlib_ascii module~stdlib_string_type->module~stdlib_ascii iso_c_binding iso_c_binding module~stdlib_kinds->iso_c_binding iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_ascii->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_sorting_sort_index.html"},{"title":"Contributing and specs – Fortran-lang/stdlib","text":"Warning This page is currently under construction! Todo Improve the title of this FORD \"pages\" section, and\nimprove the organization of pages\nto separate end-user, high-level documentation and examples from developer documentation and specs.","tags":"","loc":"page//index.html"},{"title":"Fortran stdlib License (MIT) – Fortran-lang/stdlib","text":"MIT License Copyright (c) 2019 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Contributing – Fortran-lang/stdlib","text":"This page aims to provide information that are useful for stdlib contributors.\nIssues can be reported on GitHub .","tags":"","loc":"page/contributing/index.html"},{"title":"Contributor Code of Conduct – Fortran-lang/stdlib","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age,\nbody size, disability, ethnicity, gender identity and expression, level of\nexperience, nationality, personal appearance, race, religion, or sexual\nidentity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment\ninclude: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or\nadvances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic\n  address, without explicit permission Other conduct which could reasonably be considered inappropriate in a\n  professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may\nbe further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing or otherwise unacceptable behavior may be\nreported by contacting one of the project maintainers at caomaco@gmail.com or \nondrej@certik.us. All complaints will be reviewed and investigated and will\nresult in a response that is deemed necessary and appropriate to the\ncircumstances. The project team is obligated to maintain confidentiality with\nregard to the reporter of an incident. Further details of specific enforcement\npolicies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4,\navailable at https://contributor-covenant.org/version/1/4","tags":"","loc":"page/contributing/CodeOfConduct.html"},{"title":"Style Guide – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Fortran stdlib Style Guide Use (modern) standard Fortran File naming conventions Indentation & whitespace Variable and procedure naming Attributes End  block closing statements Document public API code with FORD Fortran stdlib Style Guide Adopting a consistent style can improve code legibility through the choice of good naming conventions.\nIn addition, style checks will be run during CI to flag any severe non-conformance.\nThis allows code review discussions to focus on semantics and substance rather than pedantry.\nConsistent whitespace usage, and not polluting line endings with trailing white space makes git diff s considerably more legible.\nThis style guide is a living document and proposed changes may be adopted after discussing them and coming to a consensus. Use (modern) standard Fortran Do not use obsolescent or deleted language features\n  E.g., common , pause , entry , arithmetic if and computed goto Do not use vendor extensions in the form of non-standard syntax and vendor supplied intrinsic procedures\n  E.g., real*8 or etime() File naming conventions Source files should contain at most one program , module , or submodule The filename should match the program or module name and have the file extension .f90 or .F90 if preprocessing is required If the interface and implementation is split using submodules the implementation submodule file should have the same name as the\n  interface (parent) module but end in _implementation E.g., string_class.f90 and string_class_implementation.f90 Tests should be added in the tests subdirectory and have the same name as the module they are testing with the test_ prefix\n  added\n  E.g., string_class.f90 and tests/test_string_class.f90 Indentation & whitespace By setting and following a convention for indentation and whitespace, code reviews and git-diffs can\nfocus on the semantics of the proposed changes rather than style and formatting. The body of every Fortran construct should be indented by four (4) spaces Line length should be limited to 80 characters and must not exceed 132 Please do not use Tab characters for indentation Please remove trailing white space before committing code Variable and procedure naming Variable and procedure names, as well as Fortran keywords, should be written in lowercase Variable and procedure names should be made up of one or more full words separated by an underscore,\n  for example has_failed is preferred over hasfailed Where conventional and appropriate shortening of a word is used then the underscore may be omitted,\n  for example linspace is preferred over lin_space Attributes Always specify intent for dummy arguments. Don't use dimension attribute to declare arrays because it is more verbose.\n  Use this: real, allocatable :: a(:), b(:,:) instead of: real, dimension(:), allocatable :: a real, dimension(:,:), allocatable :: b When defining many arrays of the same dimension, dimension can be used as an exception if it makes the code less verbose. If the optional attribute is used to declare a dummy argument, it should follow the intent attribute. End block closing statements Fortran allows certain block constructs or scopes to include the name of the program unit in the end statement.\nThe convention adopted herein is to include procedure names, module names and program names in the end statement,\nunless the closing statement can reasonably be expected to be on the same screen or page, within about 25 lines. Document public API code with FORD Documentation strings should be provided for all public and protected entities and their arguments or parameters.\nThis is currently accomplished using the FORD tool .\nFor help writing FORD style documentation please see the FORD wiki .\nThe following two sections are most relevant for contributing new code: Writing Documentation Documentation Meta Data Limitations To write the \"spec\" (specification) for a new proposal, please place it in the FORD \"pages\" directory at doc/specs/ .\nTo get help please see the \"Writing Pages\" and \"Writing Documentation\" pages\non the FORD wiki .","tags":"","loc":"page/contributing/StyleGuide.html"},{"title":"Workflow for Contributors – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Workflow for the Fortran stdlib contributors This document describes our current workflow. We welcome everyone and anyone to participate and propose additions to stdlib.\nIt is okay if you do not have experience for specification or implementation,\nbut have an idea for stdlib. If the idea is popular among the community, more\nexperienced contributors will help it through all 5 steps. Idea : You have an idea or a proposal. Open an issue to discuss it. This\n   is on the level of \"is there interest in having image reader/writer\n   functions in stdlib?\" The goal of this step is to find out if the community\n   is interested in having this functionality as part of stdlib. API : When there seems to be significant interest in the proposal (vast\n   majority of participants think it is a good idea), move on to discuss the\n   specific API. It's OK to propose the API off the bat if you already have an\n   idea for it. This step is exploratory and its goal is to find out what the\n   API should look and feel like. Specification : Discuss the API and iterate. When there is vast majority\n   approval for the API, move on to implement it and submit a PR. Small PRs are\n   always better than large.  It is OK to implement only a few functions of a\n   new module, and continue work on the others in a later PR. All new\n   functionality goes into an \"experimental\" namespace\n   ( version: experimental ). As part of the PR, when submitting a new\n   public facing API, please provide the initial draft of the specification\n   document as well as the initial reference implementation of this\n   specification.  The specification is a document that describes the API and\n   the functionality, so that anyone can use it to create an implementation\n   from scratch without looking at stdlib . The stdlib library then provides\n   the reference implementation. Implementation in experimental: When opening a PR, request reviews from\n   one or more people that are most relevant to it. These are likely to be\n   people involved in prior steps of the workflow. Other contributors (not\n   explicitly invited) are encouraged to provide reviews and suggestions as\n   well. Iterate until all (or most) participants are on the same page.\n   A merge is permitted if there are unit tests for a majority of the possible\n   calling scenarios (with or without optional arguments, with arguments that\n   trigger an error) and if there is vast majority approval of the PR. Release : Moving from experimental to release. The experimental\n   \"namespace\" contains new functionality together with its specification. In\n   order to move from experimental to release, the specification document must\n   be approved by the wide community and the standards committee (informally).\n   If that happens, it has now been blessed for broad use and we can move the\n   code into the main section of stdlib , and the particular specification\n   document becomes part of the Fortran Standard Library. Note: the general term \"vast majority\" above means at least 80%, but ultimately\nit is left to our best judgement to ensure that the community agrees that each\nPR and proposal was approved by \"vast majority\". You are welcome to propose changes to this workflow by opening an issue . Build system This project supports two build systems right now, CMake and make.\nEventually, stdlib will be using the Fortran package manager\n( fpm ) as build system as well.\nThe effort of supporting fpm is tracked in issue #279 . CMake build files The build files for CMake allow both in-tree, i.e. build artifacts share\nthe same tree as the source files, and out-of-tree builds, i.e. build artifacts\nexist in a separate directory tree.\nBoth build types are explicitly supported and tested, the latter strategy\nis recommended for local development. Sources for the main library target are added in src/CMakeLists.txt relative to the library target, i.e. no absolute paths are required. To add tests, the macro ADDTEST should be used instead of the CMake function add_test , the macro hides creation of the executable target, linking against the \nmain library target and registering the test.\nThe tests themselves are defined as standalone executables in the subdirectories\nin src/tests , a new subdirectory with tests has to be registred in src/tests/CMakeLists.txt . The source tree should be considered read-only. References to PROJECT_SOURCE_DIR and CMAKE_CURRENT_SOURCE_DIR should only be used for accessing source files,\nnever to write build outputs, use PROJECT_BINARY_DIR and CMAKE_CURRENT_BINARY_DIR to write build artifacts instead.\nTo fully support in-tree builds, build artifacts must never have the same name as\nsource files to avoid accidentally overwriting them, e.g. when preprocessing or\nconfiguring a file. The CMAKE_INSTALL_PREFIX should only be written to on install, never in the build\nprocess. To install generated files, create a build output in the build tree and\ninstall it with the install function.\nThis project follows the GNU install conventions, this means that the variables CMAKE_INSTALL_BINDIR , CMAKE_INSTALL_LIBDIR , and CMAKE_INSTALL_INCLUDEDIR must be used instead of bin , lib , and include , respectively.\nLibrary targets should be exported on install to allow correct inclusion of the\nproject in other CMake projects.\nPrefer dashes as in project-config or project-targets over camel-case as in projectConfig or projectTarget for file names as the former allows easier\nconstruction from the PROJECT_NAME variable by concatenation. The project is usable as CMake subproject. Explicit references to CMAKE_SOURCE_DIR and CMAKE_BINARY_DIR must be avoided to not\nbreak subproject builds.\nAn example project is available here to test the CMake subproject integration. Make build files The build files for make are using the name Makefile.manual to\nnot conflict with the in-tree build of CMake.\nThis project uses recursive make to transverse the subdirectory structure\nfrom the top-level makefile, called Makefile.manual , and the build\nhappens in-tree, i.e. build artifacts are present along with the source code. New source files are added in src/Makefile.manual and include manual\ndependency definitions through the object files to allow parallel\ncompilation.\nTests are generated by the make include file src/tests/Makefile.manual.test.mk and defined in the subdirectories of the src/tests as entries in PROGS_SRC .\nNew subdirectories have to be explicitly added to src/tests/Makefile.manual or are ignored.","tags":"","loc":"page/contributing/Workflow.html"},{"title":"Specifications (specs) – Fortran-lang/stdlib","text":"Fortran stdlib Specifications (specs) This is and index/directory of the specifications (specs) for each new module/feature as described in the workflow document . Fortran stdlib Specifications (specs) Experimental Features & Modules Released/Stable Features & Modules Experimental Features & Modules ascii - Procedures for handling ASCII characters bitsets - Bitset data types and procedures error - Catching and handling errors IO - Input/output helper & convenience kinds - Kind parameters linalg - Linear Algebra logger - Runtime logging system math - General purpose mathematical functions optval - Fallback value for optional arguments quadrature - Numerical integration sorting - Sorting of rank one arrays stats - Descriptive Statistics stats_distribution_PRNG - Probability Distributions random number generator string_type - Basic string support strings - String handling and manipulation routines Released/Stable Features & Modules (None yet)","tags":"","loc":"page/specs/index.html"},{"title":"ASCII – Fortran-lang/stdlib","text":"The stdlib_ascii module The stdlib_ascii module Introduction Constants provided by stdlib_ascii Specification of the stdlib_ascii procedures to_lower Status Description Syntax Class Argument Result value Example to_upper Status Description Syntax Class Argument Result value Example to_title Status Description Syntax Class Argument Result value Example to_sentence Status Description Syntax Class Argument Result value Example reverse Status Description Syntax Class Argument Result value Example to_string Status Description Syntax Class Argument Result value Example Introduction The stdlib_ascii module provides procedures for handling and manipulating\nintrinsic character variables and constants. Constants provided by stdlib_ascii Note Specification of constants is currently incomplete. Specification of the stdlib_ascii procedures Note Specification of procedures is currently incomplete. to_lower Status Experimental Description Converts input character variable to all lowercase. Syntax res = to_lower (string) Class Pure function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example program demo_to_lower use stdlib_ascii , only : to_lower implicit none print '(a)' , to_lower ( \"HELLo!\" ) ! returns \"hello!\" end program demo_to_lower to_upper Status Experimental Description Converts input character variable to all uppercase. Syntax res = to_upper (string) Class Pure function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example program demo_to_upper use stdlib_ascii , only : to_upper implicit none print '(a)' , to_upper ( \"hello!\" ) ! returns \"HELLO!\" end program demo_to_upper to_title Status Experimental Description Returns the titlecase version of the input character variable. Title case: First character of every word in the sentence is converted to \nuppercase and the rest of the characters are converted to lowercase. A word is a contiguous sequence of character(s) which consists of alphabetical \ncharacter(s) and numeral(s) only and doesn't exclude any alphabetical character \nor numeral present next to either of its 2 ends. Syntax res = to_title (string) Class Pure function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example program demo_to_title use stdlib_ascii , only : to_title implicit none print * , to_title ( \"hello there!\" ) ! returns \"Hello There!\" print * , to_title ( \"'enquoted'\" ) ! returns \"'Enquoted'\" print * , to_title ( \"1st\" ) ! returns \"1st\" end program demo_to_title to_sentence Status Experimental Description Returns the sentencecase version of the input character variable. The first alphabetical character of the sequence is transformed to uppercase \nunless it follows a numeral. The rest of the characters in the sequence are \ntransformed to lowercase. Syntax res = to_sentence (string) Class Pure function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example program demo_to_sentence use stdlib_ascii , only : to_sentence implicit none print * , to_sentence ( \"hello!\" ) ! returns \"Hello!\" print * , to_sentence ( \"'enquoted'\" ) ! returns \"'Enquoted'\" print * , to_sentence ( \"1st\" ) ! returns \"1st\" end program demo_to_sentence reverse Status Experimental Description Reverses the order of all characters in the input character type. Syntax res = reverse (string) Class Pure function. Argument string : shall be an intrinsic character type. It is an intent(in) argument. Result value The result is an intrinsic character type of the same length as string . Example program demo_reverse use stdlib_ascii , only : reverse implicit none print '(a)' , reverse ( \"Hello, World!\" ) ! returns \"!dlroW ,olleH\" end program demo_reverse to_string Status Experimental Description Create a character string representing the value of the provided variable. Syntax res = to_string (string) Class Pure function. Argument val : shall be an intrinsic integer or logical type. It is an intent(in) argument. Result value The result is an intrinsic character type. Example program demo_string_value use stdlib_ascii , only : to_string implicit none print '(a)' , to_string ( - 3 ) ! returns \"-3\" print '(a)' , to_string (. true .) ! returns \"T\" print '(a)' , to_string ( 42 ) ! returns \"42\" end program demo_string_value","tags":"","loc":"page/specs/stdlib_ascii.html"},{"title":"Bitsets – Fortran-lang/stdlib","text":"The stdlib_bitsets module The stdlib_bitsets module Introduction The module's constants The stdlib_bitsets derived types The bitset-literal The binary-literal Summary of the module's operations Table of the bitset_type methods Table of the non-member procedure overloads Assignments Example Table of the non-member comparison operations Specification of the stdlib_bitsets methods and procedures all - determine whether all bits are set in self Status Description Syntax Class Argument Result value Example and - bitwise and of the bits of two bitsets Status Description Syntax Class Arguments Example and_not - Bitwise and of one bitset with the negation of another Status Description Syntax Class Arguments Example any - determine whether any bits are set Status Description Syntax Class Argument Result value Example bit_count - return the number of bits that are set Status Description Syntax Class Argument Result value Example bits - returns the number of bits Status Description Syntax Class Argument Result value Example clear - clears a sequence of one or more bits Status Description Syntax Class Arguments Example extract - create a new bitset from a range in an old bitset Status Description Syntax Class Arguments Example flip - flip the values of a sequence of one or more bits Status Description Syntax Class Arguments Example from_string - initializes a bitset from a binary literal Status Description Syntax Class Arguments Example init - bitset_type initialization routines Status Description Syntax Class Arguments Example input - reads a bitset from an unformatted file Status Description Syntax Class Arguments Example none - determines whether no bits are set Status Description Syntax Class Argument Result value Example not - Performs the logical complement on a bitset Status Description Syntax Class Argument Example or - Bitwise OR of the bits of two bitsets Status Description Syntax Class Arguments Example output - Writes a binary representation of a bitset to a file Status Description Syntax Class Arguments Example read_bitset - initializes self with the value of a bitset_literal Status Description Syntax Class Arguments Example set - sets a sequence of one or more bits to 1 Status Description Syntax Class Arguments Example test - determine whether a bit is set Status Descriptions Syntax Class Arguments Result value Example to_string - represent a bitset as a binary literal Status Description Syntax Class Arguments Example value - determine the value of a bit Status Description Syntax Class Arguments Result value Example write_bitset - writes a bitset-literal Status Description Syntax Class Arguments Example xor - bitwise exclusive or Status Description Syntax Class Arguments Example Specification of the stdlib_bitsets operators == - compare two bitsets to determine whether the bits have the same value Status Description Syntax Class Arguments Result value Example /= - compare two bitsets to determine whether any bits differ in value Status Description Syntax Class Arguments Result value Example &gt;= - compare two bitsets to determine whether the first is greater than or equal to the second Status Description Syntax Class Arguments Result value Example &gt; - compare two bitsets to determine whether the first is greater than the other Status Description Syntax Class Arguments Result value Example &lt;= - compare two bitsets to determine whether the first is less than or equal to the other Status Description Syntax Class Arguments Result value Example &lt; - compare two bitsets to determine whether the first is less than the other Status Description Syntax Class Arguments Result value Example Introduction The stdlib_bitsets module implements bitset types. A bitset is a\ncompact representation of a sequence of bits binary values. It can\nequivalently be considered as a sequence of logical values or as a\nsubset of the integers 0 ... bits-1 . For example, the value 1110 can be considered as defining the subset of integers [1, 2, 3].\nThe bits are indexed from 0 to bits(bitset)-1 .\nA bitset is used when space savings are critical in applications\nthat require a large number of closely related logical values.\nIt may also improve performance by reducing memory traffic. To\nimplement bitsets the module\ndefines three bitset types, multiple constants, a character string\nliteral that can be read to and from strings and formatted files, a\nsimple character string literal that can be read to and from strings,\nassignments, procedures, methods, and operators. Note that the module\nassumes two's complement integers, but all current Fortran 95 and later\nprocessors use such integers. Note that the module defines a number of \"binary\" procedures,\nprocedures with two bitset arguments. These arguments must be of the\nsame type and should have the same number of bits . For reasons of\nperformance the module does not enforce the bits constraint, but\nfailure to obey that constraint results in undefined behavior. This\nundefined behavior includes undefined values for those bits that\nexceed the defined number of bits in the smaller bitset. The\nundefined behavior may also include a \"segmentation fault\" for\nattempting to address bits in the smaller bitset, beyond the defined\nnumber of bits . Other problems are also possible. The module's constants The module defines several public integer constants, almost all\nintended to serve as error codes in reporting problems through an\noptional stat argument. One constant, bits_kind is\nthe integer kind value for indexing bits and reporting counts of\nbits. The other constants that are error codes are summarized below: Error Code Summary success No problems found alloc_fault Failure with a memory allocation array_size_invalid_error Attempt to define either negative bits or more than 64 bits in a bitset_64 char_string_invalid_error Invalid character found in a character string char_string_too_large_error Character string was too large to be encoded in the bitset char_string_too_small_error Character string was too small to hold the expected number of bits index_invalid_error Index to a bitstring was less than zero or greater than the number of bits integer_overflow_error Attempt to define an integer value bigger than huge(0_bits_kind) read_failure Failure on a read statement eof_failure An unexpected \"End-of-File\" on a read statement write_failure Failure on a write statement The stdlib_bitsets derived types The stdlib_bitsets module defines three derived types, bitset_type , bitset_64 , and bitset_large . bitset_type is an abstract\ntype that serves as the ancestor of bitset_64 and bitset_large . bitset_type defines one method, bits , and all of its\nother methods are deferred to its extensions. bitset_64 is a bitset\nthat can handle up to 64 bits. bitset_large is a bitset that can handle\nup huge(0_bits_kind) bits. All attributes of the bitset types are\nprivate. The various types each define a sequence of binary values: 0\nor 1. In some cases it is useful to associate a logical value, test ,\nfor each element of the sequence, where test is .true. if the value\nis 1 and .false. otherwise. The number of such values in an entity\nof that type is to be termed, bits . The bits are ordered in terms of\nposition, that, in turn, is indexed from 0 to bits-1 . bitset_type is\nused only as a class to define entities that can be either a bitset_64 or\na bitset_large . The syntax for using the types are: class( bitset_type ) :: variable type( bitset_64 ) :: variable and type( bitset_large ) :: variable The bitset-literal A bitset value may be represented as a bitset-literal-constant character string in source code or as a bitset-literal in\nformatted files and non-constant strings. bitset-literal-constant is ' bitset-literal '\n                          or \" bitset-literal \" bitset-literal is bitsize-literal binary-literal bitsize-literal is S digit [ digit ] ... binary-literal is B binary-digit [ binary-digit ] ... digit is 0\n        or 1\n        or 2\n        or 3\n        or 4\n        or 5\n        or 6\n        or 7\n        or 8\n        or 9 binary-digit is 0\n               or 1 The bitset-literal consists of two parts: a bitsize-literal and a binary-literal . The sequence of decimal digits that is part of the bitsize-literal is interpreted as the decimal value of bits .\nThe binary-literal value is interpreted as a sequence of bit\nvalues and there must be as many binary digits in the literal as there\nare bits . The sequence of binary digits are treated as if they were\nan unsigned integer with the i-th digit corresponding to the bits-i bit position. The binary-literal In defining the bitset-literal we also defined a binary-literal . While not suitable for file I/0, the binary-literal is suitable for transfer to and from character\nstrings. In that case the length of the string is the number of bits\nand all characters in the string must be either \"0\" or \"1\". Summary of the module's operations The stdlib_bitsets module defines a number of operations: \"unary\" methods of class bitset_type , \"binary\" procedure overloads of type bitset_64 or bitset_large , assignments, and \"binary\" comparison operators of type bitset_64 or bitset_large . Each category will be discussed separately. Table of the bitset_type methods The bitset_type class has a number of methods. All except one, bits ,\nare deferred. The methods consist of all procedures with one argument\nof class bitset_type . The procedures with two arguments of type bitset_64 or bitset_large are not methods and are\nsummarized in a separate table of procedures. The methods are\nsummarized below: Method name Class Summary all function .true. if all bits are 1, .false. otherwise any function .true. if any bits are 1, .false. otherwise bit_count function returns the number of bits that are 1 bits function returns the number of bits in the bitset clear subroutine sets a sequence of one or more bits to 0 flip subroutine flips the value of a sequence of one or more bits from_string subroutine reads the bitset from a string treating it as a binary literal init subroutine creates a new bitset of size bits with no bits set input subroutine reads a bitset from an unformatted I/O unit none function .true. if no bits are 1, .false. otherwise not subroutine performs a logical not operation on all the bits output subroutine writes a bitset to an unformatted I/O unit read_bitset subroutine reads a bitset from a bitset literal in a character string or formatted I/O unit set subroutine sets a sequence of one or more bits to 1 test function .true. if the bit at pos is 1, .false. otherwise to_string subroutine represents the bitset as a binary literal value function 1 if the bit at pos is 1, 0 otherwise write_bitset subroutine writes a bitset as a bitset literal to a  character string or formatted I/O unit Table of the non-member procedure overloads The procedures with two arguments of type bitset_large or bitset_64 must have both arguments of the same known type which\nprevents them from being methods. The bitwise \"logical\" procedures, and , and_not , or , and xor also require that the two bitset\narguments have the same number of bits, otherwise the results are\nundefined. These procedures are summarized in the following table: Procedure name Class Summary and elemental subroutine Sets self to the bitwise and of the original bits in self and set2 and_not elemental subroutine Sets self to the bitwise and of the original bits in self and the negation of set2 extract subroutine creates a new bitset, new , from a range in old or elemental subroutine Sets self to the bitwise or of the original bits in self and set2 xor elemental subroutine Sets self to the bitwise exclusive or of the original bits in self and set2 Assignments The module defines an assignment operation, = , that creates a\nduplicate of an original bitset. It also defines assignments to and\nfrom rank one arrays of logical type of kinds int8 , int16 , int32 , and int64 . In the assignment to and from logical arrays\narray index, i , is mapped to bit position, pos=i-1 , and .true. is mapped to a set bit, and .false. is mapped to an unset bit. Example program demo_assignment use stdlib_bitsets logical ( int8 ) :: logical1 ( 64 ) = . true . logical ( int32 ), allocatable :: logical2 (:) type ( bitset_64 ) :: set0 , set1 set0 = logical1 if ( set0 % bits () /= 64 ) then error stop procedure // & ' initialization with logical(int8) failed to set' // & ' the right size.' else if ( . not . set0 % all () ) then error stop procedure // ' initialization with' // & ' logical(int8) failed to set the right values.' else write ( * , * ) 'Initialization with logical(int8) succeeded.' end if set1 = set0 if ( set1 == set0 ) & write ( * , * ) 'Initialization by assignment succeeded' logical2 = set1 if ( all ( logical2 ) ) then write ( * , * ) 'Initialization of logical(int32) succeeded.' end if end program demo_assignment Table of the non-member comparison operations The comparison operators with two arguments of type bitset_large or bitset_64 must have both arguments of the same known type which\nprevents them from being methods. The operands must also have the same\nnumber of bits otherwise the results are undefined. These operators\nare summarized in the following table: Operator Description == , .eq. .true. if all bits in set1 and set2 have the same value, .false. otherwise /= , .ne. .true. if any bits in set1 and set2 differ in value, .false. otherwise > , .gt. .true. if the bits in set1 and set2 differ in value and the highest order differing bit is 1 in set1 and 0 in set2 , .false. otherwise >= , .ge. .true. if the bits in set1 and set2 are the same or the highest order differing bit is 1 in set1 and 0 in set2 , .false. otherwise < , .lt. .true. if the bits in set1 and set2 differ in value and the highest order differing bit is 0 in set1 and 1 in set2 , .false. otherwise <= , .le. .true. if the bits in set1 and set2 are the same or the highest order differing bit is 0 in set1 and 1 in set2 , .false. otherwise Specification of the stdlib_bitsets methods and procedures all - determine whether all bits are set in self Status Experimental Description Determines whether all bits are set to 1 in self . Syntax result = self % all () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if all bits in self are set,\notherwise it is .false. . Example program demo_all use stdlib_bitsets character ( * ), parameter :: & bits_all = '111111111111111111111111111111111' type ( bitset_64 ) :: set0 call set0 % from_string ( bits_all ) if ( . not . set0 % all () ) then error stop \"FROM_STRING failed to interpret\" // & \"BITS_ALL's value properly.\" else write ( * , * ) \"FROM_STRING transferred BITS_ALL properly\" // & \" into set0.\" end if end program demo_all and - bitwise and of the bits of two bitsets Status Experimental Description Sets the bits in set1 to the bitwise and of the original bits in set1 and set2 . Note that set1 and set2 must have the same\nnumber of bits, otherwise the result is undefined. Syntax call and (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a bitset_64 or bitset_large scalar variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise and of the original bits in set1 with the\ncorresponding bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note that set2 must also have the same\nnumber of bits as set1 . Example program demo_and use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call and ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of AND worked.' call set0 % not () call and ( set0 , set1 ) ! all none if ( none ( set0 ) ) write ( * , * ) 'Second test of AND worked.' call set1 % not () call and ( set0 , set1 ) ! none all if ( none ( set0 ) ) write ( * , * ) 'Third test of AND worked.' call set0 % not () call and ( set0 , set1 ) ! all all if ( all ( set0 ) ) write ( * , * ) 'Fourth test of AND worked.' end program demo_and and_not - Bitwise and of one bitset with the negation of another Status Experimental Description Sets the bits of set1 to bitwise and of the bits of set1 with\nthe bitwise negation of the corresponding bits of set2 . Note that set1 and set2 must have the same number of bits, otherwise the\nresult is undefined. Syntax call and_not (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise and of the original bits in set1 with the\ncorresponding negation of the bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note that it should also have the same\nnumber of bits as set1 , otherwise the result is undefined. Example program demo_and_not use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call and_not ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of AND_NOT worked.' call set0 % not () call and_not ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of AND_NOT worked.' call set0 % not () call set1 % not () call and_not ( set0 , set1 ) ! none all if ( none ( set0 ) ) write ( * , * ) 'Third test of AND_NOT worked.' call set0 % not () call and_not ( set0 , set1 ) ! all all if ( none ( set0 ) ) write ( * , * ) 'Fourth test of AND_NOT worked.' end program demo_and_not any - determine whether any bits are set Status Experimental Description Determines whether any bits are set in self . Syntax result = self % any () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar. The result is .true. if any bits in self are set, otherwise it\nis .false. . Example program demo_any use stdlib_bitsets character ( * ), parameter :: & bits_0 = '0000000000000000000' type ( bitset_64 ) :: set0 call set0 % from_string ( bits_0 ) if ( . not . set0 % any () ) then write ( * , * ) \"FROM_STRING interpreted \" // & \"BITS_0's value properly.\" end if call set0 % set ( 5 ) if ( set0 % any () ) then write ( * , * ) \"ANY interpreted SET0's value properly.\" end if end program demo_any bit_count - return the number of bits that are set Status Experimental Description Returns the number of bits that are set to one in self . Syntax result = self % bit_count () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is an integer scalar of kind bits_kind ,\nequal to the number of bits that are set in self . Example program demo_bit_count use stdlib_bitsets character ( * ), parameter :: & bits_0 = '0000000000000000000' type ( bitset_64 ) :: set0 call set0 % from_string ( bits_0 ) if ( set0 % bit_count () == 0 ) then write ( * , * ) \"FROM_STRING interpreted \" // & \"BITS_0's value properly.\" end if call set0 % set ( 5 ) if ( set0 % bit_count () == 1 ) then write ( * , * ) \"BIT_COUNT interpreted SET0's value properly.\" end if end program demo_bit_count bits - returns the number of bits Status Experimental Description Reports the number of bits in self . Syntax result = self % bits () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is an integer scalar of kind bits_kind , equal to\nthe number of defined bits in self . Example program demo_bits use stdlib_bitsets character ( * ), parameter :: & bits_0 = '0000000000000000000' type ( bitset_64 ) :: set0 call set0 % from_string ( bits_0 ) if ( set0 % bits () == 19 ) then write ( * , * ) \"FROM_STRING interpreted \" // & \"BITS_0's size properly.\" end if end program demo_bits clear - clears a sequence of one or more bits Status Experimental Description If only pos is present, clears the bit with position pos in self . If start_pos and end_pos are present with end_pos >= start_pos clears the bits with positions from start_pos to end_pos in self . if start_pos and end_pos are present with end_pos < start_pos self is unmodified. Note: Positions outside the range 0 to bits(set) -1 are ignored. Syntax call self % clear (pos) or call self % clear (start_pos, end_pos) Class Elemental subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(inout) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. start_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example program demo_clear use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) call set0 % not () if ( set0 % all () ) write ( * , * ) 'SET0 is properly initialized.' call set0 % clear ( 165 ) if ( . not . set0 % test ( 165 ) ) write ( * , * ) 'Bit 165 is cleared.' call set0 % clear ( 0 , 164 ) if ( set0 % none () ) write ( * , * ) 'All bits are cleared.' end program demo_clear extract - create a new bitset from a range in an old bitset Status Experimental Description Creates a new bitset, new , from a range, start_pos to stop_pos ,\nin bitset old . If start_pos is greater than stop_pos the new\nbitset is empty. If start_pos is less than zero or stop_pos is\ngreater than bits(old)-1 then if status is present it has the\nvalue index_invalid_error , otherwise processing stops with an\ninformative message. Syntax call extract (new, old, start_pos, stop_pos, status ) Class Subroutine Arguments new : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(out) argument. It will be the new bitset. old : shall be a scalar expression of the same type as new . It is\nan intent(in) argument. It will be the source bitset. start_pos : shall be a scalar integer expression of the kind bits_kind . It is an intent(in) argument. stop_pos : shall be a scalar integer expression of the kind bits_kind . It is an intent(in) argument. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present it shall have one of the values: success - no problems found index_invalid_error - start_pos was less than zero or stop_pos was greater than bits(old)-1 . Example program demo_extract use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set0 % set ( 100 , 150 ) call extract ( set1 , set0 , 100 , 150 ) if ( set1 % bits () == 51 ) & write ( * , * ) 'SET1 has the proper size.' if ( set1 % all () ) write ( * , * ) 'SET1 has the proper values.' end program demo_extract flip - flip the values of a sequence of one or more bits Status Experimental Description Flip the values of  a sequence of one or more bits. If only pos is present flip the bit value with position pos in self .\n* If start_pos and end_pos are present with end_pos >= start_pos flip the bit values with positions from start_pos to end_pos in self . If end_pos < start_pos then self is unmodified. Syntax call self % flip (pos) or call self % flip (start_pos, end_pos) Class Elemental subroutine. Arguments self : shall be a scalar class bitset_type variable It is an intent(inout) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. start_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example program demo_flip use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) if ( set0 % none () ) write ( * , * ) 'SET0 is properly initialized.' call set0 % flip ( 165 ) if ( set0 % test ( 165 ) ) write ( * , * ) 'Bit 165 is flipped.' call set0 % flip ( 0 , 164 ) if ( set0 % all () ) write ( * , * ) 'All bits are flipped.' end program demo_flip from_string - initializes a bitset from a binary literal Status Experimental Description Initializes the bitset self from string , treating string as a\nbinary literal. Syntax call self % from_string (string[, status]) Class Subroutine Arguments self : shall be a scalar class bitset_type variable. It is an intent(out) argument. string : shall be a scalar default character expression. It is an intent(in) argument. It shall consist only of the characters \"0\",\nand \"1\". status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present, on return its value shall be\none of the error codes defined in this module. If absent, and its\nvalue would not have been success , then processing will stop with an\ninformative text as its stop code. It shall have one of the error\ncodes: success - if no problems were found, alloc_fault - if allocation of the bitset failed char_string_too_large_error - if string was too large, or char_string_invalid_error - if string had an invalid character. Example program demo_from_string use stdlib_bitsets character ( * ), parameter :: & bits_all = '111111111111111111111111111111111' type ( bitset_64 ) :: set0 call set0 % from_string ( bits_all ) if ( bits ( set0 ) /= 33 ) then error stop \"FROM_STRING failed to interpret \" // & 'BITS_ALL' s size properly . \" else if ( .not. set0 % all() ) then error stop \" FROM_STRING failed to interpret \" // & \" BITS_ALL ' s value properly . \" else write(*,*) \" FROM_STRING transferred BITS_ALL properly \" // & \" into set0 . \" end if end program demo_from_string init - bitset_type initialization routines Status Experimental Description bitset_type initialization routine. Syntax call self % init (bits [, status]) Class Subroutine. Arguments self : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(out) argument. bits : shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument that if present\nspecifies the number of bits in set . A negative value, or a value\ngreater than 64 if self is of type bitset_64 , is an error. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument that, if present, returns an error code\nindicating any problem found in processing init , and if absent and\nan error was found result in stopping processing with an informative\nstop code. It can have any of the following error codes: success - no problem found alloc_fault - self was of type bitset_large and memory\n  allocation failed array_size_invalid_error - bits was present with either a negative\n  value, or a value greater than 64 when self was of type bitset_64 . Example program demo_init use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) if ( set0 % bits () == 166 ) & write ( * , * ) 'SET0 has the proper size.' if ( set0 % none () ) write ( * , * ) 'SET0 is properly initialized.' end program demo_init input - reads a bitset from an unformatted file Status Experimental Description Reads a bitset from its binary representation in an unformatted\nfile. Syntax call self % input (unit [, status]) Class Subroutine Arguments self : shall be a scalar variable of class bitset_64 or bitset_large . It is an intent(out) argument. unit : shall be a scalar default integer expression. It is an intent(in) argument. Its value must be that of a logical unit\nnumber for an open unformatted file with read or readwrite access positioned at the start of a bitset value written by a bitset_type output subroutine by the same processor. status (optional): shall be a scalar default integer variable. If\npresent its value shall be of one of the error codes defined in this\nmodule. If absent and it would have had a value other than success processing will stop with an informative stop code. Allowed error code\nvalues for this status are: success - no problem found alloc_fault - self was of type bitset_large and allocation of\n  memory failed. array_size_invalid_error - if the number of bits read from unit is either negative or greater than 64, if class of self is bitset_64 . read_failure - failure during a read statement Example program demo_input character ( * ), parameter :: & bits_0 = '000000000000000000000000000000000' , & bits_1 = '000000000000000000000000000000001' , & bits_33 = '100000000000000000000000000000000' integer :: unit type ( bitset_64 ) :: set0 , set1 , set2 , set3 , set4 , set5 call set0 % from_string ( bits_0 ) call set1 % from_string ( bits_1 ) call set2 % from_string ( bits_33 ) open ( newunit = unit , file = 'test.bin' , status = 'replace' , & form = 'unformatted' , action = 'write' ) call set2 % output ( unit ) call set1 % output ( unit ) call set0 % output ( unit ) close ( unit ) open ( newunit = unit , file = 'test.bin' , status = 'old' , & form = 'unformatted' , action = 'read' ) call set5 % input ( unit ) call set4 % input ( unit ) call set3 % input ( unit ) close ( unit ) if ( set3 /= set0 . or . set4 /= set1 . or . set5 /= set2 ) then error stop 'Transfer to and from units using ' // & ' output and input failed.' else write ( * , * ) 'Transfer to and from units using ' // & 'output and input succeeded.' end if end program demo_input none - determines whether no bits are set Status Experimental Description Determines whether no bits are set in self . Syntax result = self % none () Class Elemental function. Argument self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if no bits in self are set, otherwise it is .false. . Example program demo_none use stdlib_bitsets character ( * ), parameter :: & bits_0 = '0000000000000000000' type ( bitset_large ) :: set0 call set0 % from_string ( bits_0 ) if ( set0 % none () ) then write ( * , * ) \"FROM_STRING interpreted \" // & \"BITS_0's value properly.\" end if call set0 % set ( 5 ) if ( . not . set0 % none () ) then write ( * , * ) \"NONE interpreted SET0's value properly.\" end if end program demo_none not - Performs the logical complement on a bitset Status Experimental Description Performs the logical complement on the bits of self . Syntax call self % not () Class Elemental subroutine. Argument self shall be a scalar variable of class bitset_type . It is an intent(inout) argument. On return its bits shall be the logical\ncomplement of their values on input. Example program demo_not use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 155 ) if ( set0 % none () ) then write ( * , * ) \"FROM_STRING interpreted \" // & \"BITS_0's value properly.\" end if call set0 % not () if ( set0 % all () ) then write ( * , * ) \"ALL interpreted SET0's value properly.\" end if end program demo_not or - Bitwise OR of the bits of two bitsets Status Experimental Description Replaces the original bits of set1 with the bitwise or of those\nbits with the bits of set2 . Note set1 and set2 must have the\nsame number of bits, otherwise the result is undefined. Syntax call or (set1, set2) Class Elemental subroutine. Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in setf are the bitwise or of the original bits in set1 with the\ncorresponding bits in set2 . set2 : shall be a scalar expression of the same type as set1 . It is\nan intent(in) argument. Note bits(set2) must equal bits(set1) otherwise the results are undefined. Example program demo_or use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call or ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of OR worked.' call set0 % not () call or ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of OR worked.' call set0 % not () call set1 % not () call or ( set0 , set1 ) ! none all if ( all ( set0 ) ) write ( * , * ) 'Third test of OR worked.' call set0 % not () call or ( set0 , set1 ) ! all all if ( all ( set0 ) ) write ( * , * ) 'Fourth test of OR worked.' end program demo_or output - Writes a binary representation of a bitset to a file Status Experimental Description Writes a binary representation of a bitset to an unformatted file. Syntax call self % output (unit[, status]) Class Subroutine. Arguments self : shall be a scalar expression of class bitset_64 or bitset_large . It is an intent(in) argument. unit : shall be a scalar default integer expression. It is an intent(in) argument. Its value must be that of an I/O unit number\nfor an open unformatted file with write or readwrite access. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it will have the value\nof success or write_failure . If absent and it would not have the\nvalue of success then processing will stop with an informative stop\ncode. The two code values have the meaning: success - no problem found write_failure - a failure occurred in a write statement. Example program demo_output character ( * ), parameter :: & bits_0 = '000000000000000000000000000000000' , & bits_1 = '000000000000000000000000000000001' , & bits_33 = '100000000000000000000000000000000' integer :: unit type ( bitset_64 ) :: set0 , set1 , set2 , set3 , set4 , set5 call set0 % from_string ( bits_0 ) call set1 % from_string ( bits_1 ) call set2 % from_string ( bits_33 ) open ( newunit = unit , file = 'test.bin' , status = 'replace' , & form = 'unformatted' , action = 'write' ) call set2 % output ( unit ) call set1 % output ( unit ) call set0 % output ( unit ) close ( unit ) open ( newunit = unit , file = 'test.bin' , status = 'old' , & form = 'unformatted' , action = 'read' ) call set5 % input ( unit ) call set4 % input ( unit ) call set3 % input ( unit ) close ( unit ) if ( set3 /= set0 . or . set4 /= set1 . or . set5 /= set2 ) then error stop 'Transfer to and from units using ' // & ' output and input failed.' else write ( * , * ) 'Transfer to and from units using ' // & 'output and input succeeded.' end if end program demo_output read_bitset - initializes self with the value of a bitset_literal Status Experimental Description Reads a bitset-literal and initializes self with the corresponding\nvalue. Syntax call self % read_bitset (string[, status]) or call self % read_bitset (unit[, advance, status]) Class Subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(out) argument. Upon a successful return it is initialized with\nthe value of a bitset-literal . string (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It will consist of a left \njustified bitset-literal , terminated by either the end of the string\nor a blank. unit (optional): shall be a scalar default integer expression. It is\nan intent(in) argument. Its value must be that of an I/O unit number\nfor an open formatted file with read or readwrite access\npositioned at the start of a bitset-literal . advance (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It is the advance specifier for the final read of unit . If present it should have\nthe value 'yes' or 'no' . If absent it has the default value of 'yes' . status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it shall have the\nvalue of one of the error codes of this module. If absent and it would\nnot have had the value success processing will stop with a message\nas its error code. The possible error codes are: success - no problems found; alloc_fault - if self is of class bitset_large and allocation\n  of the bits failed; array_size_invalid_error - if the bitset-literal has a bits\n  value greater than 64 and self is of class bitset_64 ; char_string_invalid_error - if the bitset-literal has an invalid\n  character; char_string_too_small_error - if string ends before all the bits\n  are read; eof_failure -  if a read statement reached an end-of-file before\n   completing the read of the bitset literal, integer_overflow_error - if the bitset-literal has a bits value larger than huge(0_bits_kind) ; or read_failure - if a read statement failed. Example program demo_read_bitset character ( * ), parameter :: & bits_0 = 'S33B000000000000000000000000000000000' , & bits_1 = 'S33B000000000000000000000000000000001' , & bits_33 = 'S33B100000000000000000000000000000000' character (:), allocatable :: test_0 , test_1 , test_2 integer :: unit type ( bitset_64 ) :: set0 , set1 , set2 , set3 , set4 , set5 call set0 % read_bitset ( bits_0 , status ) call set1 % read_bitset ( bits_1 , status ) call set2 % read_bitset ( bits_2 , status ) call set0 % write_bitset ( test_0 , status ) call set1 % write_bitset ( test_1 , status ) call set2 % write_bitset ( test_2 , status ) if ( bits_0 == test_0 . and . bits_1 == test_1 . and . & bits_2 == test_2 ) then write ( * , * ) 'READ_BITSET to WRITE_BITSET strings worked.' end if open ( newunit = unit , file = 'test.txt' , status = 'replace' , & form = 'formatted' , action = 'write' ) call set2 % write_bitset ( unit , advance = 'no' ) call set1 % write_bitset ( unit , advance = 'no' ) call set0 % write_bitset ( unit ) close ( unit ) open ( newunit = unit , file = 'test.txt' , status = 'old' , & form = 'formatted' , action = 'read' ) call set3 % read_bitset ( unit , advance = 'no' ) call set4 % read_bitset ( unit , advance = 'no' ) call set5 % read_bitset ( unit ) if ( set3 == set0 . and . set4 == set1 . and . set5 == set2 ) then write ( * , * ) WRITE_BITSET to READ_BITSET through unit worked . ' end if end program demo_read_bitset set - sets a sequence of one or more bits to 1 Status Experimental Description Sets a sequence of one or more bits in self to 1. If start_pos and end_pos are absent sets the bit at position pos in self to 1. If start_pos and end_pos are present with end_pos >= start_pos set the bits at positions from start_pos to end_pos in self to 1. If start_pos and end_pos are present with end_pos < start_pos self is unchanged. Positions outside the range 0 to bits(self) are ignored. Syntax call self % set (POS) or call self % set (START_POS, END_POS) Class Elemental subroutine Arguments self : shall be a scalar variable of class bitset_type . It is an intent(inout) argument. pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. start_pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. end_pos (optional): shall be a scalar integer expression of kind bits_kind . It is an intent(in) argument. Example program demo_set use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) if ( set0 % none () ) write ( * , * ) 'SET0 is properly initialized.' call set0 % set ( 165 ) if ( set0 % test ( 165 ) ) write ( * , * ) 'Bit 165 is set.' call set0 % set ( 0 , 164 ) if ( set0 % all () ) write ( * , * ) 'All bits are set.' end program demo_set test - determine whether a bit is set Status Experimental Descriptions Determine whether the bit at position pos is set to 1 in self . Syntax result = self % test (pos) Class Elemental function. Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bit at pos in self is set,\notherwise it is .false. . If pos is outside the range 0... bits(self)-1 the result is .false. . Example program demo_test use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) call set0 % not () if ( set0 % all () ) write ( * , * ) 'SET0 is properly initialized.' call set0 % clear ( 165 ) if ( . not . set0 % test ( 165 ) ) write ( * , * ) 'Bit 165 is cleared.' call set0 % set ( 165 ) if ( set0 % test ( 165 ) ) write ( * , * ) 'Bit 165 is set.' end program demo_test to_string - represent a bitset as a binary literal Status Experimental Description Represents the value of self as a binary literal in string . Syntax call self % to_string (string[, status]) Class Subroutine Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. string : shall be a scalar default character variable of allocatable\nlength. It is an intent(out) argument. On return it shall have a binary-literal representation of the bitset self . status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present it shall have either the value success or alloc_fault . If absent and it would have had the value alloc_fault then processing will stop with an informative test as\nthe stop code. The values have the following meanings: success - no problem found. alloc_fault - allocation of string failed. Example program demo_to_string use stdlib_bitsets character ( * ), parameter :: & bits_all = '111111111111111111111111111111111' type ( bitset_64 ) :: set0 character (:), allocatable :: new_string call set0 % init ( 33 ) call set0 % not () call set0 % to_string ( new_string ) if ( new_string == bits_all ) then write ( * , * ) \"TO_STRING transferred BITS0 properly\" // & \" into NEW_STRING.\" end if end program demo_to_string value - determine the value of a bit Status Experimental Description Determines the value of the bit at position, pos , in self . Syntax result = self % value (pos) Class Elemental function. Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. pos : shall be a scalar integer expression of kind bits_kind . It is\nan intent(in) argument. Result value The result is a default integer scalar.\nThe result is one if the bit at pos in self is set, otherwise it\nis zero. If pos is outside the range 0... bits(set)-1 the result\nis zero. Example program demo_value use stdlib_bitsets type ( bitset_large ) :: set0 call set0 % init ( 166 ) call set0 % not () if ( set0 % all () ) write ( * , * ) 'SET0 is properly initialized.' call set0 % clear ( 165 ) if ( set0 % value ( 165 ) == 0 ) write ( * , * ) 'Bit 165 is cleared.' call set0 % set ( 165 ) if ( set0 % value ( 165 ) == 1 ) write ( * , * ) 'Bit 165 is set.' end program demo_value write_bitset - writes a bitset-literal Status Experimental Description Writes a bitset-literal representing self 's current value to a\ncharacter string or formatted file. Syntax call self % write_bitset (string[, status]) or call self % write_bitset (unit[, advance, status]) Class Subroutine Arguments self : shall be a scalar expression of class bitset_type . It is an intent(in) argument. string (optional): shall be a scalar default character variable of\nallocatable length. It is an intent(out) argument. unit (optional): shall be a scalar default logical expression. It is\nan intent(in) argument. Its value must be that of a I/O unit number\nfor an open formatted file with write or readwrite access. advance (optional): shall be a scalar default character\nexpression. It is an intent(in) argument. It is the advance specifier for the write to unit . If present it must have the value 'yes' or 'no' . It has the default value of 'yes' . if advance is not present or is present with a value of 'no' then the bitset's bitset-literal is written to unit followed by a blank, and the current record is not advanced. If advance is present with a value of 'yes' then the\n  bitset's bitset-literal is written to unit and the\n  record is immediately advanced. status (optional): shall be a scalar default integer variable. It is\nan intent(out) argument. If present on return it shall have the\nvalue of one of the module's error codes. If absent and a problem was\nfound processing will stop with an informative stop code. It may have\nthe following error code values: success - no problem was found alloc_fault - allocation of the string failed write_failure - the write to the unit failed Example program demo_write_bitset character ( * ), parameter :: & bits_0 = 'S33B000000000000000000000000000000000' , & bits_1 = 'S33B000000000000000000000000000000001' , & bits_33 = 'S33B100000000000000000000000000000000' character (:), allocatable :: test_0 , test_1 , test_2 integer :: unit type ( bitset_64 ) :: set0 , set1 , set2 , set3 , set4 , set5 call set0 % read_bitset ( bits_0 , status ) call set1 % read_bitset ( bits_1 , status ) call set2 % read_bitset ( bits_2 , status ) call set0 % write_bitset ( test_0 , status ) call set1 % write_bitset ( test_1 , status ) call set2 % write_bitset ( test_2 , status ) if ( bits_0 == test_0 . and . bits_1 == test_1 . and . & bits_2 == test_2 ) then write ( * , * ) 'READ_BITSET to WRITE_BITSET strings worked.' end if open ( newunit = unit , file = 'test.txt' , status = 'replace' , & form = 'formatted' , action = 'write' ) call set2 % write_bitset ( unit , advance = 'no' ) call set1 % write_bitset ( unit , advance = 'no' ) call set0 % write_bitset ( unit ) close ( unit ) open ( newunit = unit , file = 'test.txt' , status = 'old' , & form = 'formatted' , action = 'read' ) call set3 % read_bitset ( unit , advance = 'no' ) call set4 % read_bitset ( unit , advance = 'no' ) call set5 % read_bitset ( unit ) if ( set3 == set0 . and . set4 == set1 . and . set5 == set2 ) then write ( * , * ) WRITE_BITSET to READ_BITSET through unit worked . ' end if end program demo_write_bitset xor - bitwise exclusive or Status Experimental Description Replaces set1 's bitset with the bitwise exclusive or of the\noriginal bits of set1 and set2 . Note set1 and set2 must have\nthe samee number of bits, otherwise the result is undefined. Syntax result = xor (set1, set2) Class Elemental subroutine Arguments set1 : shall be a scalar bitset_64 or bitset_large variable. It\nis an intent(inout) argument. On return the values of the bits in set1 are the bitwise exclusive or of the original bits in set1 with the corresponding bits in set2 . set2 shall be a scalar expression of the same type as set1 . It is\n  an intent(in) argument. Note set1 and set2 must have the\nsamee number of bits, otherwise the result is undefined. Example program demo_xor use stdlib_bitsets type ( bitset_large ) :: set0 , set1 call set0 % init ( 166 ) call set1 % init ( 166 ) call xor ( set0 , set1 ) ! none none if ( none ( set0 ) ) write ( * , * ) 'First test of XOR worked.' call set0 % not () call xor ( set0 , set1 ) ! all none if ( all ( set0 ) ) write ( * , * ) 'Second test of XOR worked.' call set0 % not () call set1 % not () call xor ( set0 , set1 ) ! none all if ( all ( set0 ) ) write ( * , * ) 'Third test of XOR worked.' call set0 % not () call xor ( set0 , set1 ) ! all all if ( none ( set0 ) ) write ( * , * ) 'Fourth test of XOR worked.' end program demo_xor Specification of the stdlib_bitsets operators == - compare two bitsets to determine whether the bits have the same value Status Experimental Description Returns .true. if all bits in set1 and set2 have the same value, .false. otherwise. Syntax result = set1 [[stdlib_bitsets(module):==(interface)]] set2 or result = set1 .EQ. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in both bitsets are set\nto the same value, otherwise the result is .false. . Example program demo_equality use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 == set0 . and . set1 == set1 . and . set2 == set2 . and . & . not . set0 == set1 . and . . not . set0 == set2 . and . . not . & set1 == set2 ) then write ( * , * ) 'Passed 64 bit equality tests.' else error stop 'Failed 64 bit equality tests.' end if end program demo_equality /= - compare two bitsets to determine whether any bits differ in value Status Experimental Description Returns .true. if any bits in self and set2 differ in value, .false. otherwise. Syntax result = set1 [[stdlib_bitsets(module):/=(interface)]] set2 or result = set1 .NE. set2 Class Elemental function Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if any bits in both bitsets differ, otherwise\nthe result is .false. . Example program demo_inequality use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 /= set1 . and . set0 /= set2 . and . set1 /= set2 . and . & . not . set0 /= set0 . and . . not . set1 /= set1 . and . . not . & set2 /= set2 ) then write ( * , * ) 'Passed 64 bit inequality tests.' else error stop 'Failed 64 bit inequality tests.' end if end program demo_inequality >= - compare two bitsets to determine whether the first is greater than or equal to the second Status Experimental Description Returns .true. if the bits in set1 and set2 are the same or the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. .  otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):>=(interface)]] set2 or result = set1 .GE. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 are the same\nor the highest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. Example program demo_ge use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set1 >= set0 . and . set2 >= set1 . and . set2 >= set0 . and . & set0 >= set0 . and . set1 >= set1 . and . set2 >= set2 . and . & . not . set0 >= set1 . and . . not . set0 >= set2 . and . . not . & set1 >= set2 ) then write ( * , * ) 'Passed 64 bit greater than or equals tests.' else error stop 'Failed 64 bit greater than or equals tests.' end if end program demo_ge > - compare two bitsets to determine whether the first is greater than the other Status Experimental Description Returns .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):>(interface)]] set2 or result = set1 .GT. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 1 in set1 and to 0 in set2 , .false. otherwise. Example program demo_gt use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set1 > set0 . and . set2 > set1 . and . set2 > set0 . and . & . not . set0 > set0 . and . . not . set0 > set1 . and . . not . & set1 > set2 ) then write ( * , * ) 'Passed 64 bit greater than tests.' else error stop 'Failed 64 bit greater than tests.' end if end program demo_gt <= - compare two bitsets to determine whether the first is less than or equal to the other Status Experimental Description Returns .true. if the bits in set1 and set2 are the same or the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):<=(interface)]] set2 or result = set1 .LE. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 are the same\nor the highest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. Example program demo_le use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 <= set1 . and . set1 <= set2 . and . set0 <= set2 . and . & set0 <= set0 . and . set1 <= set1 . and . set2 <= set2 . and . & . not . set1 <= set0 . and . . not . set2 <= set0 . and . . not . & set2 <= set1 ) then write ( * , * ) 'Passed 64 bit less than or equal tests.' else error stop 'Failed 64 bit less than or equal tests.' end if end program demo_le < - compare two bitsets to determine whether the first is less than the other Status Experimental Description Returns .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. The sets must be the same size otherwise the\nresults are undefined. Syntax result = set1 [[stdlib_bitsets(module):<(interface)]] set2 or `result = set1 .LT. set2 Class Elemental operator Arguments set1 : shall be a scalar bitset_64 or bitset_large expression. It\nis an intent(in) argument. set2 : shall be a scalar expression of the same type as self . It\nwill have the same number of bits as set1 . It is an intent(in) argument. Result value The result is a default logical scalar.\nThe result is .true. if the bits in set1 and set2 differ and the\nhighest order different bit is set to 0 in set1 and to 1 in set2 , .false. otherwise. Example program demo_lt use stdlib_bitsets type ( bitset_64 ) :: set0 , set1 , set2 call set0 % init ( 33 ) call set1 % init ( 33 ) call set2 % init ( 33 ) call set1 % set ( 0 ) call set2 % set ( 32 ) if ( set0 < set1 . and . set1 < set2 . and . set0 < set2 . and . & . not . set0 < set0 . and . . not . set2 < set0 . and . . not . & set2 < set1 ) then write ( * , * ) 'Passed 64 bit less than tests.' else error stop 'Failed 64 bit less than tests.' end if end program demo_lt","tags":"","loc":"page/specs/stdlib_bitsets.html"},{"title":"error – Fortran-lang/stdlib","text":"Catching and handling errors Catching and handling errors check - Checks the value of a logical condition Status Description Syntax Arguments Return value Examples error_stop - aborts the program Status Description Syntax Arguments Output Examples check - Checks the value of a logical condition Status Experimental Description Checks the value of a logical condition. Syntax call check (condition, msg, code, warn) Arguments condition : Shall be a scalar of type logical . msg (optional): Shall be a character expression containing the message to be printed to stderr . The default msg is 'Check failed.'. code (optional): Shall be a scalar of type integer . The default code is 1 . warn (optional): Shall be a scalar of type logical . The default warn is .true. . Return value If condition is .false ., and: no other arguments are provided, this subroutine stops the program with the default message and exit code 1; msg is provided, this subroutine stops the program and it prints the value of msg ; code is provided, this subroutine stops the program with the given exit code; warn is provided and warn is .true. , this subroutine doesn't stop the program and prints the message. Examples program demo_check1 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints 'Check failed.' call check ( a == 5 ) end program demo_check1 program demo_check2 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints  'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' ) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5,  prints 'a == 5 failed.', but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 77 and prints 'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) end program demo_check3 error_stop - aborts the program Status Experimental Description Aborts the program with a message and a nonzero exit code. Syntax call error_stop (msg, code) Arguments msg : Shall be a character expression containing the message to be printed to stderr . code (optional): Shall be a scalar of type integer to be returned as exit code. Output Aborts the program with printing the message msg to stderr and a nonzero exit code. The nonzero exit code is equal to code if provided, and 1 otherwise. Examples Without error code: program demo_error_stop1 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" ) end program demo_error_stop1 With error code: program demo_error_stop2 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" , code = 123 ) end program demo_error_stop2","tags":"","loc":"page/specs/stdlib_error.html"},{"title":"IO – Fortran-lang/stdlib","text":"IO IO loadtxt - load a 2D array from a text file Status Description Syntax Arguments Return value Example open - open a file Status Description Syntax Arguments Return value Example savetxt - save a 2D array into a text file Status Description Syntax Arguments Output Example loadtxt - load a 2D array from a text file Status Experimental Description Loads a rank-2 array from a text file. Syntax call loadtxt (filename, array) Arguments filename : Shall be  a character expression containing the file name from which to load the rank-2 array . array : Shall be an allocatable rank-2 array of type real , complex or integer . Return value Returns an allocated rank-2 array with the content of filename . Example program demo_loadtxt use stdlib_io , only : loadtxt implicit none real , allocatable :: x (:,:) call loadtxt ( 'example.dat' , x ) end program demo_loadtxt open - open a file Status Experimental Description Returns the unit number of a file opened to read, to write, or to read and write. The file might be a text file or a binary file. All files are opened using a streamed access. Syntax u = open (filename [, mode] [, iostat]) Arguments filename : Shall be a character expression containing the name of the file to open. mode (optional): Shall be a character expression containing characters describing the way in which the file will be used. The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of the file if it exists '+' open for updating (reading and writing) 'b' binary mode 't' text mode (default) The default mode is 'rt' (i.e. open for reading a text file). The mode may include one of the four different methods for opening a file (i.e., 'r' , 'w' , 'x' , and 'a' ). These four methods can be associated with the character '+' to open the file for updating. In addition, it can be specified if the file should be handled as a binary file ( 'b' ) or a text file ( 't' ). iostat (optional): Shall be a scalar of type integer that receives the error status of open , if provided. If no error exists, iostat is zero. u : Shall be a scalar of type integer that specifies the unit number associated with the file filename . Return value The result is a scalar of type integer . Example program demo_open use stdlib_io , only : open implicit none integer :: u u = open ( 'example.dat' , 'wt' ) write ( u , '(a)' ) 'This is an example for open' close ( u ) end program demo_open savetxt - save a 2D array into a text file Status Experimental Description Saves a rank-2 array into a text file. Syntax call savetxt (filename, array) Arguments filename : Shall be  a character expression containing the name of the file that will contain the 2D array . array : Shall be a rank-2 array of type real , complex or integer . Output Provides a text file called filename that contains the rank-2 array . Example program demo_savetxt use stdlib_io , only : savetxt implicit none real :: x ( 3 , 2 ) = 1 call savetxt ( 'example.dat' , x ) end program demo_savetxt","tags":"","loc":"page/specs/stdlib_io.html"},{"title":"kinds – Fortran-lang/stdlib","text":"The stdlib_kinds module The stdlib_kinds module Introduction Constants provided by stdlib_kinds sp dp qp int8 int16 int32 int64 lk c_bool Introduction The stdlib_kinds module provides kind parameters for the Fortran intrinsic data types, integer , logical , real , and complex . Constants provided by stdlib_kinds sp Alias for intrinsic named constant real32 imported from iso_fortran_env . dp Alias for intrinsic named constant real64 imported from iso_fortran_env . qp Alias for intrinsic named constant real128 imported from iso_fortran_env . int8 Reexported intrinsic named constant int8 from iso_fortran_env . int16 Reexported intrinsic named constant int16 from iso_fortran_env . int32 Reexported intrinsic named constant int32 from iso_fortran_env . int64 Reexported intrinsic named constant int64 from iso_fortran_env . lk Kind parameter of the default logical data type. c_bool Reexported intrinsic named constant c_bool from iso_c_binding .","tags":"","loc":"page/specs/stdlib_kinds.html"},{"title":"linalg – Fortran-lang/stdlib","text":"Linear Algebra Linear Algebra diag - Create a diagonal array or extract the diagonal elements of an array Status Description Syntax Arguments Return value Example eye - Construct the identity matrix Status Description Syntax Arguments Return value Example trace - Trace of a matrix Status Description Syntax Arguments Return value Example outer_product - Computes the outer product of two vectors Status Description Syntax Arguments Return value Example diag - Create a diagonal array or extract the diagonal elements of an array Status Experimental Description Create a diagonal array or extract the diagonal elements of an array Syntax d = diag (a [, k]) Arguments a : Shall be a rank-1 or or rank-2 array. If a is a rank-1 array (i.e. a vector) then diag returns a rank-2 array with the elements of a on the diagonal. If a is a rank-2 array (i.e. a matrix) then diag returns a rank-1 array of the diagonal elements. k (optional): Shall be a scalar of type integer and specifies the diagonal. The default k = 0 represents the main diagonal, k > 0 are diagonals above the main diagonal, k < 0 are diagonals below the main diagonal. Return value Returns a diagonal array or a vector with the extracted diagonal elements. Example program demo_diag1 use stdlib_linalg , only : diag implicit none real , allocatable :: A (:,:) integer :: i A = diag ([( 1 , i = 1 , 10 )]) ! creates a 10 by 10 identity matrix end program demo_diag1 program demo_diag2 use stdlib_linalg , only : diag implicit none real :: v (:) real , allocatable :: A (:,:) integer :: i v = [ 1 , 2 , 3 , 4 , 5 ] A = diag ( v ) ! creates a 5 by 5 matrix with elements of v on the diagonal end program demo_diag2 program demo_diag3 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 10 real :: c ( n ), ul ( n - 1 ) real :: A ( n , n ) integer :: i c = 2 ul = - 1 A = diag ( ul , - 1 ) + diag ( c ) + diag ( ul , 1 ) ! Gil Strang's favorite matrix end program demo_diag3 program demo_diag4 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 12 real :: A ( n , n ) real :: v ( n ) integer :: i call random_number ( A ) v = diag ( A ) ! v contains diagonal elements of A end program demo_diag4 program demo_diag5 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 3 real :: A ( n , n ) real , allocatable :: v (:) integer :: i A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ n , n ]) v = diag ( A , - 1 ) ! v is [2,6] v = diag ( A , 1 ) ! v is [4,8] end program demo_diag5 eye - Construct the identity matrix Status Experimental Description Construct the identity matrix Syntax I = eye (n) Arguments n : Shall be a scalar of default type integer . Return value Returns the identity matrix, i.e. a square matrix with ones on the main diagonal and zeros elsewhere. The return value is of type integer(int8) . Example program demo_eye1 use stdlib_linalg , only : eye implicit none real :: a ( 3 , 3 ) A = eye ( 3 ) end program demo_eye1 program demo_eye2 use stdlib_linalg , only : eye , diag implicit none print * , all ( eye ( 4 ) == diag ([ 1 , 1 , 1 , 1 ])) ! prints .true. end program demo_eye2 trace - Trace of a matrix Status Experimental Description Trace of a matrix (rank-2 array) Syntax result = [stdlib_linalg(module):trace(interface)](A) Arguments A : Shall be a rank-2 array. If A is not square, then trace(A) will return the sum of diagonal values from the square sub-section of A . Return value Returns the trace of the matrix, i.e. the sum of diagonal elements. Example program demo_trace use stdlib_linalg , only : trace implicit none real :: A ( 3 , 3 ) A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ 3 , 3 ]) print * , trace ( A ) ! 1 + 5 + 9 end program demo_trace outer_product - Computes the outer product of two vectors Status Experimental Description Computes the outer product of two vectors Syntax d = outer_product (u, v) Arguments u : Shall be a rank-1 array v : Shall be a rank-1 array Return value Returns a rank-2 array equal to u v&#94;T (where u, v are considered column vectors). The shape of the returned array is [size(u), size(v)] . Example program demo_outer_product use stdlib_linalg , only : outer_product implicit none real , allocatable :: A (:,:), u (:), v (:) u = [ 1. , 2. , 3. ] v = [ 3. , 4. ] A = outer_product ( u , v ) !A = reshape([3., 6., 9., 4., 8., 12.], [3,2]) end program demo_outer_product","tags":"","loc":"page/specs/stdlib_linalg.html"},{"title":"logger – Fortran-lang/stdlib","text":"Loggers Loggers Introduction The stdlib_logger constants The derived type: logger_type Status Description Syntax Private attributes The stdlib_logger variable Public logger_type methods Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Description Syntax Class Arguments Example add_log_unit - add a unit to the array self % log_units Status Description Syntax Class. Arguments Example configuration - report a logger's configuration Status Description Syntax Class Arguments Example configure - configure the logging process Status Description Syntax Class Arguments Example log_debug - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_error - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_information - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_io_error - Write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_message - write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_text_error - send a message to self % log_units describing an error Status Description Behavior Syntax Class Arguments Example log_units_assigned - returns the number of active I/O units Status Description Syntax Class Argument Result character Result value Example log_warning - write the string message to log_units Status Description Behavior Syntax Class Arguments Example remove_log_unit - remove unit from self % log_units Status Description Syntax Class Arguments Example Introduction This module defines a derived type, its methods, a variable, and\nconstants to be used for the reporting of errors, displaying messages,\nand other information. The derived type, logger_type , is to be used\nto define both global and local logger variables. The logger_type methods serve to configure the loggers and use the logger variables to\nreport messages to a variable specific list of I/O units termed log_units . The variable, global_logger , of type logger_type ,\nis intended to serve as the default global logger. The constants serve\nas error flags returned by the optional integer stat argument. The logger variables have the option to: change which units receive the log messages; report which units receive the log messages; select which types of messages are logged; precede messages by a blank line; precede messages by a time stamp of the form yyyy-mm-dd hh:mm:ss.sss ; precede messages with the names of a module and procedure; follow a message with the stat and errmsg of the error report\n  that prompted the log message; follow a message with the iostat and iomsg of the I/O error\n  report that prompted the log message; label a message with one of 'DEBUG: ' , 'INFO: ' , 'WARN: ' , 'ERROR: ' , or 'I/O ERROR: ' ; indent subsequent lines of the messages; and format the text to fit within a maximum column width. While every effort has been made to make the code process and\nasynchronous I/O safe, it is always best to have each process write to\nits own dedicated logger file.\nFor thread parallelism (e.g., with OpenMP), it is advised to put the\nlogger call in a guarding region (e.g., in an OpenMP critical region). Note: Loggers of type logger_type normally report their messages to I/O\nunits in the internal list termed log_units . However if log_units is empty then the messages go to the output_unit of the intrinsic\nmodule iso_fortran_env . The stdlib_logger constants The module defines nine distinct public integer constants for\nreporting errors in the stat arguments of some of the module's\nprocedures. The constants, termed error codes, are as follows: Error Code Description success no error was detected close_failure a close statement for an I/O unit failed index_invalid_error the column was invalid for the given line non_sequential_error the I/O unit did not have SEQUENTIAL access open_failure an open statement failed read_only_error an output unit did not have an access specifier of 'WRITE' or 'READWRITE' unformatted_in_error the unit did not have a form of 'FORMATTED' unopened_in_error the unit was not opened write_fault one of the writes to log_units failed The module also defines eight distinct public integer constants for\nselecting the messages that are logged. These constants, termed\nseverity levels, are (sorted following their increasing order of\nseverity): all_level , debug_level , information_level , warning_level , error_level , io_error_level , text_error_level ,\nand none_level .\nAll log messages with a level (e.g., debug_level ) lower than a\nspecified severity level (e.g., information_level ) will be ignored.\nThe levels error_level and io_error_level have the same severity.\nThe default severity level is information_level . The derived type: logger_type Status Experimental Description Serves to define 'logger' variables to be used in reporting\nsignificant events encountered during the execution of a program. Syntax type( logger_type ) :: variable Private attributes Attribute Type Description Initial value add_blank_line Logical Flag to precede output with a blank line .false. indent_lines Logical Flag to indent subsequent lines by four columns .true. level Integer Severity level information_level log_units Integer array List of I/O units used for output Unallocated max_width Integer Maximum column width of output 0 time_stamp Logical Flag to precede output by a time stamp .true. units Integer Count of the number of active output units 0 The stdlib_logger variable The module defines one public variable, global_logger , of type logger_type . As might be guessed from its name, global_logger is\nintended to serve as the default logger for use throughout an\napplication. Public logger_type methods The module defines twelve public procedures: one function and eleven\nsubroutines.  The\nmethods are: Method Class Description add_log_file Subroutine Opens a file using newunit , and adds the resulting unit to the log_units list add_log_unit Subroutine Adds an existing unit to the log_units list configuration Subroutine Reports the details of the logging configuration configure Subroutine Configures the details of the logging process log_debug Subroutine Sends a message prepended by 'DEBUG: ' log_error Subroutine Sends a message prepended by 'ERROR: ' optionally followed by a stat or errmsg log_information Subroutine Sends a message prepended by 'INFO: ' log_io_error Subroutine Sends a message prepended by 'I/O ERROR: ' optionally followed by an iostat or iomsg log_message Subroutine Sends a message log_text_error Subroutine Sends a message describing an error found in a line of text log_units_assigned Function Returns the number of active I/O units in log_units log_warning Subroutine Sends a message prepended by 'WARN: ' remove_log_unit Subroutine Removes the unit number from the log_units array Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Experimental Description Opens a formatted, sequential access, output file, filename using newunit and adds the resulting unit number to the logger's log_units array. Syntax call self % add_log_file ( filename [, unit, action, position, status, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to add the file to its log_units . filename : shall be a scalar default character expression. It is\nan intent(in) argument. It shall be the name of the file to be opened. unit (optional): shall be a scalar default integer variable. It is an intent(out) argument. It will be the unit number returned by the newunit specifier of the open statement for filename . action (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the action specifier of the open statement and must have one of the values 'WRITE' or 'READWRITE' . It has the default value of 'WRITE' . position (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the position specifier of the open statement and must have one of\n  the values 'ASIS' , 'REWIND' , or 'APPEND' . It has the default\n  value of 'REWIND' . status (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the status specifier of the open statement and must have one of\n  the values 'OLD' , 'NEW' , 'REPLACE' , or 'UNKNOWN' . It has the\n  default value of 'REPLACE' . stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present, on return it will have the\n  value success if filename could be opened, the value read_only_error if the action specifier is \"READ\" , or the value open_failure if filename could not be opened. If absent and filename could not be opened then processing will stop with an informative message as the stop code. Example program demo_global_logger use stdlib_logger , global => global_logger integer :: unit , stat call global % add_log_file ( 'error_log.txt' , unit , & position = 'asis' , stat = stat ) if ( stat /= success ) then error stop 'Unable to open \"error_log.txt\".' end if end program demo_global_logger add_log_unit - add a unit to the array self % log_units Status Experimental Description Adds unit to the array of self % log_units . The unit shall\nbe the unit number for an opened, sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . Failure of unit to meet\nthose requirements will cause stat , if present, to not be success and unit will not be added to log_units . In this case, if stat is\nnot present, cause processing to stop with an informative string as\nthe stop code. Syntax call self % add_log_unit ( unit [, stat ] ) Class. Subroutine. Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to direct its output\nto unit . unit : shall be a scalar default integer expression. It is an intent(in) argument. It shall be the unit number for an opened,\n  sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If absent  and unit could not be added\n  to self's log_units processing will stop with an informative\n  message as the stop code. If present it shall have the value of one\n  of the module's error codes indicating any errors found with unit . The codes are\n  * success - no problem found\n  * non_sequential_error - unit did not have an access specifier of 'SEQUENTIAL' * read_only_error - unit had an action specifier of 'READ' when it needs a specifier of 'WRITE' or 'READWRITE' * unformatted_in_error - unit did not have a form specifier of 'FORMATTED' * unopened_in_error - unit was not opened Example program demo_add_log_unit use stdlib_logger , only : global_logger , read_only_error character ( 256 ) :: iomsg integer :: iostat , unit , stat open ( newunit = unit , 'error_log.txt' , & form = 'formatted' , status = 'replace' , & position = 'rewind' , err = 999 , & action = 'read' , iostat = iostat , iomsg = iomsg ) call global_logger % add_log_unit ( unit , stat ) select case ( stat ) case ( read_only_error ) error stop 'Unable to write to \"error_log.txt\".' end select 999 error stop ' Unable to open \"error_log.txt\" . end program demo_add_log_unit configuration - report a logger's configuration Status Experimental Description Reports the configuration of a logger. Syntax call self % configuration ( [ add_blankline, indent, level, max_width, time_stamp, log_units ] ) Class Pure subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It shall be the logger whose configuration is reported. add_blank_line (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. starts output with a blank line, and .false. otherwise. indent (optional): shall be a scalar default logical variable. It\n  is an intent(out) argument. A value of .true. indents subsequent\n  lines by four spaces, and .false. otherwise. level (optional): shall be a scalar default integer variable. It is an intent(out) argument. The value corresponds to the severity level for\n  ignoring a message. max_width (optional): shall be a scalar default integer\n  variable. It is an intent(out) argument. A positive value bigger\n  than four defines the maximum width of the output, otherwise there\n  is no maximum width. time_stamp (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. precedes output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and .false. otherwise. log_units (optional): shall be a rank one allocatable array\n  variable of type default integer. It is an intent(out) argument. On return it shall be the elements of the self 's log_units array. If there were no elements in self 's log_units , a\n  zero-sized array is returned. Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) call logger % configuration ( log_units = log_units ) if ( size ( log_units ) == 0 ) then call add_logger_unit ( unit ) end if end subroutine example_sub end module example_mod configure - configure the logging process Status Experimental Description Configures the logging process for self. Syntax call self % configure ( [ add_blank_line, indent, level, max_width, time_stamp ] ) Class Pure subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to be configured. add_blank_line (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to start\n  output with a blank line, and to .false. otherwise. indent (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  indent subsequent lines by four spaces, and to .false. to\n  not indent. level (optional): shall be a scalar default integer expression. It is\n  an intent(in) argument. Set the severity level for ignoring a log\n  message. max_width (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. Set to a positive value\n  bigger than four to define the maximum width of the output,\n  otherwise there is no maximum width. time_stamp (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  precede output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and to .false. otherwise. Example program demo_configure use stdlib_logger , only : global => global_logger call global % configure ( indent = . false ., max_width = 72 ) end program demo_configure log_debug - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % log_debug ( message [, module, procedure ] ) Behavior If time stamps are active, a time stamp is written, followed\nby module and procedure if present, and then message is written with the prefix 'DEBUG: ' . It is ignored if the level of self is higher than debug_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_information call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_information call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection character ( 128 ) :: errmsg , message integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_DEBUG ( message , & module = 'EXAMPLE_MOD' , procedure = 'EXAMPLE_SUB' ) end subroutine example_sub end module example_mod log_error - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % log_error ( message [, module, procedure, stat, errmsg ] ) Behavior If time stamps are active for self , a time stamp is written,\nfollowed by module and procedure if present, then message is written with the prefix 'ERROR: ' , and then\nif stat or errmsg are present they are written. It is ignored if the level of self is higher than error_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_error call. stat (optional): shall be a scalar default integer expression. It\n  is an intent(in) argument. It should be the stat specifier of\n  the subroutine call or intrinsic statement that prompted the log_error call. errmsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the errmsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_error call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size ) integer , intent ( in ) :: size character ( 128 ) :: errmsg , message integer :: stat allocate ( a ( size ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_error ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & stat = stat , & errmsg = errmsg ) end if end subroutine example_sub end module example_mod log_information - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % log_information ( message [, module, procedure ] ) Behavior If time stamps are active, a time stamp is written, followed\nby module and procedure if present, and then message is written with the prefix 'INFO: ' . It is ignored if the level of self is higher than information_level . Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_information call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_information call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection character ( 128 ) :: errmsg , message integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_information ( message , & module = 'EXAMPLE_MOD' , procedure = 'EXAMPLE_SUB' ) end subroutine example_sub end module example_mod log_io_error - Write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\noptional additional text. Behavior If time stamps are active, a time stamp is written\nfirst. Then if module or procedure are present, they are\nwritten. Then message is written with the prefix 'I/O ERROR: ' . Then if iostat or iomsg are present they are\nwritten. It is ignored if the level of self is higher than io_error_level . Syntax call self % log_io_error ( message [, module, procedure, iostat, iomsg ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_io_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_io_error call. iostat (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the iostat specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. iomsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the iomsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. Example program demo_log_io_error use stdlib_logger , global => global_logger character ( * ), parameter :: filename = 'dummy.txt' integer :: iostat , lun character ( 128 ) :: iomsg character ( * ), parameter :: message = & 'Failure in opening \"dummy.txt\".' open ( newunit = lun , file = filename , form = 'formatted' , & status = 'old' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) then call global % log_io_error ( message , & procedure = 'EXAMPLE' , & iostat = iostat , & iomsg = iomsg ) error stop 'Error on opening a file' end if end program demo_log_io_error log_message - write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure are written if present,\nfollowed by prefix \\\\ ': ' , if present, and finally message . No severity level is applied to log_message . Syntax call self % log_message ( message [, module, procedure, prefix ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_message call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_message call. prefix (optional): shall be a scalar default character expression.\nIt is an intent(in) argument. It will precede message with an ': ' appended. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_message ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & prefix = ` INFO ' ) end subroutine example_sub end module example_mod log_text_error - send a message to self % log_units describing an error Status Experimental Description log_text_error sends a message to self % log_units describing an error found in a line of text. Behavior If time stamps are active first a time stamp is\nwritten. Then if filename or line_number are present they are\nwritten with column . Then line is written. Then a caret, '&#94;', is\nwritten below line at the column indicated by column . Then summary is written below the caret. It is ignored if the level of self is higher than text_error_level . Syntax call self % log_text_error ( line, column, summary [, filename, line_number, caret, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. line : shall be a scalar default character expression. It is an intent(in) argument. It should be the line of text in which the\n  error was found. column : shall be a scalar default integer expression. It is an intent(in) argument. It should be the one's based column at which\n  the error begins. summary : shall be a scalar default character expression. It is an intent(in) argument. It should be a description of the error in line . filename (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the file, if any, in which line was found. line_number (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the line\n  number in filename associated with line . caret (optional): shall be a scalar default single character\n  expression. It is an intent(in) argument. If present it will be\n  placed below line on output to indicate the starting location of\n  the error. It has a default value of '&#94;'. stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present it will have the value of success if no errors were encountered, the value index_invalid_error if column is less than one or greater than len(line)+1 , or the value write_fault if the writes to any of log_units failed. If stat is absent and would not have the value success then processing will stop with an informative stop code. Example program demo_log_text_error use stdlib_logger character ( * ), parameter :: filename = 'dummy.txt' integer :: col_no , line_no , lun character ( 128 ) :: line character ( * ), parameter :: message = 'Bad text found.' open ( newunit = lun , file = filename , statu = 'old' , & form = 'formatted' ) line_no = 0 do read ( lun , fmt = '(a)' , end = 900 ) line line_no = line_no + 1 call check_line ( line , status , col_no ) if ( status /= 0 ) call global_logger % log_text_error ( line , & col_no , message , filename , line_no ) error stop 'Error in reading ' // filename end if end do 900 continue end program demo_log_text_error log_units_assigned - returns the number of active I/O units Status Experimental Description Returns the number of active I/O units in self % log_units Syntax result = self % log_units_assigned () Class Elemental function Argument self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger whose state is queried. Result character The result shall be a scalar of type default integer. Result value The result is the number of I/O units in self % log_units . Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) if ( logger % log_units_assigned () == 0 ) then call logger % add_log_unit ( unit ) end if end subroutine example_sub end module example_mod log_warning - write the string message to log_units Status Experimental Description Writes the string message to log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure if present, then message is written with the prefix WARN: ' . Syntax call self % log_warning ( message [, module, procedure ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. Note message may have embedded new_line calls. module : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_warning call. procedure : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_warning call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size , stat ) integer , intent ( in ) :: size integer , intent ( out ) :: stat allocate ( a ( size ) ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_warning ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' ) end if end subroutine example_sub end module example_mod remove_log_unit - remove unit from self % log_units Status Experimental Description Remove unit from the self % log_units list. If close_unit is present and .true. then the corresponding file is\nclosed. If unit is not in self % log_units then nothing is done. Syntax call self % remove_log_unit ( unit [, close_unit, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It is the logger whose log_units is to be\nmodified. unit : shall be a scalar default integer expression. It is an intent(in) argument. It should be one of the I/O unit numbers\n  in self % log_units . If it is not, then nothing is done. close_unit (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. If .true and unit is\n  in self % log_units then unit will be closed, otherwise the I/O unit\n  will be unaffected. stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If present it has the default value of success , but has the value close_failure if close_unit is\n  present with the value .true. , and unit is initially in log_units , and closing unit fails. If stat is absent and\n  closing the unit fails then processing stops with an informative\n  stop code. Example module example_mod use stdlib_logger , global => global_logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit call global % remove_log_unit ( unit ) end subroutine example_sub end module example_mod","tags":"","loc":"page/specs/stdlib_logger.html"},{"title":"math – Fortran-lang/stdlib","text":"The stdlib_math module The stdlib_math module Introduction Procedures and Methods provided clip function Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: linspace - Create a linearly spaced rank one array Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: logspace - Create a logarithmically spaced rank one array Description Syntax Status Class Argument(s) Output value or Result value Examples Example 1: Example 2: Example 3: Introduction stdlib_math module provides general purpose mathematical functions. Procedures and Methods provided clip function Description Returns a value which lies in the given interval [ xmin , xmax ] (interval is xmin and xmax inclusive) and is closest to the input value x . Syntax res = clip (x, xmin, xmax) Status Experimental Class Elemental function. Argument(s) x : scalar of either integer or real type. This argument is intent(in) . xmin : scalar of either integer or real type. This argument is intent(in) . xmax : scalar of either integer or real type, which must be greater than or equal to xmin . This argument is intent(in) . Note: All arguments must have same type and same kind . Output value or Result value The output is a scalar of type and kind same as to that of the arguments. Examples Example 1: Here inputs are of type integer and kind int32 program demo_clip_integer use stdlib_math , only : clip use stdlib_kinds , only : int32 implicit none integer ( int32 ) :: x integer ( int32 ) :: xmin integer ( int32 ) :: xmax integer ( int32 ) :: clipped_value xmin = - 5_int32 xmax = 5_int32 x = 12_int32 clipped_value = clip ( x , xmin , xmax ) ! clipped_value <- 5 end program demo_clip_integer Example 2: Here inputs are of type real and kind sp program demo_clip_real use stdlib_math , only : clip use stdlib_kinds , only : sp implicit none real ( sp ) :: x real ( sp ) :: xmin real ( sp ) :: xmax real ( sp ) :: clipped_value xmin = - 5.769_sp xmax = 3.025_sp x = 3.025_sp clipped_value = clip ( x , xmin , xmax ) ! clipped_value <- 3.02500010 end program demo_clip_real linspace - Create a linearly spaced rank one array Description Returns a linearly spaced rank 1 array from [ start , end ]. Optionally, you can specify the length of the returned array by passing n . Syntax res = linspace (start, end [, n]) Status Experimental Class Function. Argument(s) start : Shall be scalar of any numeric type or kind. This argument is intent(in) . end : Shall be the same type and kind as start . This argument is intent(in) . n : Shall be an integer specifying the length of the output. This argument is optional and intent(in) . Output value or Result value The output is a rank 1 array whose length is either 100 (default value) or n . If n == 1, return a rank 1 array whose only element is end .\nIf n <= 0, return a rank 1 array with length 0. If start / end are real or complex types, the result will be of the same type and kind as start / end .\nIf start / end are integer types, the result will default to a real(dp) array. Examples Example 1: Here inputs are of type complex and kind dp program demo_linspace_complex use stdlib_math , only : linspace use stdlib_kinds , only : dp implicit none complex ( dp ) :: start = complex ( 1 0.0_dp , 5.0_dp ) complex ( dp ) :: end = complex ( - 1 0.0_dp , 1 5.0_dp ) complex ( dp ) :: z ( 11 ) z = linspace ( start , end , 11 ) end program demo_linspace_complex Example 2: Here inputs are of type integer and kind int16 , with the result defaulting to real(dp) . program demo_linspace_int16 use stdlib_math , only : linspace use stdlib_kinds , only : int16 , dp implicit none integer ( int16 ) :: start = 10_int16 integer ( int16 ) :: end = 23_int16 real ( dp ) :: r ( 15 ) r = linspace ( start , end , 15 ) end program demo_linspace_int16 logspace - Create a logarithmically spaced rank one array Description Returns a logarithmically spaced rank 1 array from [ base &#94; start , base &#94; end ]. The default size of the array is 50. Optionally, you can specify the length of the returned array by passing n . You can also specify the base used to compute the range (default 10). Syntax res = logspace (start, end [, n [, base]]) Status Experimental Class Function. Argument(s) start : Shall be a scalar of any numeric type. All kinds are supported for real and complex arguments. For integers, only the default kind is currently implemented. This argument is intent(in) . end : Shall be the same type and kind as start . This argument is intent(in) . n : Shall be an integer specifying the length of the output. This argument is optional and intent(in) . base : Shall be a scalar of any numeric type. All kinds are supported for real and complex arguments. For integers, only the default kind is currently implemented. This argument is optional and intent(in) . Output value or Result value The output is a rank 1 array whose length is either 50 (default value) or n . If n == 1, return a rank 1 array whose only element is base &#94; end .\nIf n <= 0, return a rank 1 array with length 0 The type and kind of the output is dependent on the type and kind of the passed parameters. For function calls where the base is not specified: logspace(start, end) / logspace(start, end, n) , the type and kind of\nthe output follows the same scheme as above for linspace . If start / end are real or complex types, the result will be the same type and kind as start / end .\nIf start / end are integer types, the result will default to a real(dp) array. For function calls where the base is specified, the type and kind of the result is in accordance with the following table: start / end n base output real(KIND) Integer real(KIND) real(KIND) \"          \" \"       \" complex(KIND) complex(KIND) \"          \" \"       \" Integer real(KIND) complex(KIND) \"       \" real(KIND) complex(KIND) \"             \" \"       \" complex(KIND) complex(KIND) \"             \" \"       \" Integer complex(KIND) Integer \"        \" real(KIND) real(KIND) \"              \" \"        \" complex(KIND) complex(KIND) \"              \" \"        \" Integer Integer Examples Example 1: Here inputs are of type complex and kind dp . n and base is not specified and thus default to 50 and 10, respectively. program demo_logspace_complex use stdlib_math , only : logspace use stdlib_kinds , only : dp implicit none complex ( dp ) :: start = ( 1 0.0_dp , 5.0_dp ) complex ( dp ) :: end = ( - 1 0.0_dp , 1 5.0_dp ) complex ( dp ) :: z ( 11 ) ! Complex values raised to complex powers results in complex values z = logspace ( start , end , 11 ) end program demo_logspace_complex Example 2: Here inputs are of type integer and default kind. base is not specified and thus defaults to 10. program demo_logspace_int use stdlib_math , only : logspace use stdlib_kinds , only : dp implicit none integer :: start = 10 integer :: end = 23 integer :: n = 15 real ( dp ) :: r ( n ) ! Integer values raised to real powers results in real values r = logspace ( start , end , n ) end program demo_logspace_int Example 3: Here start / end are of type real and double precision. base is type complex and also double precision. program demo_logspace_rstart_cbase use stdlib_math , only : logspace use stdlib_kinds , only : dp implicit none real ( dp ) :: start = 0.0_dp real ( dp ) :: end = 3.0_dp integer :: n = 4 complex ( dp ) :: base = ( 0.0_dp , 1.0_dp ) complex ( dp ) :: z ( n ) ! complex values raised to real powers result in complex values z = logspace ( start , end , n , base ) end program demo_logspace_rstart_cbase","tags":"","loc":"page/specs/stdlib_math.html"},{"title":"optval – Fortran-lang/stdlib","text":"Default values for optional arguments Default values for optional arguments optval - fallback value for optional arguments Status Description Syntax Arguments Return value Example optval - fallback value for optional arguments Status Experimental Description Returns x if it is present, otherwise default . This function is intended to be called in a procedure with one or more optional arguments, in order to conveniently fall back to a default value if an optional argument is not present. Syntax result = optval (x, default) Arguments x : Shall be of type integer , real , complex , or logical , or a scalar of type character . default : Shall have the same type, kind, and rank as x . Return value If x is present, the result is x , otherwise the result is default . Example program demo_optval use stdlib_optval , only : optval implicit none print * , root ( 6 4.0 ) ! 8.0 print * , root ( 6 4.0 , 3 ) ! 4.0 contains real function root ( x , n ) real , intent ( in ) :: x integer , intent ( in ), optional :: n root = x ** ( 1.0 / optval ( n , 2 )) end function root end program demo_optval","tags":"","loc":"page/specs/stdlib_optval.html"},{"title":"quadrature – Fortran-lang/stdlib","text":"Numerical integration Numerical integration trapz - integrate sampled values using trapezoidal rule Status Description Syntax Arguments Return value Example trapz_weights - trapezoidal rule weights for given abscissas Status Description Syntax Arguments Return value Example simps - integrate sampled values using Simpson's rule Status Description Syntax Arguments Return value Example simps_weights - Simpson's rule weights for given abscissas Status Description Syntax Arguments Return value Example gauss_legendre - Gauss-Legendre quadrature (a.k.a. Gaussian quadrature) nodes and weights Status Description Syntax Arguments Example gauss_legendre_lobatto - Gauss-Legendre-Lobatto quadrature nodes and weights Status Description Syntax Arguments Example trapz - integrate sampled values using trapezoidal rule Status Experimental Description Returns the trapezoidal rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Syntax result = trapz (y, x) result = trapz (y, dx) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. Example program demo_trapz use stdlib_quadrature , only : trapz implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 print * , trapz ( y , x ) ! 22.0 print * , trapz ( y , 0.5 ) ! 11.0 end program demo_trapz trapz_weights - trapezoidal rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a trapezoidal rule approximation to the integral. Syntax result = trapz_weights (x) Arguments x : Shall be a rank-one array of type real . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. Example program demo_trapz_weights use stdlib_quadrature , only : trapz_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 real :: w ( 5 ) w = trapz_weights ( x ) print * , sum ( w * y ) ! 22.0 end program demo_trapz_weights simps - integrate sampled values using Simpson's rule Status Experimental Description Returns the Simpson's rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and these two results were averaged. Syntax result = simps (y, x [, even]) result = simps (y, dx [, even]) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . even : (Optional) Shall be a default-kind integer . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. If the size of y is two, the result is the same as if trapz had been called instead. Example program demo_simps use stdlib_quadrature , only : simps implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 print * , simps ( y , x ) ! 64.0 print * , simps ( y , 0.5 ) ! 32.0 end program demo_simps simps_weights - Simpson's rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a Simpson's rule approximation to the integral. Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array and the 1/3 rule used elsewhere. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and then these two results were averaged. Syntax result = simps_weights (x [, even]) Arguments x : Shall be a rank-one array of type real . even : (Optional) Shall be a default-kind integer . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. If the size of x is two, then the result is the same as if trapz_weights had been called instead. Example program demo_simps_weights use stdlib_quadrature , only : simps_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 real :: w ( 5 ) w = simps_weights ( x ) print * , sum ( w * y ) ! 64.0 end program demo_simps_weights gauss_legendre - Gauss-Legendre quadrature (a.k.a. Gaussian quadrature) nodes and weights Status Experimental Description Computes Gauss-Legendre quadrature (also known as simply Gaussian quadrature) nodes and weights,\n for any N (number of nodes).\nUsing the nodes x and weights w , you can compute the integral of some function f as follows: integral = sum(f(x) * w) . Only double precision is supported - if lower precision is required, you must do the appropriate conversion yourself.\nAccuracy has been validated up to N=64 by comparing computed results to tablulated values known to be accurate to machine precision\n(maximum difference from those values is 2 epsilon). Syntax subroutine gauss_legendre (x, w[, interval]) Arguments x : Shall be a rank-one array of type real(real64) . It is an output argument, representing the quadrature nodes. w : Shall be a rank-one array of type real(real64) , with the same dimension as x . \nIt is an output argument, representing the quadrature weights. interval : (Optional) Shall be a two-element array of type real(real64) . \nIf present, the nodes and weigts are calculated for integration from interval(1) to interval(2) .\nIf not specified, the default integral is -1 to 1. Example program integrate use iso_fortran_env , dp => real64 implicit none integer , parameter :: N = 6 real ( dp ), dimension ( N ) :: x , w call gauss_legendre ( x , w ) print * , \"integral of x**2 from -1 to 1 is\" , sum ( x ** 2 * w ) end program gauss_legendre_lobatto - Gauss-Legendre-Lobatto quadrature nodes and weights Status Experimental Description Computes Gauss-Legendre-Lobatto quadrature nodes and weights,\n for any N (number of nodes).\nUsing the nodes x and weights w , you can compute the integral of some function f as follows: integral = sum(f(x) * w) . Only double precision is supported - if lower precision is required, you must do the appropriate conversion yourself.\nAccuracy has been validated up to N=64 by comparing computed results to tablulated values known to be accurate to machine precision\n(maximum difference from those values is 2 epsilon). Syntax subroutine gauss_legendre_lobatto (x, w[, interval]) Arguments x : Shall be a rank-one array of type real(real64) . It is an output argument, representing the quadrature nodes. w : Shall be a rank-one array of type real(real64) , with the same dimension as x . \nIt is an output argument, representing the quadrature weights. interval : (Optional) Shall be a two-element array of type real(real64) . \nIf present, the nodes and weigts are calculated for integration from interval(1) to interval(2) .\nIf not specified, the default integral is -1 to 1. Example program integrate use iso_fortran_env , dp => real64 implicit none integer , parameter :: N = 6 real ( dp ), dimension ( N ) :: x , w call gauss_legendre_lobatto ( x , w ) print * , \"integral of x**2 from -1 to 1 is\" , sum ( x ** 2 * w ) end program","tags":"","loc":"page/specs/stdlib_quadrature.html"},{"title":"Sorting Procedures – Fortran-lang/stdlib","text":"The stdlib_sorting module The stdlib_sorting module Overview of sorting Overview of the module The int_size parameter The module subroutines Licensing The ORD_SORT subroutine The SORT_INDEX subroutine The SORT subroutine Specifications of the stdlib_sorting procedures ord_sort - sorts an input array Status Description Syntax Class Arguments Notes Example sort - sorts an input array Status Description Syntax Class Arguments Notes Example sort_index - creates an array of sorting indices for an input array, while also sorting the array. Status Description Syntax Class Arguments Notes Examples Performance benchmarks Overview of sorting The sorting of collections of data is useful in the analysis of those\ncollections.\nWith its absence of generics and limited polymorphism, it is\nimpractical, in current Fortran, to provide sorting routines for\narbitrary collections of arbitrary types of data.\nHowever Fortran's arrays are by far its most widely used collection,\nand arrays of arbitrary types of data can often be sorted in terms of\na single component of intrinsic type.\nThe Fortran Standard Library therefore provides a module, stdlib_sorting , with procedures to sort arrays of simple intrinsic\nnumeric types, i.e. the different kinds of integers and reals, the\ndefault assumed length character, and the stdlib_string_type module's string_type type. Overview of the module The module stdlib_sorting defines several public entities, one\ndefault integer parameter, int_size , and three overloaded\nsubroutines: ORD_SORT , SORT , and SORT_INDEX . The\noverloaded subroutines also each have seven specific names for\nversions corresponding to different types of array arguments. The int_size parameter The int_size parameter is used to specify the kind of integer used\nin indexing the various arrays. Currently the module sets int_size to the value of int64 from the stdlib_kinds module. The module subroutines The stdlib_sorting module provides three different overloaded\nsubroutines intended to sort three different kinds of arrays of\ndata:\n* ORD_SORT is intended to sort simple arrays of intrinsic data\n  that have significant sections that were partially ordered before\n  the sort;\n* SORT_INDEX is based on ORD_SORT , but in addition to sorting the\n  input array, it returns indices that map the original array to its\n  sorted version. This enables related arrays to be re-ordered in the\n  same way; and\n* SORT is intended to sort simple arrays of intrinsic data\n  that are effectively unordered before the sort. Licensing The Fortran Standard Library is distributed under the MIT\nLicense. However components of the library may be based on code with\nadditional licensing restrictions. In particular ORD_SORT , SORT_INDEX , and SORT are translations of codes with their\nown distribution restrictions. The ORD_SORT and SORT_INDEX subroutines are essentially\ntranslations to Fortran 2008 of the \"Rust\" sort of the Rust Language\ndistributed as part of slice.rs .\nThe header of the slice.rs file has as its licensing requirements: Copyright 2012 - 2015 The Rust Project Developers . See the COPYRIGHT file at the top - level directory of this distribution and at http : // rust - lang . org / COPYRIGHT . Licensed under the Apache License , Version 2 . 0 < LICENSE - APACHE or http : // www . apache . org / licenses / LICENSE - 2 . 0 > or the MIT license < LICENSE - MIT or http : // opensource . org / licenses / MIT > , at your option . This file may not be copied , modified , or distributed except according to those terms . So the license for the slice.rs code is compatible with the use of\nmodified versions of the code in the Fortran Standard Library under\nthe MIT license. The SORT subroutine is essentially a translation to Fortran\n2008 of the\n[ introsort ]((http://www.cs.rpi.edu/~musser/gp/introsort.ps) of David\nMusser.  David Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license\nprovided we cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,” Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. The ORD_SORT subroutine ORD_SORT is a translation of the \"Rust\" sort sorting algorithm\ncontained in [ slice.rs ]\n(https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs). \"Rust\" sort , in turn, is inspired by the [ timsort algorithm]\n(http://svn.python.org/projects/python/trunk/Objects/listsort.txt)\nthat Tim Peters created for the Python Language. ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\nand insertion sort . It has always at worst O(N Ln(N)) runtime\nperformance in sorting random data, having a performance about 15-25%\nslower than SORT on such data. However it has much better\nperformance than SORT on partially sorted data, having O(N)\nperformance on uniformly increasing or decreasing data. When sorting in an increasing order, ORD_SORT begins by traversing the array\nstarting in its tail attempting to identify runs in the array, where a run is\neither a uniformly decreasing sequence, ARRAY(i-1) > ARRAY(i) , or a\nnon-decreasing, ARRAY(i-1) <= ARRAY(i) , sequence. First delimited decreasing\nsequences are reversed in their order. Then, if the sequence has less than MIN_RUN elements, previous elements in the array are added to the run using insertion sort until the run contains MIN_RUN elements or the array is\ncompletely processed. As each run is identified the start and length of the run\nare then pushed onto a stack and the stack is then processed using merge until\nit obeys the stack invariants: len(i-2) > len(i-1) + len(i) len(i-1) > len(i) ensuring that processing the stack is, at worst, of order O(N\nLn(N)) . However, because of the identification of decreasing and\nnon-decreasing runs, processing of structured data can be much faster,\nwith processing of uniformly decreasing or non-decreasing arrays being\nof order O(N). The result in our tests is that ORD_SORT is about\n25% slower than SORT on purely random data, depending on\nthe compiler, but can be Ln(N) faster than SORT on highly\nstructured data. As a modified merge sort , ORD_SORT requires the\nuse of a \"scratch\" array, that may be provided as an optional work argument or allocated internally on the stack. Arrays can be also sorted in a decreasing order by providing the argument reverse\n= .true. . The SORT_INDEX subroutine The SORT and ORD_SORT subroutines can sort rank 1 isolated\narrays of intrinsic types, but do nothing for the coordinated sorting\nof related data, e.g., multiple related rank 1 arrays, higher rank\narrays, or arrays of derived types. For such related data, what is\nuseful is an array of indices that maps a rank 1 array to its sorted\nform. For such a sort, a stable sort is useful, therefore the module\nprovides a subroutine, SORT_INDEX , that generates such an array of\nindices based on the ORD_SORT algorithm, in addition to sorting\nthe input array. The logic of SORT_INDEX parallels that of ORD_SORT , with\nadditional housekeeping to keep the array of indices consistent with\nthe sorted positions of the input array. Because of this additional\nhousekeeping it has slower runtime performance than ORD_SORT . SORT_INDEX requires the use of two \"scratch\" arrays, that may be\nprovided as optional work and iwork arguments or allocated\ninternally on the stack. The SORT subroutine SORT uses the introsort sorting algorithm of David Musser. introsort is a hybrid unstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm's\nruntime performance is always O(N Ln(N)), it is relatively fast on\nrandomly ordered data, but does not show the improvement in\nperformance on partly sorted data found for ORD_SORT . First it examines the array and estimates the depth of recursion a\nquick sort would require for ideal (random) data, D =\nCeiling(Ln(N)/Ln(2)) . It then defines a limit to the number of quicksort recursions to be allowed in processing, D_limit = factor * D , where factor is currently 2, and\ncalls introsort proper. introsort proper then: Examines the number of elements remaining to be sorted, and, if\n   they are less than 16, sorts them using insertion sort and returns; If they are not less than 16, checks whether the current depth of\n   recursion exceeds D_limit and, if it does, processes the remaining\n   elements with heap sort and returns; If the current depth of recursion does not exceed D_limit , then\n   in effect does a quicksort step: Partitions the remaining array using a median of three, Calls introsort proper on the leftmost partition, Calls introsort proper on the rightmost partition, and then\n  returns. The resulting algorithm is of order O(N Ln(N)) run time performance\nfor all inputs. Because it relies on quicksort , the coefficient of\nthe O(N Ln(N)) behavior is typically small compared to other sorting\nalgorithms on random data. On partially sorted data it can show either\nslower heap sort performance, or enhanced performance by up to a\nfactor of six. Still, even when it shows enhanced performance, its\nperformance on partially sorted data is typically an order of\nmagnitude slower than ORD_SORT . Its memory requirements are also\nlow, being of order O(Ln(N)), while the memory requirements of ORD_SORT and SORT_INDEX are of order O(N). Specifications of the stdlib_sorting procedures ord_sort - sorts an input array Status Experimental Description Returns an input array with the elements sorted in order of\nincreasing, or decreasing, value. Syntax call ord_sort ( array[, work, reverse ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) , character(*) , or type(string_type) . It is an intent(inout) argument. On input it is\nthe array to be sorted. If both the type of array is real and at\nleast one of the elements is a NaN , then the ordering of the result\nis undefined. Otherwise on return its elements will be sorted in order\nof non-decreasing value. work (optional): shall be a rank one array of the same type as\narray, and shall have at least size(array)/2 elements. It is an intent(out) argument. It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in stable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in stable order. Notes ORD_SORT implements a hybrid sorting algorithm combining merge sort , and insertion sort . For most purposes it behaves like\na merge sort , providing worst case O(N Ln(N)) run time performance\nfor most random arrays, that is typically slower than SORT .\nHowever, if the array has significant runs of decreasing or\nnon-decreasing values, performance can be much better than SORT , with O(N) behavior on uniformly decreasing, or\nnon-decreasing arrays. The optional work array replaces \"scratch\"\nmemory that would otherwise be allocated on the stack. If array is of\nany type REAL the order of its elements on return undefined if any\nelement of array is a NaN .  Sorting of CHARACTER(*) and STRING_TYPE arrays are based on the operators > and < , and not on the\nfunction LGT . Example program demo_ord_sort use stdlib_sorting , only : ord_sort implicit none integer , allocatable :: array1 (:), work (:) array1 = [ 5 , 4 , 3 , 1 , 10 , 4 , 9 ] allocate ( work , mold = array1 ) call ord_sort ( array1 , work ) print * , array1 !print [1, 3, 4, 4, 5, 9, 10] end program demo_ord_sort sort - sorts an input array Status Experimental Description Returns an input array with the elements sorted in order of increasing, or\ndecreasing, value. Syntax call sort ( array[, reverse] ) Class Pure generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) . character(*) , or type(string_type) . It is an intent(inout) argument. On return its\ninput elements will be sorted in order of non-decreasing value. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in unstable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in unstable order. Notes SORT implements a hybrid sorting algorithm combining quicksort , merge sort , and insertion sort . For most purposes it\nbehaves like a quicksort with a median of three partition, providing\ngood, O(N Ln(N)) , run time performance for most random arrays, but\ndefaulting to merge sort if the structure of the array results in\nthe quicksort not converging as rapidly as expected. If array is of\nany type REAL , the behavior of the sorting is undefined if any\nelement of array is a NaN .  Sorting of CHARACTER(*) and STRING_TYPE arrays are based on the operators < , <= , > , and >= , and not on the functions LLT , LLE , LGT , or LGE . Example program demo_sort use stdlib_sorting , only : sort implicit none integer , allocatable :: array (:) array = [ 5 , 4 , 3 , 1 , 10 , 4 , 9 ] call sort ( array ) print * , array !print [1, 3, 4, 4, 5, 9, 10] end program demo_sort sort_index - creates an array of sorting indices for an input array, while also sorting the array. Status Experimental Description Returns the input array sorted in the direction requested while\nretaining order stability, and an integer array whose elements would\nsort the input array to produce the output array . Syntax call sort_index ( array, index[, work, iwork, reverse ] ) Class Generic subroutine. Arguments array : shall be a rank one array of any of the types: integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(sp) , real(dp) , real(qp) , character(*) , or type(string_type) . It is an intent(inout) argument. On input it\nwill be an array whose sorting indices are to be determined. On return\nit will be the sorted array. index : shall be a rank one integer array of kind int_size and of\nthe size of array . It is an intent(out) argument. On return it\nshall have values that are the indices needed to sort the original\narray in the desired direction. work (optional): shall be a rank one array of any of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument. It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. iwork (optional): shall be a rank one integer array of kind int_size , and shall have at least size(array)/2 elements. It\nis an intent(out) argument.  It is intended to be used as \"scratch\"\nmemory for internal record keeping. If associated with an array in\nstatic storage, its use can significantly reduce the stack memory\nrequirements for the code. Its contents on return are undefined. reverse (optional): shall be a scalar of type default logical. It\nis an intent(in) argument. If present with a value of .true. then index will sort array in order of non-increasing values in stable\norder. Otherwise index will sort array in order of non-decreasing\nvalues in stable order. Notes SORT_INDEX implements the hybrid sorting algorithm of ORD_SORT ,\nkeeping the values of index consistent with the elements of array as it is sorted. As a merge sort based algorithm, it is a stable\nsorting comparison algorithm. The optional work and iwork arrays\nreplace \"scratch\" memory that would otherwise be allocated on the\nstack. If array is of any kind of REAL the order of the elements in index and array on return are undefined if any element of array is a NaN . Sorting of CHARACTER(*) and STRING_TYPE arrays are\nbased on the operator > , and not on the function LGT . It should be emphasized that the order of array will typically be\ndifferent on return Examples Sorting a related rank one array: subroutine sort_related_data ( a , b , work , index , iwork ) ! Sort `a`, and  also  sort `b` to be reorderd the same way as `a` integer , intent ( inout ) :: a (:) integer ( int32 ), intent ( inout ) :: b (:) ! The same size as a integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) ! Find the indices to sort a call sort_index ( a , index ( 1 : size ( a )),& work ( 1 : size ( a ) / 2 ), iwork ( 1 : size ( a ) / 2 )) ! Sort b based on the sorting of a b (:) = b ( index ( 1 : size ( a )) ) end subroutine sort_related_data Sorting a rank 2 array based on the data in a column subroutine sort_related_data ( array , column , work , index , iwork ) ! Reorder rows of `array` such that `array(:, column)` is  sorted integer , intent ( inout ) :: array (:,:) integer ( int32 ), intent ( in ) :: column integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) integer , allocatable :: dummy (:) integer :: i allocate ( dummy ( size ( array , dim = 1 ))) ! Extract a column of `array` dummy (:) = array (:, column ) ! Find the indices to sort the column call sort_index ( dummy , index ( 1 : size ( dummy )),& work ( 1 : size ( dummy ) / 2 ), iwork ( 1 : size ( dummy ) / 2 )) ! Sort a based on the sorting of its column do i = 1 , size ( array , dim = 2 ) array (:, i ) = array ( index ( 1 : size ( array , dim = 1 )), i ) end do end subroutine sort_related_data Sorting an array of a derived type based on the data in one component subroutine sort_a_data ( a_data , a , work , index , iwork ) ! Sort `a_data` in terms or its component `a` type ( a_type ), intent ( inout ) :: a_data (:) integer ( int32 ), intent ( inout ) :: a (:) integer ( int32 ), intent ( out ) :: work (:) integer ( int_size ), intent ( out ) :: index (:) integer ( int_size ), intent ( out ) :: iwork (:) ! Extract a component of `a_data` a ( 1 : size ( a_data )) = a_data (:) % a ! Find the indices to sort the component call sort_index ( a ( 1 : size ( a_data )), index ( 1 : size ( a_data )),& work ( 1 : size ( a_data ) / 2 ), iwork ( 1 : size ( a_data ) / 2 )) ! Sort a_data based on the sorting of that component a_data (:) = a_data ( index ( 1 : size ( a_data )) ) end subroutine sort_a_data Performance benchmarks We have performed benchmarks of the procedures on nine different\ninteger arrays each of size 2**16 : Blocks - the array is divided into six blocks, each of distinct\n  uniformly increasing integers. Decreasing - values decrease uniformly from 2**16-1 to 0 . Identical - all integers have the same value of 10. Increasing - values increase uniformly from 0 to 2**16-1 . Random dense - the integers are generated randomly from a set of\n  values from 0 to 2**14-1 so duplicates are dense. Random order - a set of integers from 0 to 2**16 - 1 in random\n  order. Random sparse - the integers are generated randomly from a set of\n  values from 0 to 2**18-1 so duplicates are sparse. Random-3 - the increasing array has 3 random exchanges of individual\n  elements. Random-10 - the final ten elements of the increasing array are\n  replaced by random values. On three different default character arrays, each of length 4 and of\nsize `20**4, with characters drawn from the set \"a\"-\"p\": Char. Decreasing - values decrease uniformly from \"pppp\" to \"aaaa\" . Char. Increasing - values decrease uniformly from \"aaaa\" to \"pppp\" . Char. Random - the set of strings from \"aaaa\" to \"pppp\" in\n  random order. On three different string_type arrays, each of length 4 elements and\nof size 16**3 , with characters drawn from the set \"a\"-\"p\": String Decreasing - values decrease uniformly from \"ppp\" to \"aaa\" . String Increasing - values decrease uniformly from \"aaa\" to \"ppp\" . String Random - the set of strings from \"aaa\" to \"ppp\" in\n  random order. These benchmarks have been performed on two different compilers, both\non a MacBook Pro, featuring a 2.3 GHz Quad-Core Intel Core i5, with 8\nGB 2133 MHz LPDDR3 memory. The first compiler was GNU Fortran\n(GCC) 10.2.0, with the following results: Type Elements Array Name Method Time (s) Integer 65536 Blocks Ord_Sort 0.000579 Integer 65536 Decreasing Ord_Sort 0.000212 Integer 65536 Identical Ord_Sort 0.000165 Integer 65536 Increasing Ord_Sort 0.000131 Integer 65536 Random dense Ord_Sort 0.009991 Integer 65536 Random order Ord_Sort 0.008574 Integer 65536 Random sparse Ord_Sort 0.010504 Integer 65536 Random 3 Ord_Sort 0.000532 Integer 65536 Random 10 Ord_Sort 0.000315 Character 65536 Char. Decrease Ord_Sort 0.001041 Character 65536 Char. Increase Ord_Sort 0.000584 Character 65536 Char. Random Ord_Sort 0.026273 String_type 4096 String Decrease Ord_Sort 0.001202 String_type 4096 String Increase Ord_Sort 0.000758 String_type 4096 String Random Ord_Sort 0.018180 Integer 65536 Blocks Sort 0.005073 Integer 65536 Decreasing Sort 0.005830 Integer 65536 Identical Sort 0.007372 Integer 65536 Increasing Sort 0.002421 Integer 65536 Random dense Sort 0.007006 Integer 65536 Random order Sort 0.007211 Integer 65536 Random sparse Sort 0.007109 Integer 65536 Random 3 Sort 0.012232 Integer 65536 Random 10 Sort 0.017345 Character 65536 Char. Decrease Sort 0.031350 Character 65536 Char. Increase Sort 0.011606 Character 65536 Char. Random Sort 0.022440 String_type 4096 String Decrease Sort 0.026539 String_type 4096 String Increase Sort 0.009755 String_type 4096 String Random Sort 0.016218 Integer 65536 Blocks Sort_Index 0.000953 Integer 65536 Decreasing Sort_Index 0.000418 Integer 65536 Identical Sort_Index 0.000264 Integer 65536 Increasing Sort_Index 0.000262 Integer 65536 Random dense Sort_Index 0.009563 Integer 65536 Random order Sort_Index 0.009592 Integer 65536 Random sparse Sort_Index 0.009691 Integer 65536 Random 3 Sort_Index 0.000781 Integer 65536 Random 10 Sort_Index 0.000455 Character 65536 Char. Decrease Sort_Index 0.001189 Character 65536 Char. Increase Sort_Index 0.000752 Character 65536 Char. Random Sort_Index 0.025767 String_type 4096 String Decrease Sort_Index 0.001411 String_type 4096 String Increase Sort_Index 0.000761 String_type 4096 String Random Sort_Index 0.018202 The second compiler was Intel(R) Fortran Intel(R) 64 Compiler Classic\nfor applications running on Intel(R) 64, Version 2021.2.0 Build\n20210228_000000, with the following results: Type Elements Array Name Method Time (s) Integer 65536 Blocks Ord_Sort 0.000267 Integer 65536 Decreasing Ord_Sort 0.000068 Integer 65536 Identical Ord_Sort 0.000056 Integer 65536 Increasing Ord_Sort 0.000056 Integer 65536 Random dense Ord_Sort 0.004615 Integer 65536 Random order Ord_Sort 0.006325 Integer 65536 Random sparse Ord_Sort 0.004601 Integer 65536 Random 3 Ord_Sort 0.000193 Integer 65536 Random 10 Ord_Sort 0.000101 Character 65536 Char. Decrease Ord_Sort 0.001009 Character 65536 Char. Increase Ord_Sort 0.000529 Character 65536 Char. Random Ord_Sort 0.024547 String_type 4096 String Decrease Ord_Sort 0.003381 String_type 4096 String Increase Ord_Sort 0.000133 String_type 4096 String Random Ord_Sort 0.051985 Integer 65536 Blocks Sort 0.001614 Integer 65536 Decreasing Sort 0.001783 Integer 65536 Identical Sort 0.002111 Integer 65536 Increasing Sort 0.000674 Integer 65536 Random dense Sort 0.003574 Integer 65536 Random order Sort 0.003296 Integer 65536 Random sparse Sort 0.003380 Integer 65536 Random 3 Sort 0.003623 Integer 65536 Random 10 Sort 0.006839 Character 65536 Char. Decrease Sort 0.032564 Character 65536 Char. Increase Sort 0.012346 Character 65536 Char. Random Sort 0.022932 String_type 4096 String Decrease Sort 0.082140 String_type 4096 String Increase Sort 0.029591 String_type 4096 String Random Sort 0.043078 Integer 65536 Blocks Sort_Index 0.000848 Integer 65536 Decreasing Sort_Index 0.000103 Integer 65536 Identical Sort_Index 0.000102 Integer 65536 Increasing Sort_Index 0.000066 Integer 65536 Random dense Sort_Index 0.006434 Integer 65536 Random order Sort_Index 0.005941 Integer 65536 Random sparse Sort_Index 0.005957 Integer 65536 Random 3 Sort_Index 0.000326 Integer 65536 Random 10 Sort_Index 0.000175 Character 65536 Char. Decrease Sort_Index 0.001082 Character 65536 Char. Increase Sort_Index 0.000468 Character 65536 Char. Random Sort_Index 0.023100 String_type 4096 String Decrease Sort_Index 0.003292 String_type 4096 String Increase Sort_Index 0.000122 String_type 4096 String Random Sort_Index 0.049155","tags":"","loc":"page/specs/stdlib_sorting.html"},{"title":"specialfunctions – Fortran-lang/stdlib","text":"Special functions Special functions legendre - Calculate Legendre polynomials Status Description Syntax Arguments Return value dlegendre - Calculate first derivatives of Legendre polynomials Status Description Syntax Arguments Return value legendre - Calculate Legendre polynomials Status Experimental Description Computes the value of the n-th Legendre polynomial at a specified point.\nCurrently only 64 bit floating point is supported. This is an elemental function. Syntax result = legendre (n, x) Arguments n : Shall be a scalar of type real(real64) . x : Shall be a scalar or array (this function is elemental) of type real(real64) . Return value The function result will be the value of the n -th Legendre polynomial, evaluated at x . dlegendre - Calculate first derivatives of Legendre polynomials Status Experimental Description Computes the value of the first derivative of the n-th Legendre polynomial at a specified point.\nCurrently only 64 bit floating point is supported. This is an elemental function. Syntax result = dlegendre (n, x) Arguments n : Shall be a scalar of type real(real64) . x : Shall be a scalar or array (this function is elemental) of type real(real64) . Return value The function result will be the value of the first derivative of the n -th Legendre polynomial, evaluated at x .","tags":"","loc":"page/specs/stdlib_specialfunctions.html"},{"title":"stats – Fortran-lang/stdlib","text":"Descriptive statistics Descriptive statistics corr - Pearson correlation of array elements Status Description Syntax Arguments Return value Example cov - covariance of array elements Status Description Syntax Arguments Return value Example mean - mean of array elements Status Description Syntax Arguments Return value Example moment - central moments of array elements Status Description Syntax Arguments Return value Example var - variance of array elements Status Description Syntax Arguments Return value Example corr - Pearson correlation of array elements Status Experimental Description Returns the Pearson correlation of the elements of array along dimension dim if the corresponding element in mask is true . The Pearson correlation between two rows (or columns), say x and y , of array is defined as: corr(x, y) = cov(x, y) / sqrt( var(x) * var(y)) Syntax result = corr (array, dim [, mask]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of rank 1 and of type real or complex , the result is of type real and has the same kind as array .\nIf array is of rank 2 and of type real or complex , the result is of the same type and kind as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1 and of size larger than 1, a scalar equal to 1 is returned. Otherwise, IEEE NaN is returned.\nIf array is of rank 2, a rank-2 array  with the corresponding correlations is returned. If mask is specified, the result is the Pearson correlation of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_corr use stdlib_stats , only : corr implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ - 1. , 4 0. , - 3. , 4. , 1 0. , 6. ], [ 2 , 3 ]) print * , corr ( x , 1 ) !returns 1. print * , corr ( y , 2 ) !returns reshape([ 1., -.32480, -.32480, 1. ], [ 2, 3]) end program demo_corr cov - covariance of array elements Status Experimental Description Returns the covariance of the elements of array along dimension dim if the corresponding element in mask is true . Per default, the covariance is defined as: cov(array) = 1/(n-1) sum_i (array(i) - mean(array) * (array(i) - mean(array))) where n is the number of elements. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = cov (array, dim [, mask [, corrected]]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of rank 1 and of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of rank 2 and of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1, a scalar with the covariance (that is the variance) of all elements in array is returned.\nIf array is of rank 2, a rank-2 array is returned. If mask is specified, the result is the covariance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_cov use stdlib_stats , only : cov implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , cov ( x , 1 ) !returns 3.5 print * , cov ( x , 1 , corrected = . false .) !returns 2.9167 print * , cov ( y , 1 ) !returns a square matrix of size 3 with all elements equal to 0.5 end program demo_cov mean - mean of array elements Status Experimental Description Returns the mean of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Syntax result = mean (array [, mask]) result = mean (array, dim [, mask]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the mean of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the mean of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_mean use stdlib_stats , only : mean implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , mean ( x ) !returns 3.5 print * , mean ( y ) !returns 3.5 print * , mean ( y , 1 ) !returns [ 1.5, 3.5, 5.5 ] print * , mean ( y , 1 , y > 3. ) !returns [ NaN, 4.0, 5.5 ] end program demo_mean moment - central moments of array elements Status Experimental Description Returns the k -th order central moment of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . If a scalar or an array center is provided, the function returns the k -th order moment about 'center', of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . The k -th order central moment is defined as : moment(array) = 1/n sum_i (array(i) - mean(array))&#94;k where n is the number of elements. The k -th order moment about center is defined as : moment(array) = 1/n sum_i (array(i) - center)&#94;k Syntax result = moment (array, order [, center [, mask]]) result = moment (array, order, dim [, center [, mask]]) Arguments array : Shall be an array of type integer , real , or complex . order : Shall be an scalar of type integer . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . center (optional): Shall be a scalar of the same type of result if dim is not provided. If dim is provided, center shall be a scalar or an array (with a shape similar to that of array with dimension dim dropped) of the same type of result . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the k -th (central) moment of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the k -th  (central) moment of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_moment use stdlib_stats , only : moment implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , moment ( x , 2 ) !returns 2.9167 print * , moment ( y , 2 ) !returns 2.9167 print * , moment ( y , 2 , 1 ) !returns [0.25, 0.25, 0.25] print * , moment ( y , 2 , 1 , mask = ( y > 3. )) !returns [NaN, 0., 0.25] print * , moment ( x , 2 , center = 0. ) !returns 15.1667 print * , moment ( y , 1 , 1 , center = 0. ) !returns [1.5, 3.5, 5.5] end program demo_moment var - variance of array elements Status Experimental Description Returns the variance of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Per default, the variance is defined as the best unbiased estimator and is computed as: var(array) = 1/(n-1) sum_i (array(i) - mean(array))&#94;2 where n is the number of elements. The use of the term n-1 for scaling is called Bessel 's correction. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = var (array [, mask [, corrected]]) result = var (array, dim [, mask [, corrected]]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the variance of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the variance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . If the variance is computed with only one single element, then the result is IEEE NaN if corrected is .true. and is 0. if corrected is .false. . Example program demo_var use stdlib_stats , only : var implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , var ( x ) !returns 3.5 print * , var ( x , corrected = . false .) !returns 2.9167 print * , var ( y ) !returns 3.5 print * , var ( y , 1 ) !returns [0.5, 0.5, 0.5] print * , var ( y , 1 , y > 3. ) !returns [NaN, NaN, 0.5] print * , var ( y , 1 , y > 3. , corrected = . false .) !returns [NaN, 0., 0.25] end program demo_var","tags":"","loc":"page/specs/stdlib_stats.html"},{"title":"stats_distribution – Fortran-lang/stdlib","text":"Statistical Distributions -- Pseudorandom Number Generator Module Statistical Distributions -- Pseudorandom Number Generator Module random_seed - set or get a value of seed to the probability distribution pseudorandom number generator Status Description Syntax Arguments Return value Example dist_rand - Get a random integer with specified kind Status Description Syntax Arguments Return value Example random_seed - set or get a value of seed to the probability distribution pseudorandom number generator Status Experimental Description Set or get the seed value before calling the probability distribution pseudorandom number generator for variates. Syntax call random_seed (put, get) Arguments put : argument has intent(in) and may be a scalar of type integer . get : argument has intent(out) and is a scalar of type integer . Return value Return a scalar of type integer . Example program demo_random_seed use stdlib_stats_distribution_PRNG , only : random_seed implicit none integer :: seed_put , seed_get seed_put = 1234567 call random_seed ( seed_put , seed_get ) ! set and get current value of seed end program demo_random_seed dist_rand - Get a random integer with specified kind Status Experimental Description Generate an integer pseudorandom number in a specific range [-2&#94;k, 2&#94;k - 1] according to the input integer kind n. This pseudorandom number will be operated by bit opeartors instead of normal arithmetic operators. Syntax result = dist_rand (n) Arguments n : argument has intent(in) is a scalar of type integer . Return value Return a scalar of type integer . Example program demo_dist_rand use stdlib_stats_distribution_PRNG , only : dist_rand , random_seed implicit none integer :: put , get put = 135792468 call random_seed ( put , get ) ! set and get current value of seed print * , dist_rand ( 1_int8 ) ! random integer in [-2&#94;7, 2&#94;7 - 1] ! -90 print * , dist_rand ( 1_int16 ) ! random integer in [-2&#94;15, 2&#94;15 - 1] ! -32725 print * , dist_rand ( 1_int32 ) ! random integer in [-2&#94;31, 2&#94;31 - 1] ! -1601563881 print * , dist_rand ( 1_int64 ) ! random integer in [-2&#94;63, 2&#94;63 - 1] ! 180977695517992208 end program demo_dist_rand","tags":"","loc":"page/specs/stdlib_stats_distribution_PRNG.html"},{"title":"string type – Fortran-lang/stdlib","text":"The stdlib_string_type module The stdlib_string_type module Introduction Derived types provided The string_type derived type Status Procedures and methods provided Constructor for empty string Description Syntax Status Class Argument Result value Example Constructor from character scalar Description Syntax Status Class Argument Result value Example Constructor from integer scalar Description Syntax Status Class Argument Result value Example Constructor from logical scalar Description Syntax Status Class Argument Result value Example Assignment of character scalar Description Syntax Status Class Example Len function Description Syntax Status Class Argument Result value Example Len_trim function Description Syntax Status Class Argument Result value Example Trim function Description Syntax Status Class Argument Result value Example Adjustl function Description Syntax Status Class Argument Result value Example Adjustr function Description Syntax Status Class Argument Result value Example Repeat function Description Syntax Status Class Argument Result value Example Char function Description Syntax Status Class Argument Result value Example Char function (position variant) Description Syntax Status Class Argument Result value Example Char function (range variant) Description Syntax Status Class Argument Result value Example Ichar function Description Syntax Status Class Argument Result value Example Iachar function Description Syntax Status Class Argument Result value Example Index function Description Syntax Status Class Argument Result value Example Scan function Description Syntax Status Class Argument Result value Example Verify function Description Syntax Status Class Argument Result value Example Lgt function (lexical greater than) Description Syntax Status Class Argument Result value Example Llt function (lexical less than) Description Syntax Status Class Argument Result value Example Lge function (lexical greater than or equal) Description Syntax Status Class Argument Result value Example Lle function (lexical less than or equal) Description Syntax Status Class Argument Result value Example To_lower function Description Syntax Status Class Argument Result Value Example To_upper function Description Syntax Status Class Argument Result Value Example To_title function Description Syntax Status Class Argument Result Value Example To_sentence function Description Syntax Status Class Argument Result Value Example Reverse function Description Syntax Status Class Argument Result Value Example Comparison operator greater Description Syntax Status Class Argument Result value Example Comparison operator less Description Syntax Status Class Argument Result value Example Comparison operator greater or equal Description Syntax Status Class Argument Result value Example Comparison operator less or equal Description Syntax Status Class Argument Result value Example Comparison operator equal Description Syntax Status Class Argument Result value Example Comparison operator not equal Description Syntax Status Class Argument Result value Example Concatenation operator Description Syntax Status Class Argument Result value Example Unformatted write Description Syntax Status Class Argument Example Formatted write Description Syntax Status Class Argument Example Unformatted read Description Syntax Status Class Argument Example Formatted read Description Syntax Status Class Argument Example Introduction The stdlib_string_type provides a derived type holding an arbitrary sequence\nof characters compatible with most Fortran intrinsic character procedures as\nwell as operators for working with character variables and constants. Derived types provided The string_type derived type The string_type is defined as a non-extendible derived type representing a\nsequence of characters. The internal representation of the character sequence\nis implementation dependent and not visible for the user of the module. Status Experimental Procedures and methods provided Procedures returning string_type instances can usually be used in elemental\ncontext, while procedures returning scalar character values can only be\nused in a pure way. Constructor for empty string Description The module defines a constructor to create an empty string type. Creates a string instance representing an empty string. Syntax res = string_type () Status Experimental Class Elemental function. Argument None. Result value The result is an instance of string_type with zero length. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = string_type () ! len(string) == 0 end program demo Constructor from character scalar Description The module defines a constructor to create a string type from a character scalar. Creates a string instance representing the input character scalar value.\nThe constructor shall create an empty string if an unallocated deferred-length\ncharacter variable is passed. Syntax res = string_type (string) Status Experimental Class Elemental function. Argument string : shall be a scalar character value. It is an intent(in) argument. Result value The result is an instance of string_type . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = string_type ( \"Sequence\" ) ! len(string) == 8 string = string_type ( \" S p a c e d \" ) ! len(string) == 13 end program demo Constructor from integer scalar Description The module defines a constructor to create a string type from an integer scalar. Syntax res = string_type (string) Status Experimental Class Elemental function. Argument val : shall be a scalar integer value. It is an intent(in) argument. Result value The result is an instance of string_type . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = string_type ( 42 ) ! len(string) == 2 string = string_type ( - 289 ) ! len(string) == 4 end program demo Constructor from logical scalar Description The module defines a constructor to create a string type from a logical scalar. Syntax res = string_type (string) Status Experimental Class Elemental function. Argument val : shall be a scalar logical value. It is an intent(in) argument. Result value The result is an instance of string_type . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = string_type (. true .) ! len(string) == 1 string = string_type (. false .) ! len(string) == 1 end program demo Assignment of character scalar Description The module defines an assignment operations, = , to create a string type\nfrom a character scalar. Creates a string instance representing the right-hand-side character scalar value. Syntax lhs = rhs Status Experimental Class Elemental subroutine, assignment(=) . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string ! len(string) == 0 string = \"Sequence\" ! len(string) == 8 end program demo Len function Description Returns the length of the string. Syntax res = len (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: length string = \"Some longer sentence for this example.\" length = len ( string ) ! length == 38 string = \"Whitespace                            \" length = len ( string ) ! length == 38 end program demo Len_trim function Description Returns the length of the character sequence without trailing spaces\nrepresented by the string. Syntax res = len_trim (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: length string = \"Some longer sentence for this example.\" length = len_trim ( string ) ! length == 38 string = \"Whitespace                            \" length = len_trim ( string ) ! length == 10 end program demo Trim function Description Returns the character sequence hold by the string without trailing spaces\nrepresented by a string_type . Syntax res = trim (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = \"Whitespace                            \" string = trim ( string ) ! len(string) == 10 end program demo Adjustl function Description Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = adjustl (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = \"                            Whitespace\" string = adjustl ( string ) ! char(string) == \"Whitespace                            \" end program demo Adjustr function Description Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = adjustr (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = \"Whitespace                            \" string = adjustr ( string ) ! char(string) == \"                            Whitespace\" end program demo Repeat function Description Repeats the character sequence hold by the string by the number of\nspecified copies. Syntax res = repeat (string, ncopies) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . ncopies : Integer of default type. This argument is intent(in) . Result value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = \"What? \" string = repeat ( string , 3 ) ! string == \"What? What? What? \" end program demo Char function Description Return the character sequence represented by the string. Syntax res = char (string) Status Experimental Class Pure function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"Character sequence\" dlc = char ( string ) ! dlc == \"Character sequence\" end program demo Char function (position variant) Description Return the character at a certain position in the string. Syntax res = char (string, pos) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . pos : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc character ( len = 1 ), allocatable :: chars (:) string = \"Character sequence\" dlc = char ( string , 3 ) ! dlc == \"a\" chars = char ( string , [ 3 , 5 , 8 , 12 , 14 , 15 , 18 ]) ! chars == [\"a\", \"a\", \"e\", \"e\", \"u\", \"e\", \"e\"] end program demo Char function (range variant) Description Return a substring from the character sequence of the string. Syntax res = char (string, start, last) Status Experimental Class Pure function. Argument string : Instance of a string_type . This argument is intent(in) . start : Integer of default type. This argument is intent(in) . last : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"Fortran\" dlc = char ( string , 1 , 4 ) ! dlc == \"Fort\" end program demo Ichar function Description Character-to-integer conversion function. Returns the code for the character in the first character position of the\ncharacter sequence in the system's native character set. Syntax res = ichar (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: code string = \"Fortran\" code = ichar ( string ) end program demo Iachar function Description Code in ASCII collating sequence. Returns the code for the ASCII character in the first character position of\nthe character sequences represent by the string. Syntax res = iachar (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: code string = \"Fortran\" code = iachar ( string ) end program demo Index function Description Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\nof string substring in string , counting from one. If substring is not\npresent in string , zero is returned. Syntax res = index (string, substring[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . substring : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"Search this string for this expression\" pos = index ( string , \"this\" ) ! pos == 8 pos = index ( string , \"this\" , back = . true .) ! pos == 24 pos = index ( string , \"This\" ) ! pos == 0 end program demo Scan function Description Scans a string for the  presence any of the characters in a set of characters.\nIf back is either absent or false , this function returns the position\nof the leftmost character of string that is in set . If back is true ,\nthe rightmost position is returned. If no character of set is found in string , the result is zero. Syntax res = scan (string, set[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"fortran\" pos = scan ( string , \"ao\" ) ! pos == 2 pos = scan ( string , \"ao\" , . true .) ! pos == 6 pos = scan ( string , \"c++\" ) ! pos == 0 end program demo Verify function Description Verifies that all the characters in string belong to the set of characters in set .\nIf back is either absent or false , this function returns the position\nof the leftmost character of string that is not in set . If back is true ,\nthe rightmost position is returned. If all characters of string are found\nin set , the result is zero. Syntax res = verify (string, set[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"fortran\" pos = verify ( string , \"ao\" ) ! pos == 1 pos = verify ( string , \"fo\" ) ! pos == 3 pos = verify ( string , \"c++\" ) ! pos == 1 pos = verify ( string , \"c++\" , back = . true .) ! pos == 7 pos = verify ( string , string ) ! pos == 0 end program demo Lgt function (lexical greater than) Description Lexically compare the order of two character sequences being greater than. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lgt procedure. Syntax res = lgt (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lgt ( string , \"abc\" ) ! res .eqv. .true. res = lgt ( string , \"bcd\" ) ! res .eqv. .false. res = lgt ( string , \"cde\" ) ! res .eqv. .false. end program demo Llt function (lexical less than) Description Lexically compare the order of two character sequences being less than. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic llt procedure. Syntax res = llt (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = llt ( string , \"abc\" ) ! res .eqv. .false. res = llt ( string , \"bcd\" ) ! res .eqv. .false. res = llt ( string , \"cde\" ) ! res .eqv. .true. end program demo Lge function (lexical greater than or equal) Description Lexically compare the order of two character sequences being greater than\nor equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lge procedure. Syntax res = lge (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lge ( string , \"abc\" ) ! res .eqv. .true. res = lge ( string , \"bcd\" ) ! res .eqv. .true. res = lge ( string , \"cde\" ) ! res .eqv. .false. end program demo Lle function (lexical less than or equal) Description Lexically compare the order of two character sequences being less than\nor equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lle procedure. Syntax res = lle (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lle ( string , \"abc\" ) ! res .eqv. .false. res = lle ( string , \"bcd\" ) ! res .eqv. .true. res = lle ( string , \"cde\" ) ! res .eqv. .true. end program demo To_lower function Description Returns a new string_type instance which holds the lowercase version of the \ncharacter sequence hold by the input string. Syntax lowercase_string = [[stdlib_string_type(module): to_lower(interface)]] (string) Status Experimental Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string , lowercase_string string = \"Lowercase This String\" ! string <-- \"Lowercase This String\" lowercase_string = to_lower ( string ) ! string <-- \"Lowercase This String\" ! lowercase_string <-- \"lowercase this string\" end program demo To_upper function Description Returns a new string_type instance which holds the uppercase version of the \ncharacter sequence hold by the input string. Syntax uppercase_string = [[stdlib_string_type(module): to_upper(interface)]] (string) Status Experimental Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string , uppercase_string string = \"Uppercase This String\" ! string <-- \"Uppercase This String\" uppercase_string = to_upper ( string ) ! string <-- \"Uppercase This String\" ! uppercase_string <-- \"UPPERCASE THIS STRING\" end program demo To_title function Description Returns a new string_type instance which holds the titlecase version \nof the character sequence hold by the input string. Title case: First character of every word in the sentence is converted to \nuppercase and the rest of the characters are converted to lowercase. A word is a contiguous sequence of character(s) which consists of alphabetical \ncharacter(s) and numeral(s) only and doesn't exclude any alphabetical character \nor numeral present next to either of its 2 ends. Syntax titlecase_string = [[stdlib_string_type(module): to_title(interface)]] (string) Status Experimental Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example program demo_to_title use stdlib_string_type implicit none type ( string_type ) :: string , titlecase_string string = \"titlecase this string.\" ! string <-- \"titlecase this string.\" titlecase_string = to_title ( string ) ! string <-- \"titlecase this string.\" ! titlecase_string <-- \"Titlecase This String.\" end program demo_to_title To_sentence function Description Returns a new string_type instance which holds the sentencecase \nversion of the character sequence hold by the input string. Sentencecase version: The first alphabetical character of the input character sequence \nis transformed to uppercase unless it follows a numeral and the rest of the \ncharacters in the sequence are transformed to lowercase. Syntax sentencecase_string = [[stdlib_string_type(module): to_sentence(interface)]] (string) Status Experimental Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example program demo_to_sentence use stdlib_string_type implicit none type ( string_type ) :: string , sentencecase_string string = \"sentencecase this string.\" ! string <-- \"sentencecase this string.\" sentencecase_string = to_sentence ( string ) ! string <-- \"sentencecase this string.\" ! sentencecase_string <-- \"Sentencecase this string.\" end program demo_to_sentence Reverse function Description Returns a new string_type instance which holds the reversed version of the \ncharacter sequence hold by the input string. Syntax reverse_string = [[stdlib_string_type(module): reverse(interface)]] (string) Status Experimental Class Elemental function. Argument string : Instance of string_type . This argument is intent(in) . Result Value The result is a scalar string_type value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string , reverse_string string = \"Reverse This String\" ! string <-- \"Reverse This String\" reverse_string = reverse ( string ) ! string <-- \"Reverse This String\" ! reverse_string <-- \"gnirtS sihT esreveR\" end program demo Comparison operator greater Description Compare the order of two character sequences being greater. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(>) and operator(.gt.) . Syntax res = lhs > rhs res = lhs .gt. rhs Status Experimental Class Elemental function, operator(>) and operator(.gt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string > \"abc\" ! res .eqv. .true. res = string > \"bcd\" ! res .eqv. .false. res = string > \"cde\" ! res .eqv. .false. end program demo Comparison operator less Description Compare the order of two character sequences being less. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(<) and operator(.lt.) . Syntax res = lhs < rhs res = lhs .lt. rhs Status Experimental Class Elemental function, operator(<) and operator(.lt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string < \"abc\" ! res .eqv. .false. res = string < \"bcd\" ! res .eqv. .false. res = string < \"cde\" ! res .eqv. .true. end program demo Comparison operator greater or equal Description Compare the order of two character sequences being greater or equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(>=) and operator(.ge.) . Syntax res = lhs >= rhs res = lhs .ge. rhs Status Experimental Class Elemental function, operator(>=) and operator(.ge.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string >= \"abc\" ! res .eqv. .true. res = string >= \"bcd\" ! res .eqv. .true. res = string >= \"cde\" ! res .eqv. .false. end program demo Comparison operator less or equal Description Compare the order of two character sequences being less or equal. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(<=) and operator(.le.) . Syntax res = lhs <= rhs res = lhs .le. rhs Status Experimental Class Elemental function, operator(<=) and operator(.le.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string <= \"abc\" ! res .eqv. .false. res = string <= \"bcd\" ! res .eqv. .true. res = string <= \"cde\" ! res .eqv. .true. end program demo Comparison operator equal Description Compare two character sequences for equality. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(==) and operator(.eq.) . Syntax res = lhs == rhs res = lhs .eq. rhs Status Experimental Class Elemental function, operator(==) and operator(.eq.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string == \"abc\" ! res .eqv. .false. res = string == \"bcd\" ! res .eqv. .true. res = string == \"cde\" ! res .eqv. .false. end program demo Comparison operator not equal Description Compare two character sequences for inequality. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(/=) and operator(.ne.) . Syntax res = lhs /= rhs res = lhs .ne. rhs Status Experimental Class Elemental function, operator(/=) and operator(.ne.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example program demo use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string /= \"abc\" ! res .eqv. .true. res = string /= \"bcd\" ! res .eqv. .false. res = string /= \"cde\" ! res .eqv. .true. end program demo Concatenation operator Description Concatenate two character sequences. The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(//) . Syntax res = lhs // rhs Status Experimental Class Elemental function, operator(//) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is an instance of string_type . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string string = \"Hello, \" string = string // \"World!\" ! len(string) == 13 end program demo Unformatted write Description Write the character sequence hold by the string to a connected unformatted unit.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. Syntax write(unit, iostat=iostat, iomsg=iomsg) string Status Experimental Class Unformatted user defined derived type output. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"unformatted\" , status = \"scratch\" ) write ( io ) string rewind ( io ) read ( io ) string close ( io ) end program demo Formatted write Description Write the character sequence hold by the string to a connected formatted unit. The current implementation is limited to list directed output and dt formatted\noutput. Requesting namelist output will raise an error. Syntax write(unit, fmt, iostat=iostat, iomsg=iomsg) string Status Experimental Class Formatted user defined derived type output. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist output or starts with \"DT\" for derived type output.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type output.\n  This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"formatted\" , status = \"scratch\" ) write ( io , * ) string write ( io , * ) rewind ( io ) read ( io , * ) string close ( io ) end program demo Unformatted read Description Read a character sequence from a connected unformatted unit into the string.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. On failure the state the read variable is undefined and implementation dependent. Syntax read(unit, iostat=iostat, iomsg=iomsg) string Status Experimental Class Unformatted derived type input. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"unformatted\" , status = \"scratch\" ) write ( io ) string rewind ( io ) read ( io ) string close ( io ) end program demo Formatted read Description Read a character sequence from a connected formatted unit into the string.\nList-directed input will retrieve the complete record into the string. On failure the state the read variable is undefined and implementation dependent. The current implementation is limited to list directed input.\nRequesting dt formatted input or namelist output will raise an error. Syntax read(unit, fmt, iostat=iostat, iomsg=iomsg) string Status Experimental Class Formatted derived type input. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist input or starts with \"DT\" for derived type input.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type input.\n  This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example program demo use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"formatted\" , status = \"scratch\" ) write ( io , * ) string write ( io , * ) rewind ( io ) read ( io , * ) string close ( io ) end program demo","tags":"","loc":"page/specs/stdlib_string_type.html"},{"title":"string handling – Fortran-lang/stdlib","text":"The stdlib_strings module The stdlib_strings module Introduction Procedures and methods provided strip Description Syntax Status Class Argument Result value Example chomp Description Syntax Status Class Argument Result value Example starts_with Description Syntax Status Class Argument Result value Example ends_with Description Syntax Status Class Argument Result value Example slice Description Syntax Status Class Argument Result value Example find Description Syntax Status Class Argument Result value Example replace_all Description Syntax Status Class Argument Result value Example padl Description Syntax Status Class Argument Result value Example padr Description Syntax Status Class Argument Result value Example count Description Syntax Status Class Argument Result value Example Introduction The stdlib_strings module provides basic string handling and manipulation routines. Procedures and methods provided strip Description Remove leading and trailing whitespace characters. Syntax string = strip (string) Status Experimental Class Pure function. Argument string : Character scalar or string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example program demo use stdlib_ascii , only : TAB , VT , NUL , LF , CR , FF use stdlib_strings , only : strip implicit none print '(a)' , strip ( \"   hello   \" ) ! \"hello\" print '(a)' , strip ( TAB // \"goodbye\" // CR // LF ) ! \"goodbye\" print '(a)' , strip ( \" \" // TAB // LF // VT // FF // CR ) ! \"\" print '(a)' , strip ( \"  !  \" ) // \"!\" ! \"!!\" print '(a)' , strip ( \"Hello\" ) ! \"Hello\" end program demo chomp Description Remove trailing characters in set or substring from string .\nIf no character set or substring is provided trailing whitespace is removed. Syntax string = chomp (string[, set|substring]) Status Experimental Class Pure function. Argument string : Character scalar or string_type .\n  This argument is intent(in). set : Array of length one character. This argument is intent(in). substring : Character scalar or string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example program demo use stdlib_ascii , only : TAB , VT , NUL , LF , CR , FF use stdlib_strings , only : chomp implicit none print '(a)' , chomp ( \"   hello   \" ) ! \"   hello\" print '(a)' , chomp ( TAB // \"goodbye\" // CR // LF ) ! \"\\tgoodbye\" print '(a)' , chomp ( \" \" // TAB // LF // VT // FF // CR ) ! \"\" print '(a)' , chomp ( \"  !  \" ) // \"!\" ! \"  !!\" print '(a)' , chomp ( \"Hello\" ) ! \"Hello\" print '(a)' , chomp ( \"hello\" , [ \"l\" , \"o\" ]) ! \"he\" print '(a)' , chomp ( \"hello\" , set = [ \"l\" , \"o\" ]) ! \"he\" print '(a)' , chomp ( \"hello\" , \"lo\" ) ! \"hel\" print '(a)' , chomp ( \"hello\" , substring = \"lo\" ) ! \"hel\" end program demo starts_with Description Check if a string starts with a given substring . Syntax string = starts_with (string, substring) Status Experimental Class Pure function. Argument string : Character scalar or string_type .\n  This argument is intent(in). substring : Character scalar or string_type .\n  This argument is intent(in). Result value The result is of scalar logical type. Example program demo use stdlib_strings , only : starts_with implicit none print '(a)' , starts_with ( \"pattern\" , \"pat\" ) ! T print '(a)' , starts_with ( \"pattern\" , \"ern\" ) ! F end program demo ends_with Description Check if a string ends with a given substring . Syntax string = ends_with (string, substring) Status Experimental Class Pure function. Argument string : Character scalar or string_type .\n  This argument is intent(in). substring : Character scalar or string_type .\n  This argument is intent(in). Result value The result is of scalar logical type. Example program demo use stdlib_strings , only : ends_with implicit none print '(a)' , ends_with ( \"pattern\" , \"ern\" ) ! T print '(a)' , ends_with ( \"pattern\" , \"pat\" ) ! F end program demo slice Description Extracts the characters from the defined region of the input string by taking strides. Argument first and last defines this region for extraction by function slice . Argument stride defines the magnitude and direction (+/-) of stride to be taken while extraction. stride when given invalid value 0, is converted to +1. Deduction Process: Function first automatically deduces the optional arguments that are not provided by the user. Deduced first and last argument take +infinity or -infinity value and deduced stride argument \ntakes value +1 or -1 depending upon the actual argument(s) provided by the user. Extraction Process: Extraction starts only if last is crossable from first with stride of stride . Extraction starts from the first valid index in the defined region to take stride of stride and ends when the last valid index in the defined region is crossed. If no valid index exists in the defined region, empty string is returned. Syntax string = slice (string [, first, last, stride]) Status Experimental Class Pure function. Argument string : Character scalar or string_type .\n  This argument is intent(in). first : integer.\n  This argument is intent(in) and optional. last : integer.\n  This argument is intent(in) and optional. stride : integer.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example program demo_slice use stdlib_string_type use stdlib_strings , only : slice implicit none type ( string_type ) :: string character ( len = 10 ) :: char string = \"abcdefghij\" ! string <-- \"abcdefghij\" char = \"abcdefghij\" ! char <-- \"abcdefghij\" print '(a)' , slice ( \"abcdefghij\" , 2 , 6 , 2 ) ! \"bdf\" print '(a)' , slice ( char , 2 , 6 , 2 ) ! \"bdf\" string = slice ( string , 2 , 6 , 2 ) ! string <-- \"bdf\" end program demo_slice find Description Returns the starting index of the occurrence th occurrence of the substring pattern in the input string string . Default value of occurrence is set to 1 . \nIf consider_overlapping is not provided or is set to .true. the function counts two overlapping occurrences of substring pattern as two different occurrences. If occurrence th occurrence is not found, function returns 0 . Syntax string = find (string, pattern [, occurrence, consider_overlapping]) Status Experimental Class Elemental function Argument string : Character scalar or string_type .\n  This argument is intent(in). pattern : Character scalar or string_type .\n  This argument is intent(in). occurrence : integer.\n  This argument is intent(in) and optional. consider_overlapping : logical.\n  This argument is intent(in) and optional. Result value The result is a scalar of integer type or an integer array of rank equal to the highest rank among all dummy arguments. Example program demo_find use stdlib_string_type , only : string_type , assignment ( = ) use stdlib_strings , only : find implicit none type ( string_type ) :: string string = \"needle in the character-stack\" print * , find ( string , \"needle\" ) ! 1 print * , find ( string , [ \"a\" , \"c\" ], [ 3 , 2 ]) ! [27, 20] print * , find ( \"qwqwqwq\" , \"qwq\" , 3 , [. false ., . true .]) ! [0, 5] end program demo_find replace_all Description Replaces all occurrences of substring pattern in the input string with the replacement replacement . Occurrences overlapping on a base occurrence will not be replaced. Syntax string = replace_all (string, pattern, replacement) Status Experimental Class Pure function Argument string : Character scalar or string_type .\n  This argument is intent(in). pattern : Character scalar or string_type .\n  This argument is intent(in). replacement : Character scalar or string_type .\n  This argument is intent(in). Result value The result is of the same type as string . Example program demo_replace_all use stdlib_string_type , only : string_type , assignment ( = ) use stdlib_strings , only : replace_all implicit none type ( string_type ) :: string string = \"hurdles here, hurdles there, hurdles everywhere\" ! string <-- \"hurdles here, hurdles there, hurdles everywhere\" print '(a)' , replace_all ( string , \"hurdles\" , \"learn from\" ) ! \"learn from here, learn from there, learn from everywhere\" string = replace_all ( string , \"hurdles\" , \"technology\" ) ! string <-- \"technology here, technology there, technology everywhere\" end program demo_replace_all padl Description Returns a string of length output_length left padded with pad_with character if it is provided, otherwise with \" \" (1 whitespace). If output_length is less than or equal to the length of string , padding is not performed. Syntax string = padl (string, output_length [, pad_with]) Status Experimental Class Pure function Argument string : Character scalar or string_type .\n  This argument is intent(in). output_length : integer.\n  This argument is intent(in). pad_with : Character scalar of length 1.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example program demo_padl use stdlib_string_type , only : string_type , assignment ( = ) use stdlib_strings , only : padl implicit none string_type :: string string = \"left pad this string\" ! string <-- \"left pad this string\" print * , padl ( string , 25 , \"$\" ) ! \"$left pad this string\" string = padl ( string , 25 ) ! string <-- \"     left pad this string\" end program demo_padl padr Description Returns a string of length output_length right padded with pad_with character if it is provided, otherwise with \" \" (1 whitespace). If output_length is less than or equal to the length of string , padding is not performed. Syntax string = padr (string, output_length [, pad_with]) Status Experimental Class Pure function Argument string : Character scalar or string_type .\n  This argument is intent(in). output_length : integer.\n  This argument is intent(in). pad_with : Character scalar of length 1.\n  This argument is intent(in) and optional. Result value The result is of the same type as string . Example program demo_padr use stdlib_string_type , only : string_type , assignment ( = ) use stdlib_strings , only : padr implicit none string_type :: string string = \"right pad this string\" ! string <-- \"right pad this string\" print * , padr ( string , 25 , \"$\" ) ! \"right pad this string\" string = padr ( string , 25 ) ! string <-- \"right pad this string    \" end program demo_padr count Description Returns the number of times the substring pattern has occurred in the input string string . If consider_overlapping is not provided or is set to .true. the function counts two overlapping occurrences of substring pattern as two different occurrences. Syntax string = count (string, pattern [, consider_overlapping]) Status Experimental Class Elemental function Argument string : Character scalar or string_type .\n  This argument is intent(in). pattern : Character scalar or string_type .\n  This argument is intent(in). consider_overlapping : logical.\n  This argument is intent(in) and optional. Result value The result is a scalar of integer type or an integer array of rank equal to the highest rank among all dummy arguments. Example program demo_count use stdlib_string_type , only : string_type , assignment ( = ) use stdlib_strings , only : count implicit none type ( string_type ) :: string string = \"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\" print * , count ( string , \"wood\" ) ! 4 print * , count ( string , [ \"would\" , \"chuck\" , \"could\" ]) ! [1, 4, 1] print * , count ( \"a long queueueueue\" , \"ueu\" , [. false ., . true .]) ! [2, 4] end program demo_count","tags":"","loc":"page/specs/stdlib_strings.html"}]}