<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="A community driven standard library for (modern) Fortran">
    <meta name="author" content="fortran-lang/stdlib contributors" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; Fortran-lang/stdlib
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Fortran-lang/stdlib </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../page/index.html">Contributing and specs</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr>
                 <td><a href='../interface/adjustl.html'>adjustl</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Left-adjust the character sequence represented by the string.
The length of the character sequence remains unchanged.</p><a href="../interface/adjustl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/adjustr.html'>adjustr</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Right-adjust the character sequence represented by the string.
The length of the character sequence remains unchanged.</p><a href="../interface/adjustr.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/all_close.html'>all_close</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Returns a boolean scalar where two arrays are element-wise equal within a tolerance.
(<a href="../page/specs/stdlib_math.html#all_close-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/and.html'>and</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Sets the bits in <code>set1</code> to the bitwise <code>and</code> of the original bits in <code>set1</code>
 and <code>set2</code>. The sets must have the same number of bits
 otherwise the result is undefined.
 (<a href="../page/specs/stdlib_bitsets.html#and-bitwise-and-of-the-bits-of-two-bitsets">Specification</a>)</p><a href="../interface/and.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/and_not.html'>and_not</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Sets the bits in <code>set1</code> to the bitwise and of the original bits in <code>set1</code>
 with the bitwise negation of <code>set2</code>. The sets must have the same
 number of bits otherwise the result is undefined.</p><a href="../interface/and_not.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/arange.html'>arange</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p><code>arange</code> creates a one-dimensional <code>array</code> of the <code>integer/real</code> type 
 with fixed-spaced values of given spacing, within a given interval.
(<a href="../page/specs/stdlib_math.html#arange-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/arg.html'>arg</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p><code>arg</code> computes the phase angle in the interval (-π,π].
(<a href="../page/specs/stdlib_math.html#arg-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/arg_select.html'>arg_select</a></td>
                 <td><a href='../module/stdlib_selection.html'>stdlib_selection</a></td>
                 <td>Interface</td>
                 <td><p>(<a href="..//page/specs/stdlib_selection.html#arg_select-find-the-index-of-the-k-th-smallest-value-in-an-input-array">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/argd.html'>argd</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p><code>argd</code> computes the phase angle of degree version in the interval (-180.0,180.0].
(<a href="../page/specs/stdlib_math.html#argd-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/argpi.html'>argpi</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p><code>argpi</code> computes the phase angle of circular version in the interval (-1.0,1.0].
(<a href="../page/specs/stdlib_math.html#argpi-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=).html'>assignment(=)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Assign a character sequence to a string.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~2.html'>assignment(=)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Used to define assignment for <code>bitset_large</code>.
 (<a href="../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value">Specification</a>)</p><a href="../interface/assignment(=)~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/axpy.html'>axpy</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>AXPY constant times a vector plus a vector.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/bidx.html'>bidx</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns an instance of type 'stringlist_index_type' representing backward index
<a href="../page/specs/stdlib_stringlist_type.html#bidx">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bits.html'>bits</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Function</td>
                 <td><p>Returns the number of bit positions in <code>self</code>.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/cdf_exp.html'>cdf_exp</a></td>
                 <td><a href='../module/stdlib_stats_distribution_exponential.html'>stdlib_stats_distribution_exponential</a></td>
                 <td>Interface</td>
                 <td><p>Version experimental</p><a href="../interface/cdf_exp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/cdf_normal.html'>cdf_normal</a></td>
                 <td><a href='../module/stdlib_stats_distribution_normal.html'>stdlib_stats_distribution_normal</a></td>
                 <td>Interface</td>
                 <td><p>Normal Distribution Cumulative Distribution Function
(<a href="../page/specs/stdlib_stats_distribution_normal.html#
cdf_normal-normal-distribution-cumulative-distribution-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/cdf_uniform.html'>cdf_uniform</a></td>
                 <td><a href='../module/stdlib_stats_distribution_uniform.html'>stdlib_stats_distribution_uniform</a></td>
                 <td>Interface</td>
                 <td><p>Get uniform distribution cumulative distribution function (cdf) for integer,
real and complex variables.
(<a href="../page/specs/stdlib_stats_distribution_uniform.html#
cdf_uniform-uniform-cumulative-distribution-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/char.html'>char</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Return the character sequence represented by the string.</p><a href="../interface/char.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check.html'>check</a></td>
                 <td><a href='../module/stdlib_error.html'>stdlib_error</a></td>
                 <td>Subroutine</td>
                 <td><p>Checks the value of a logical condition
 (<a href="../page/specs/stdlib_error.html#description">Specification</a>)</p><a href="../proc/check.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/chomp.html'>chomp</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Remove trailing characters in set from string.
If no character set is provided trailing whitespace is removed.</p><a href="../interface/chomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/clip.html'>clip</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/copy.html'>copy</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>COPY copies a vector x to a vector y.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_key.html'>copy_key</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Subroutine</td>
                 <td><p>Copies the contents of the key, old_key, to the key, new_key
(<a href="../page/specs/stdlib_hashmaps.html#copy_key-returns-a-copy-of-the-key">Specifications</a>)</p><a href="../proc/copy_key.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_other.html'>copy_other</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Subroutine</td>
                 <td><p>Copies the other data, other_in, to the variable, other_out
(<a href="../page/specs/stdlib_hashmaps.html#copy_other-returns-a-copy-of-the-other-data">Specifications</a>)</p><a href="../proc/copy_other.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/corr.html'>corr</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Pearson correlation of array elements
(<a href="../page/specs/stdlib_stats.html#corr-pearson-correlation-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/count.html'>count</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Returns the number of times substring 'pattern' has appeared in the
input string 'string'
<a href="../page/specs/stdlib_strings.html#count">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/cov.html'>cov</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Covariance of array elements
(<a href="../page/specs/stdlib_stats.html#cov-covariance-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/cross_product.html'>cross_product</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Computes the cross product of two vectors, returning a rank-1 and size-3 array
(<a href="../page/specs/stdlib_linalg.html#cross_product-computes-the-cross-product-of-two-3-d-vectors">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/diag.html'>diag</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Creates a diagonal array or extract the diagonal elements of an array
(<a href="../page/specs/stdlib_linalg.html#
diag-create-a-diagonal-array-or-extract-the-diagonal-elements-of-an-array">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/diff.html'>diff</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Computes differences between adjacent elements of an array.
(<a href="../page/specs/stdlib_math.html#diff-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dist_rand.html'>dist_rand</a></td>
                 <td><a href='../module/stdlib_random.html'>stdlib_random</a></td>
                 <td>Interface</td>
                 <td><p>Version experimental</p><a href="../interface/dist_rand.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dlegendre.html'>dlegendre</a></td>
                 <td><a href='../module/stdlib_specialfunctions.html'>stdlib_specialfunctions</a></td>
                 <td>Interface</td>
                 <td><p>First derivative Legendre polynomial</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dot.html'>dot</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>DOT forms the dot product of two vectors.
uses unrolled loops for increments equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dotc.html'>dotc</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>DOTC forms the dot product of two complex vectors
DOTC = X^H * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dotu.html'>dotu</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>DOTU forms the dot product of two complex vectors
DOTU = X^T * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ends_with.html'>ends_with</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Check whether a string ends with substring or not</p><a href="../interface/ends_with.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/error_handler.html'>error_handler</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/error_stop.html'>error_stop</a></td>
                 <td><a href='../module/stdlib_error.html'>stdlib_error</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/extract.html'>extract</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Creates a new bitset, <code>new</code>, from a range, <code>start_pos</code> to <code>stop_pos</code>, in
 bitset <code>old</code>. If <code>start_pos</code> is greater than <code>stop_pos</code> the new bitset is
 empty. If <code>start_pos</code> is less than zero or <code>stop_pos</code> is greater than
 <code>bits(old)-1</code> then if <code>status</code> is present it has the value
 <code>index_invalid_error</code> and <code>new</code> is undefined, otherwise processing stops
 with an informative message.
 (<a href="../page/specs/stdlib_bitsets.html#extract-create-a-new-bitset-from-a-range-in-an-old-bitset">Specification</a>)</p><a href="../interface/extract.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eye.html'>eye</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Function</td>
                 <td><p>Constructs the identity matrix.
(<a href="../page/specs/stdlib_linalg.html#eye-construct-the-identity-matrix">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/falseloc.html'>falseloc</a></td>
                 <td><a href='../module/stdlib_array.html'>stdlib_array</a></td>
                 <td>Function</td>
                 <td><p>Return the positions of the false elements in array.
<a href="../page/specs/stdlib_array.html#falseloc">Specification</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fibonacci_hash.html'>fibonacci_hash</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Function</td>
                 <td><p>Maps the 32 bit integer <code>key</code> to an unsigned integer value with only <code>nbits</code>
bits where <code>nbits</code> is less than 32
(<a href="../page/specs/stdlib_hash_procedures.html#fibonacci_hash-maps-an-integer-to-a-smaller-number-of-bits">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fibonacci_hash~2.html'>fibonacci_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Function</td>
                 <td><p>Maps the 64 bit integer <code>key</code> to an unsigned integer value with only <code>nbits</code>
bits where <code>nbits</code> is less than 64
(<a href="../page/specs/stdlib_hash_procedures.html#fibonacci_hash-maps-an-integer-to-a-smaller-number-of-bits_1">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fidx.html'>fidx</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns an instance of type 'stringlist_index_type' representing forward index
<a href="../page/specs/stdlib_stringlist_type.html#fidx">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/find.html'>find</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Finds the starting index of substring 'pattern' in the input 'string'
<a href="link to the specs - to be completed">Specifications</a></p><a href="../interface/find.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fnv_1_hash.html'>fnv_1_hash</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>FNV_1 interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#fnv_1_hash-calculates-a-hash-code-from-a-key">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fnv_1_hash~2.html'>fnv_1_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td><p>FNV_1 interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#fnv_1-calculates-a-hash-code-from-a-key">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fnv_1_hasher.html'>fnv_1_hasher</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Function</td>
                 <td><p>Hashes a key with the FNV_1 algorithm
Arguments:
    key  - the key to be hashed</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fnv_1a_hash.html'>fnv_1a_hash</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>FNV_1A interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#fnv_1a_hash-calculates-a-hash-code-from-a-key">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fnv_1a_hash~2.html'>fnv_1a_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td><p>FNV_1A interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#fnv_1a-calculates-a-hash-code-from-a-key">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fnv_1a_hasher.html'>fnv_1a_hasher</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Function</td>
                 <td><p>Hashes a key with the FNV_1a algorithm
(<a href="../page/specs/stdlib_hashmaps.html#fnv_1a_hasher-calculates-a-hash-code-from-a-key">Specifications</a>)</p><a href="../proc/fnv_1a_hasher.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/free_key.html'>free_key</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Subroutine</td>
                 <td><p>Frees the memory in a key
(<a href="../page/specs/stdlib_hashmaps.html#free_key-frees-the-memory-associated-with-a-key">Specifications</a>)</p><a href="../proc/free_key.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/free_other.html'>free_other</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Subroutine</td>
                 <td><p>Frees the memory in the other data
(<a href="../page/specs/stdlib_hashmaps.html#free_other-frees-the-memory-associated-with-other-data">Specifications</a>)</p><a href="../proc/free_other.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gamma.html'>gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Gamma function for integer and complex numbers</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gauss_legendre.html'>gauss_legendre</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Computes Gauss-Legendre quadrature nodes and weights.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gauss_legendre_lobatto.html'>gauss_legendre_lobatto</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Computes Gauss-Legendre-Lobatto quadrature nodes and weights.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gbmv.html'>gbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GBMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gcd.html'>gcd</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Returns the greatest common divisor of two integers
(<a href="../page/specs/stdlib_math.html#gcd">Specification</a>)</p><a href="../interface/gcd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gemm.html'>gemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GEMM performs one of the matrix-matrix operations
C := alpha<em>op( A )</em>op( B ) + beta<em>C,
where  op( X ) is one of
op( X ) = X   or   op( X ) = X</em><em>T   or   op( X ) = X</em>*H,
alpha and beta are scalars, and A, B and C are matrices, with op( A )
an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gemv.html'>gemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GEMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ger.html'>ger</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GER performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/gerc.html'>gerc</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GERC performs the rank 1 operation
A := alpha<em>x</em>y**H + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/geru.html'>geru</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>GERU performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get.html'>get</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_stdlib_version.html'>get_stdlib_version</a></td>
                 <td><a href='../module/stdlib_version.html'>stdlib_version</a></td>
                 <td>Subroutine</td>
                 <td><p>Getter function to retrieve standard library version</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getline.html'>getline</a></td>
                 <td><a href='../module/stdlib_io.html'>stdlib_io</a></td>
                 <td>Interface</td>
                 <td><p>Read a whole line from a formatted unit into a string variable</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hbmv.html'>hbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hemm.html'>hemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HEMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where alpha and beta are scalars, A is an hermitian matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hemv.html'>hemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HEMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/her.html'>her</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HER performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/her2.html'>her2</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HER2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/her2k.html'>her2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HER2K performs one of the hermitian rank 2k operations
C := alpha<em>A</em>B<strong>H + conjg( alpha )<em>B</em>A</strong>H + beta<em>C,
or
C := alpha</em>A<strong>H<em>B + conjg( alpha )</em>B</strong>H<em>A + beta</em>C,
where  alpha and beta  are scalars with  beta  real,  C is an  n by n
hermitian matrix and  A and B  are  n by k matrices in the first case
and  k by n  matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/herk.html'>herk</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HERK performs one of the hermitian rank k operations
C := alpha<em>A</em>A<strong>H + beta<em>C,
or
C := alpha</em>A</strong>H<em>A + beta</em>C,
where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
matrix and  A  is an  n by k  matrix in the  first case and a  k by n
matrix in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hpmv.html'>hpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hpr.html'>hpr</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HPR performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/hpr2.html'>hpr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>HPR2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/iachar.html'>iachar</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Code in ASCII collating sequence.</p><a href="../interface/iachar.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ichar.html'>ichar</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Character-to-integer conversion function.</p><a href="../interface/ichar.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/index.html'>index</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Position of a <em>substring</em> within a <em>string</em>.</p><a href="../interface/index.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_alpha.html'>is_alpha</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is an ASCII letter (A .. Z, a .. z).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_alphanum.html'>is_alphanum</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a letter or a number (0 .. 9, a .. z, A .. Z).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_ascii.html'>is_ascii</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is in the ASCII character set -
i.e. in the range 0 .. 0x7F.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_blank.html'>is_blank</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is a blank character. That includes the
only the space and tab characters</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_close.html'>is_close</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Returns a boolean scalar/array where two scalar/arrays are element-wise equal within a tolerance.
(<a href="../page/specs/stdlib_math.html#is_close-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_control.html'>is_control</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a control character.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_diagonal.html'>is_diagonal</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is diagonal
(<a href="../page/specs/stdlib_linalg.html#
is_diagonal-checks-if-a-matrix-is-diagonal">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_digit.html'>is_digit</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a digit (0 .. 9).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_graphical.html'>is_graphical</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is a printable character other than the
space character.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_hermitian.html'>is_hermitian</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is Hermitian
(<a href="../page/specs/stdlib_linalg.html#
is_hermitian-checks-if-a-matrix-is-hermitian">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_hessenberg.html'>is_hessenberg</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is Hessenberg
(<a href="../page/specs/stdlib_linalg.html#
is_hessenberg-checks-if-a-matrix-is-hessenberg">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_hex_digit.html'>is_hex_digit</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a digit in base 16 (0 .. 9, A .. F, a .. f).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_lower.html'>is_lower</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a lowercase ASCII letter (a .. z).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_octal_digit.html'>is_octal_digit</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is a digit in base 8 (0 .. 7).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_printable.html'>is_printable</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is a printable character - including the
space character.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_punctuation.html'>is_punctuation</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is a punctuation character. That includes
all ASCII characters which are not control characters, letters,
digits, or whitespace.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_skew_symmetric.html'>is_skew_symmetric</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is skew-symmetric
(<a href="../page/specs/stdlib_linalg.html#
is_skew_symmetric-checks-if-a-matrix-is-skew-symmetric">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_square.html'>is_square</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is square
(<a href="../page/specs/stdlib_linalg.html#
is_square-checks-if-a-matrix-is-square">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_symmetric.html'>is_symmetric</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is symmetric
(<a href="../page/specs/stdlib_linalg.html#
is_symmetric-checks-if-a-matrix-is-symmetric">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/is_triangular.html'>is_triangular</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Checks if a matrix (rank-2 array) is triangular
(<a href="../page/specs/stdlib_linalg.html#
is_triangular-checks-if-a-matrix-is-triangular">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_upper.html'>is_upper</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether <code>c</code> is an uppercase ASCII letter (A .. Z).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_white.html'>is_white</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Checks whether or not <code>c</code> is a whitespace character. That includes the
space, tab, vertical tab, form feed, carriage return, and linefeed
characters.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/kronecker_product.html'>kronecker_product</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Computes the Kronecker product of two arrays of size M1xN1, and of M2xN2, returning an (M1<em>M2)x(N1</em>N2) array
(<a href="../page/specs/stdlib_linalg.html#
kronecker_product-computes-the-kronecker-product-of-two-matrices">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/legendre.html'>legendre</a></td>
                 <td><a href='../module/stdlib_specialfunctions.html'>stdlib_specialfunctions</a></td>
                 <td>Interface</td>
                 <td><p>Legendre polynomial</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/len.html'>len</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the length of the character sequence represented by the string.</p><a href="../interface/len.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/len_trim.html'>len_trim</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the length of the character sequence without trailing spaces
represented by the string.</p><a href="../interface/len_trim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/lge.html'>lge</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Lexically compare the order of two character sequences being greater equal,
The left-hand side, the right-hand side or both character sequences can
be represented by a string.</p><a href="../interface/lge.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/lgt.html'>lgt</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Lexically compare the order of two character sequences being greater,
The left-hand side, the right-hand side or both character sequences can
be represented by a string.</p><a href="../interface/lgt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linalg_error_handling.html'>linalg_error_handling</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Subroutine</td>
                 <td><p>Flow control: on output flag present, return it; otherwise, halt on error</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/linalg_state_type.html'>linalg_state_type</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/linspace.html'>linspace</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Create rank 1 array of linearly spaced elements
 If the number of elements is not specified, create an array with size 100. If n is a negative value,
 return an array with size 0. If n = 1, return an array whose only element is end
(<a href="../page/specs/stdlib_math.html#linspace-create-a-linearly-spaced-rank-one-array">Specification</a>)</p><a href="../interface/linspace.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/lle.html'>lle</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Lexically compare the order of two character sequences being less equal,
The left-hand side, the right-hand side or both character sequences can
be represented by a string.</p><a href="../interface/lle.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/llt.html'>llt</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Lexically compare the order of two character sequences being less,
The left-hand side, the right-hand side or both character sequences can
be represented by a string.</p><a href="../interface/llt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/load_npy.html'>load_npy</a></td>
                 <td><a href='../module/stdlib_io_npy.html'>stdlib_io_npy</a></td>
                 <td>Interface</td>
                 <td><p>Load multidimensional array in npy format
(<a href="../page/specs/stdlib_io.html#load_npy">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/loadtxt.html'>loadtxt</a></td>
                 <td><a href='../module/stdlib_io.html'>stdlib_io</a></td>
                 <td>Interface</td>
                 <td><p>Loads a 2D array from a text file
(<a href="../page/specs/stdlib_io.html#description">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/log_factorial.html'>log_factorial</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Logarithm of factorial n!, integer variable</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/log_gamma.html'>log_gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Logarithm of gamma function</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/log_lower_incomplete_gamma.html'>log_lower_incomplete_gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Logarithm of lower incomplete gamma function</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/log_upper_incomplete_gamma.html'>log_upper_incomplete_gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Logarithm of upper incomplete gamma function</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/logspace.html'>logspace</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Create rank 1 array of logarithmically spaced elements from base<strong>start to base</strong>end.
 If the number of elements is not specified, create an array with size 50. If n is a negative value,
 return an array with size 0. If n = 1, return an array whose only element is base**end. If no base
 is specified, logspace will default to using a base of 10</p><a href="../interface/logspace.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/lower_incomplete_gamma.html'>lower_incomplete_gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Lower incomplete gamma function</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mean.html'>mean</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Mean of array elements
(<a href="../page/specs/stdlib_stats.html#mean-mean-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/median.html'>median</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Median of array elements
(<a href="../page/specs/stdlib_stats.html#median-median-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/meshgrid.html'>meshgrid</a></td>
                 <td><a href='../module/stdlib_math.html'>stdlib_math</a></td>
                 <td>Interface</td>
                 <td><p>Computes a list of coordinate matrices from coordinate vectors.
(<a href="../page/specs/stdlib_math.html#meshgrid">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/moment.html'>moment</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Central moment of array elements
(<a href="../page/specs/stdlib_stats.html#moment-central-moments-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/move.html'>move</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Moves the allocated character scalar from 'from' to 'to'
<a href="../page/specs/stdlib_string_type.html#move">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/new_nmhash32_seed.html'>new_nmhash32_seed</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>(<a href="../page/specs/stdlib_hash_procedures.html#new_nmhash32_seed-returns-a-valid-input-seed-for-nmhash32">Specification</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/new_nmhash32x_seed.html'>new_nmhash32x_seed</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>(<a href="../page/specs/stdlib_hash_procedures.html#new_nmhash32x_seed-returns-a-valid-input-seed-for-nmhash32x">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/new_pengy_hash_seed.html'>new_pengy_hash_seed</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/new_spooky_hash_seed.html'>new_spooky_hash_seed</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/new_water_hash_seed.html'>new_water_hash_seed</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>(<a href="file:///home/jvandenp/stdlib/API-doc/page/specs/stdlib_hash_procedures.html#new_water_hash_seed-returns-a-valid-input-seed-for-water_hash">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/nmhash32.html'>nmhash32</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>NMHASH32 interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#nmhash32-calculates-a-hash-code-from-a-key-and-a-seed">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/nmhash32x.html'>nmhash32x</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>NMHASH32X interfaces
(<a href="file:///home/jvandenp/stdlib/API-doc/page/specs/stdlib_hash_procedures.html#nmhash32x-calculates-a-hash-code-from-a-key-and-a-seed">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/nrm2.html'>nrm2</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>NRM2 returns the euclidean norm of a vector via the function
name, so that
NRM2 := sqrt( x'*x )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/odd_random_integer.html'>odd_random_integer</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Subroutine</td>
                 <td><p>Returns a 32 bit pseudo random integer, <code>harvest</code>, distributed uniformly over
the odd integers of the <code>int32</code> kind.
(<a href="../page/specs/stdlib_hash_procedures.html#odd_random_integer-returns-an-odd-integer">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/odd_random_integer~2.html'>odd_random_integer</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Subroutine</td>
                 <td><p>Returns a 64 bit pseudo random integer, <code>harvest</code>, distributed uniformly over
the odd integers of the 64 bit kind.
(<a href="../page/specs/stdlib_hash_procedures.html#odd_random_integer-returns-odd-integer">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/open.html'>open</a></td>
                 <td><a href='../module/stdlib_io.html'>stdlib_io</a></td>
                 <td>Function</td>
                 <td><p>Opens a file
 (<a href="../page/specs/stdlib_io.html#description_1">Specification</a>)</p><a href="../proc/open.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(+).html'>operator(+)</a></td>
                 <td><a href='../module/stdlib_ansi.html'>stdlib_ansi</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASHSLASH).html'>operator(//)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Concatenate two character sequences, the left-hand side, the right-hand side
or both character sequences can be represented by a string.</p><a href="../interface/operator(SLASHSLASH).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASHSLASH)~2.html'>operator(//)</a></td>
                 <td><a href='../module/stdlib_ansi.html'>stdlib_ansi</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASHSLASH)~3.html'>operator(//)</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Concatenates stringlist with the input entity
Returns a new stringlist
<a href="../page/specs/stdlib_stringlist_type.html#append-operator">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=).html'>operator(/=)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for inequality, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(SLASH=).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~2.html'>operator(/=)</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Compares stringlist for inequality with the input entity
Returns a logical
<a href="../page/specs/stdlib_stringlist_type.html#inequality-operator">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~3.html'>operator(/=)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~4.html'>operator(/=)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if not all bits in <code>set1</code> and <code>set2</code> have the same value,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-any-bits-differ-in-value">Specification</a>)</p><a href="../interface/operator(SLASH=)~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt).html'>operator(<)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for being less, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(lt).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~2.html'>operator(<)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~3.html'>operator(<)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if the bits in <code>set1</code> and <code>set2</code> differ and the
 highest order different bit is set to 0 in <code>set1</code> and to 1 in <code>set2</code>,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-the-other">Specification</a>)</p><a href="../interface/operator(lt)~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=).html'>operator(<=)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for being less than, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(lt=).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~2.html'>operator(<=)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~3.html'>operator(<=)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if the bits in <code>set1</code> and <code>set2</code> are the same or the
 highest order different bit is set to 0 in <code>set1</code> and to 1 in <code>set2</code>,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-or-equal-to-the-other">Specification</a>)</p><a href="../interface/operator(lt=)~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==).html'>operator(==)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for equality, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(==).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~2.html'>operator(==)</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Compares stringlist for equality with the input entity
Returns a logical
<a href="../page/specs/stdlib_stringlist_type.html#equality-operator">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~3.html'>operator(==)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td><p>Comparison operators</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~4.html'>operator(==)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if all bits in <code>set1</code> and <code>set2</code> have the same value,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value">Specification</a>)</p><a href="../interface/operator(==)~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~5.html'>operator(==)</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt).html'>operator(>)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for being greater, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(gt).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~2.html'>operator(>)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~3.html'>operator(>)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if the bits in <code>set1</code> and <code>set2</code> differ and the
 highest order different bit is set to 1 in <code>set1</code> and to 0 in <code>set2</code>,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-the-other">Specification</a>)</p><a href="../interface/operator(gt)~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=).html'>operator(>=)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Compare two character sequences for being greater than, the left-hand side,
the right-hand side or both character sequences can be represented by
a string.</p><a href="../interface/operator(gt=).html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~2.html'>operator(>=)</a></td>
                 <td><a href='../module/stdlib_linalg_state.html'>stdlib_linalg_state</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~3.html'>operator(>=)</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Returns <code>.true.</code> if the bits in <code>set1</code> and <code>set2</code> are the same or the
 highest order different bit is set to 1 in <code>set1</code> and to 0 in <code>set2</code>,
 <code>.false.</code>  otherwise. The sets must have the same number of bits
 otherwise the result is undefined.
 (<a href="../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-or-equal-to-the-second">Specification</a>)</p><a href="../interface/operator(gt=)~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/optval.html'>optval</a></td>
                 <td><a href='../module/stdlib_optval.html'>stdlib_optval</a></td>
                 <td>Interface</td>
                 <td><p>Fallback value for optional arguments
(<a href="../page/specs/stdlib_optval.html#description">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/or.html'>or</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Sets the bits in <code>set1</code> to the bitwise <code>or</code> of the original bits in <code>set1</code>
 and <code>set2</code>. The sets must have the same number of bits otherwise
 the result is undefined.
 (<a href="../page/specs/stdlib_bitsets.html#or-bitwise-or-of-the-bits-of-two-bitsets">Specification</a>)</p><a href="../interface/or.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ord_sort.html'>ord_sort</a></td>
                 <td><a href='../module/stdlib_sorting.html'>stdlib_sorting</a></td>
                 <td>Interface</td>
                 <td><p>The generic subroutine interface implementing the <code>ORD_SORT</code> algorithm,
a translation to Fortran 2008, of the <code>"Rust" sort</code> algorithm found in
<code>slice.rs</code>
https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159
<code>ORD_SORT</code> is a hybrid stable comparison algorithm combining <code>merge sort</code>,
and <code>insertion sort</code>.
(<a href="../page/specs/stdlib_sorting.html#ord_sort-sorts-an-input-array">Specification</a>)</p><a href="../interface/ord_sort.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/outer_product.html'>outer_product</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Computes the outer product of two vectors, returning a rank-2 array
(<a href="../page/specs/stdlib_linalg.html#
outer_product-computes-the-outer-product-of-two-vectors">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/padl.html'>padl</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Left pad the input string
<a href="../page/specs/stdlib_strings.html#padl">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/padr.html'>padr</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Right pad the input string
<a href="../page/specs/stdlib_strings.html#padr">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/parse_mode.html'>parse_mode</a></td>
                 <td><a href='../module/stdlib_io.html'>stdlib_io</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/pdf_exp.html'>pdf_exp</a></td>
                 <td><a href='../module/stdlib_stats_distribution_exponential.html'>stdlib_stats_distribution_exponential</a></td>
                 <td>Interface</td>
                 <td><p>Version experimental</p><a href="../interface/pdf_exp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/pdf_normal.html'>pdf_normal</a></td>
                 <td><a href='../module/stdlib_stats_distribution_normal.html'>stdlib_stats_distribution_normal</a></td>
                 <td>Interface</td>
                 <td><p>Normal Distribution Probability Density Function
(<a href="../page/specs/stdlib_stats_distribution_normal.html#
pdf_normal-normal-distribution-probability-density-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/pdf_uniform.html'>pdf_uniform</a></td>
                 <td><a href='../module/stdlib_stats_distribution_uniform.html'>stdlib_stats_distribution_uniform</a></td>
                 <td>Interface</td>
                 <td><p>Get uniform distribution probability density (pdf) for integer, real and
complex variables.
(<a href="../page/specs/stdlib_stats_distribution_uniform.html#
pdf_uniform-uniform-probability-density-function">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/pengy_hash.html'>pengy_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td><p>PENGY_HASH interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#pengy_hash-maps-a-character-string-or-integer-vector-to-an-integer">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/radix_sort.html'>radix_sort</a></td>
                 <td><a href='../module/stdlib_sorting.html'>stdlib_sorting</a></td>
                 <td>Interface</td>
                 <td><p>The generic subroutine interface implementing the LSD radix sort algorithm,
see https://en.wikipedia.org/wiki/Radix_sort for more details.
It is always O(N) in sorting random data, but need a O(N) buffer.
(<a href="../page/specs/stdlib_sorting.html#radix_sort-sorts-an-input-array">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/random_seed.html'>random_seed</a></td>
                 <td><a href='../module/stdlib_random.html'>stdlib_random</a></td>
                 <td>Interface</td>
                 <td><p>Version experimental</p><a href="../interface/random_seed.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/read(formatted).html'>read(formatted)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Read a character sequence from a connected unformatted unit into the string.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/read(unformatted).html'>read(unformatted)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Read a character sequence from a connected unformatted unit into the string.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/regularized_gamma_p.html'>regularized_gamma_p</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Regularized (normalized) lower incomplete gamma function, P</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/regularized_gamma_q.html'>regularized_gamma_q</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Regularized (normalized) upper incomplete gamma function, Q</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/repeat.html'>repeat</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Repeats the character sequence hold by the string by the number of
specified copies.</p><a href="../interface/repeat.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/replace_all.html'>replace_all</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Replaces all the occurrences of substring 'pattern' in the input 'string'
with the replacement 'replacement'
Version: experimental</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/reverse.html'>reverse</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Reverse the character order in the input character variable
(<a href="../page/specs/stdlib_ascii.html#reverse">Specification</a>)</p><a href="../proc/reverse.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/reverse~2.html'>reverse</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Reverses the character sequence hold by the input string</p><a href="../interface/reverse~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rot.html'>rot</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>ROT applies a plane rotation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rotg.html'>rotg</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>The computation uses the formulas
|x| = sqrt( Re(x)<strong>2 + Im(x)</strong>2 )
sgn(x) = x / |x|  if x /= 0
= 1        if x  = 0
c = |a| / sqrt(|a|<strong>2 + |b|</strong>2)
s = sgn(a) * conjg(b) / sqrt(|a|<strong>2 + |b|</strong>2)
When a and b are real and r /= 0, the formulas simplify to
r = sgn(a)<em>sqrt(|a|</em><em>2 + |b|</em>*2)
c = a / r
s = b / r
the same as in SROTG when |a| &gt; |b|.  When |b| &gt;= |a|, the
sign of c and s will be different from those computed by SROTG
if the signs of a and b are not the same.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rotm.html'>rotm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
(DX<strong>T) , WHERE </strong>T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN
(DY<em><em>T)
DX(LX+I</em>INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX &gt;= 0, ELSE
LX = (-INCX)</em>N, AND SIMILARLY FOR SY USING LY AND INCY.
WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..
DFLAG=-1._dp     DFLAG=0._dp        DFLAG=1._dp     DFLAG=-2.D0
(DH11  DH12)    (1._dp  DH12)    (DH11  1._dp)    (1._dp  0._dp)
H=(          )    (          )    (          )    (          )
(DH21  DH22),   (DH21  1._dp),   (-1._dp DH22),   (0._dp  1._dp).
SEE ROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rotmg.html'>rotmg</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(DD1)<em>DX1,SQRT(DD2)    DY2)</em>*T.
WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..
DFLAG=-1._dp     DFLAG=0._dp        DFLAG=1._dp     DFLAG=-2.D0
(DH11  DH12)    (1._dp  DH12)    (DH11  1._dp)    (1._dp  0._dp)
H=(          )    (          )    (          )    (          )
(DH21  DH22),   (DH21  1._dp),   (-1._dp DH22),   (0._dp  1._dp).
LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22
RESPECTIVELY. (VALUES OF 1._dp, -1._dp, OR 0._dp IMPLIED BY THE
VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)
THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rvs_exp.html'>rvs_exp</a></td>
                 <td><a href='../module/stdlib_stats_distribution_exponential.html'>stdlib_stats_distribution_exponential</a></td>
                 <td>Interface</td>
                 <td><p>Version experimental</p><a href="../interface/rvs_exp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rvs_normal.html'>rvs_normal</a></td>
                 <td><a href='../module/stdlib_stats_distribution_normal.html'>stdlib_stats_distribution_normal</a></td>
                 <td>Interface</td>
                 <td><p>Normal Distribution Random Variates
(<a href="../page/specs/stdlib_stats_distribution_normal.html#
rvs_normal-normal-distribution-random-variates">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/rvs_uniform.html'>rvs_uniform</a></td>
                 <td><a href='../module/stdlib_stats_distribution_uniform.html'>stdlib_stats_distribution_uniform</a></td>
                 <td>Interface</td>
                 <td><p>Get uniformly distributed random variate for integer, real and complex
variables.
(<a href="../page/specs/stdlib_stats_distribution_uniform.html#
rvs_uniform-uniform-distribution-random-variates">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/save_npy.html'>save_npy</a></td>
                 <td><a href='../module/stdlib_io_npy.html'>stdlib_io_npy</a></td>
                 <td>Interface</td>
                 <td><p>Save multidimensional array in npy format
(<a href="../page/specs/stdlib_io.html#save_npy">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/savetxt.html'>savetxt</a></td>
                 <td><a href='../module/stdlib_io.html'>stdlib_io</a></td>
                 <td>Interface</td>
                 <td><p>Saves a 2D array into a text file
(<a href="../page/specs/stdlib_io.html#description_2">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sbmv.html'>sbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/scal.html'>scal</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SCAL scales a vector by a constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/scan.html'>scan</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Scan a <em>string</em> for the presence of a <em>set</em> of characters. Scans a <em>string</em> for
any of the characters in a <em>set</em> of characters.</p><a href="../interface/scan.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sdot.html'>sdot</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>Compute the inner product of two vectors with extended
precision accumulation and result.
Returns D.P. dot product accumulated in D.P., for S.P. SX and SY
SDOT = sum for I = 0 to N-1 of  SX(LX+I<em>INCX) * SY(LY+I</em>INCY),
where LX = 1 if INCX &gt;= 0, else LX = 1+(1-N)*INCX, and LY is
defined in a similar way using INCY.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/seeded_nmhash32_hasher.html'>seeded_nmhash32_hasher</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Function</td>
                 <td><p>Hashes a key with the NMHASH32 hash algorithm
(<a href="../page/specs/stdlib_hashmaps.html#seeded_nmhash32_hasher-calculates-a-hash-code-from-a-key">Specifications</a>)</p><a href="../proc/seeded_nmhash32_hasher.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/seeded_nmhash32x_hasher.html'>seeded_nmhash32x_hasher</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Function</td>
                 <td><p>Hashes a key with the NMHASH32X hash algorithm
(<a href="../page/specs/stdlib_hashmaps.html#seeded_nmhash32x_hasher-calculates-a-hash-code-from-a-key">Specifications</a>)
Arguments:
    key  - the key to be hashed
    seed - the seed (unused) for the hashing algorithm</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/seeded_water_hasher.html'>seeded_water_hasher</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Function</td>
                 <td><p>Hashes a key with the waterhash algorithm
(<a href="../page/specs/stdlib_hashmaps.html#seeded_water_hasher-calculates-a-hash-code-from-a-key">Specifications</a>)</p><a href="../proc/seeded_water_hasher.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/select.html'>select</a></td>
                 <td><a href='../module/stdlib_selection.html'>stdlib_selection</a></td>
                 <td>Interface</td>
                 <td><p>(<a href="..//page/specs/stdlib_selection.html#select-find-the-k-th-smallest-value-in-an-input-array">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/set.html'>set</a></td>
                 <td><a href='../module/stdlib_hashmap_wrappers.html'>stdlib_hashmap_wrappers</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/shuffle.html'>shuffle</a></td>
                 <td><a href='../module/stdlib_stats_distribution_uniform.html'>stdlib_stats_distribution_uniform</a></td>
                 <td>Interface</td>
                 <td><p>Fisher-Yates shuffle algorithm for a rank one array of integer, real and
complex variables.
(<a href="../page/specs/stdlib_stats_distribution_uniform.html#
shuffle-using-fisher-yates-algorithm-to-generate-a-random-permutation-of-a-list">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/simps.html'>simps</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Integrates sampled values using Simpson's rule
(<a href="../page/specs/stdlib_quadrature.html#description_3">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/simps_weights.html'>simps_weights</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Integrates sampled values using trapezoidal rule weights for given abscissas
(<a href="../page/specs/stdlib_quadrature.html#description_3">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/slice.html'>slice</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Extracts characters from the input string to return a new string</p><a href="../interface/slice.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sort.html'>sort</a></td>
                 <td><a href='../module/stdlib_sorting.html'>stdlib_sorting</a></td>
                 <td>Interface</td>
                 <td><p>The generic subroutine interface implementing the <code>SORT</code> algorithm, based
on the <code>introsort</code> of David Musser.
(<a href="../page/specs/stdlib_sorting.html#sort-sorts-an-input-array">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sort_index.html'>sort_index</a></td>
                 <td><a href='../module/stdlib_sorting.html'>stdlib_sorting</a></td>
                 <td>Interface</td>
                 <td><p>The generic subroutine interface implementing the <code>SORT_INDEX</code> algorithm,
based on the <code>"Rust" sort</code> algorithm found in <code>slice.rs</code>
https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159
but modified to return an array of indices that would provide a stable
sort of the rank one <code>ARRAY</code> input.
(<a href="../page/specs/stdlib_sorting.html#sort_index-creates-an-array-of-sorting-indices-for-an-input-array-while-also-sorting-the-array">Specification</a>)</p><a href="../interface/sort_index.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/spmv.html'>spmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/spooky_hash.html'>spooky_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td><p>SPOOKY_HASH interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#spooky_hash-maps-a-character-string-or-integer-vector-to-an-integer">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/spookyhash_128.html'>spookyHash_128</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/spr.html'>spr</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SPR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/spr2.html'>spr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SPR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/srot.html'>srot</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SROT applies a plane rotation, where the cos and sin (c and s) are real
and the vectors cx and cy are complex.
jack dongarra, linpack, 3/11/78.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sscal.html'>sscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SSCAL scales a complex vector by a real constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/starts_with.html'>starts_with</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Check whether a string starts with substring or not</p><a href="../interface/starts_with.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_caxpy.html'>stdlib_caxpy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CAXPY constant times a vector plus a vector.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ccopy.html'>stdlib_ccopy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CCOPY copies a vector x to a vector y.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cdotc.html'>stdlib_cdotc</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Function</td>
                 <td><p>CDOTC forms the dot product of two complex vectors
CDOTC = X^H * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cdotu.html'>stdlib_cdotu</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Function</td>
                 <td><p>CDOTU forms the dot product of two complex vectors
CDOTU = X^T * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cgbmv.html'>stdlib_cgbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CGBMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cgemm.html'>stdlib_cgemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CGEMM performs one of the matrix-matrix operations
C := alpha<em>op( A )</em>op( B ) + beta<em>C,
where  op( X ) is one of
op( X ) = X   or   op( X ) = X</em><em>T   or   op( X ) = X</em>*H,
alpha and beta are scalars, and A, B and C are matrices, with op( A )
an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cgemv.html'>stdlib_cgemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CGEMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cgerc.html'>stdlib_cgerc</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CGERC performs the rank 1 operation
A := alpha<em>x</em>y**H + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cgeru.html'>stdlib_cgeru</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CGERU performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chbmv.html'>stdlib_chbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chemm.html'>stdlib_chemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHEMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where alpha and beta are scalars, A is an hermitian matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chemv.html'>stdlib_chemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHEMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cher.html'>stdlib_cher</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHER performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cher2.html'>stdlib_cher2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHER2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cher2k.html'>stdlib_cher2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHER2K performs one of the hermitian rank 2k operations
C := alpha<em>A</em>B<strong>H + conjg( alpha )<em>B</em>A</strong>H + beta<em>C,
or
C := alpha</em>A<strong>H<em>B + conjg( alpha )</em>B</strong>H<em>A + beta</em>C,
where  alpha and beta  are scalars with  beta  real,  C is an  n by n
hermitian matrix and  A and B  are  n by k matrices in the first case
and  k by n  matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cherk.html'>stdlib_cherk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHERK performs one of the hermitian rank k operations
C := alpha<em>A</em>A<strong>H + beta<em>C,
or
C := alpha</em>A</strong>H<em>A + beta</em>C,
where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
matrix and  A  is an  n by k  matrix in the  first case and a  k by n
matrix in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chpmv.html'>stdlib_chpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chpr.html'>stdlib_chpr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHPR performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_chpr2.html'>stdlib_chpr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CHPR2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_crotg.html'>stdlib_crotg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>The computation uses the formulas
|x| = sqrt( Re(x)<strong>2 + Im(x)</strong>2 )
sgn(x) = x / |x|  if x /= 0
= 1        if x  = 0
c = |a| / sqrt(|a|<strong>2 + |b|</strong>2)
s = sgn(a) * conjg(b) / sqrt(|a|<strong>2 + |b|</strong>2)
When a and b are real and r /= 0, the formulas simplify to
r = sgn(a)<em>sqrt(|a|</em><em>2 + |b|</em>*2)
c = a / r
s = b / r
the same as in SROTG when |a| &gt; |b|.  When |b| &gt;= |a|, the
sign of c and s will be different from those computed by SROTG
if the signs of a and b are not the same.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cscal.html'>stdlib_cscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSCAL scales a vector by a constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_csrot.html'>stdlib_csrot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSROT applies a plane rotation, where the cos and sin (c and s) are real
and the vectors cx and cy are complex.
jack dongarra, linpack, 3/11/78.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_csscal.html'>stdlib_csscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSSCAL scales a complex vector by a real constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_cswap.html'>stdlib_cswap</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSWAP interchanges two vectors.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_csymm.html'>stdlib_csymm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSYMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where  alpha and beta are scalars, A is a symmetric matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_csyr2k.html'>stdlib_csyr2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSYR2K performs one of the symmetric rank 2k operations
C := alpha<em>A</em>B<strong>T + alpha<em>B</em>A</strong>T + beta<em>C,
or
C := alpha</em>A<strong>T<em>B + alpha</em>B</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A and B  are  n by k  matrices  in the  first  case  and  k by n
matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_csyrk.html'>stdlib_csyrk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CSYRK performs one of the symmetric rank k operations
C := alpha<em>A</em>A<strong>T + beta<em>C,
or
C := alpha</em>A</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A  is an  n by k  matrix in the first case and a  k by n  matrix
in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctbmv.html'>stdlib_ctbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTBMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctbsv.html'>stdlib_ctbsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTBSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular band matrix, with ( k + 1 )
diagonals.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctpmv.html'>stdlib_ctpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTPMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctpsv.html'>stdlib_ctpsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTPSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix, supplied in packed form.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctrmm.html'>stdlib_ctrmm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTRMM performs one of the matrix-matrix operations
B := alpha<em>op( A )</em>B,   or   B := alpha<em>B</em>op( A )
where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctrmv.html'>stdlib_ctrmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTRMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctrsm.html'>stdlib_ctrsm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTRSM solves one of the matrix equations
op( A )<em>X = alpha</em>B,   or   X<em>op( A ) = alpha</em>B,
where alpha is a scalar, X and B are m by n matrices, A is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.
The matrix X is overwritten on B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ctrsv.html'>stdlib_ctrsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_c.html'>stdlib_linalg_blas_c</a></td>
                 <td>Subroutine</td>
                 <td><p>CTRSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dasum.html'>stdlib_dasum</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>DASUM takes the sum of the absolute values.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_daxpy.html'>stdlib_daxpy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DAXPY constant times a vector plus a vector.
uses unrolled loops for increments equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dcabs1.html'>stdlib_dcabs1</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>DCABS1 computes |Re(.)| + |Im(.)| of a double complex number</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dcopy.html'>stdlib_dcopy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DCOPY copies a vector, x, to a vector, y.
uses unrolled loops for increments equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ddot.html'>stdlib_ddot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>DDOT forms the dot product of two vectors.
uses unrolled loops for increments equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dgbmv.html'>stdlib_dgbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DGBMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<em><em>T</em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dgemm.html'>stdlib_dgemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DGEMM performs one of the matrix-matrix operations
C := alpha<em>op( A )</em>op( B ) + beta<em>C,
where  op( X ) is one of
op( X ) = X   or   op( X ) = X</em>*T,
alpha and beta are scalars, and A, B and C are matrices, with op( A )
an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dgemv.html'>stdlib_dgemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DGEMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<em><em>T</em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dger.html'>stdlib_dger</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DGER performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dnrm2.html'>stdlib_dnrm2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>DNRM2 returns the euclidean norm of a vector via the function
name, so that
DNRM2 := sqrt( x'*x )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_drot.html'>stdlib_drot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DROT applies a plane rotation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_drotg.html'>stdlib_drotg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>The computation uses the formulas
sigma = sgn(a)    if |a| &gt;  |b|
= sgn(b)    if |b| &gt;= |a|
r = sigma<em>sqrt( a</em><em>2 + b</em><em>2 )
c = 1; s = 0      if r = 0
c = a/r; s = b/r  if r != 0
The subroutine also computes
z = s    if |a| &gt; |b|,
= 1/c  if |b| &gt;= |a| and c != 0
= 1    if c = 0
This allows c and s to be reconstructed from z as follows:
If z = 1, set c = 0, s = 1.
If |z| &lt; 1, set c = sqrt(1 - z</em><em>2) and s = z.
If |z| &gt; 1, set c = 1/z and s = sqrt( 1 - c</em>*2).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_drotm.html'>stdlib_drotm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
(DX<strong>T) , WHERE </strong>T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN
(DY<em><em>T)
DX(LX+I</em>INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX &gt;= 0, ELSE
LX = (-INCX)</em>N, AND SIMILARLY FOR SY USING LY AND INCY.
WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..
DFLAG=-1._dp     DFLAG=0._dp        DFLAG=1._dp     DFLAG=-2.D0
(DH11  DH12)    (1._dp  DH12)    (DH11  1._dp)    (1._dp  0._dp)
H=(          )    (          )    (          )    (          )
(DH21  DH22),   (DH21  1._dp),   (-1._dp DH22),   (0._dp  1._dp).
SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_drotmg.html'>stdlib_drotmg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(DD1)<em>DX1,SQRT(DD2)    DY2)</em>*T.
WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..
DFLAG=-1._dp     DFLAG=0._dp        DFLAG=1._dp     DFLAG=-2.D0
(DH11  DH12)    (1._dp  DH12)    (DH11  1._dp)    (1._dp  0._dp)
H=(          )    (          )    (          )    (          )
(DH21  DH22),   (DH21  1._dp),   (-1._dp DH22),   (0._dp  1._dp).
LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22
RESPECTIVELY. (VALUES OF 1._dp, -1._dp, OR 0._dp IMPLIED BY THE
VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)
THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsbmv.html'>stdlib_dsbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dscal.html'>stdlib_dscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSCAL scales a vector by a constant.
uses unrolled loops for increment equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsdot.html'>stdlib_dsdot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>Compute the inner product of two vectors with extended
precision accumulation and result.
Returns D.P. dot product accumulated in D.P., for S.P. SX and SY
DSDOT = sum for I = 0 to N-1 of  SX(LX+I<em>INCX) * SY(LY+I</em>INCY),
where LX = 1 if INCX &gt;= 0, else LX = 1+(1-N)*INCX, and LY is
defined in a similar way using INCY.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dspmv.html'>stdlib_dspmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dspr.html'>stdlib_dspr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSPR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dspr2.html'>stdlib_dspr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSPR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dswap.html'>stdlib_dswap</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSWAP interchanges two vectors.
uses unrolled loops for increments equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsymm.html'>stdlib_dsymm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where alpha and beta are scalars,  A is a symmetric matrix and  B and
C are  m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsymv.html'>stdlib_dsymv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsyr.html'>stdlib_dsyr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsyr2.html'>stdlib_dsyr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsyr2k.html'>stdlib_dsyr2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYR2K performs one of the symmetric rank 2k operations
C := alpha<em>A</em>B<strong>T + alpha<em>B</em>A</strong>T + beta<em>C,
or
C := alpha</em>A<strong>T<em>B + alpha</em>B</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
and  A and B  are  n by k  matrices  in the  first  case  and  k by n
matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dsyrk.html'>stdlib_dsyrk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DSYRK performs one of the symmetric rank k operations
C := alpha<em>A</em>A<strong>T + beta<em>C,
or
C := alpha</em>A</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
and  A  is an  n by k  matrix in the first case and a  k by n  matrix
in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtbmv.html'>stdlib_dtbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTBMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtbsv.html'>stdlib_dtbsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTBSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular band matrix, with ( k + 1 )
diagonals.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtpmv.html'>stdlib_dtpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTPMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtpsv.html'>stdlib_dtpsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTPSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix, supplied in packed form.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtrmm.html'>stdlib_dtrmm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTRMM performs one of the matrix-matrix operations
B := alpha<em>op( A )</em>B,   or   B := alpha<em>B</em>op( A ),
where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A**T.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtrmv.html'>stdlib_dtrmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTRMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtrsm.html'>stdlib_dtrsm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTRSM solves one of the matrix equations
op( A )<em>X = alpha</em>B,   or   X<em>op( A ) = alpha</em>B,
where alpha is a scalar, X and B are m by n matrices, A is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A**T.
The matrix X is overwritten on B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dtrsv.html'>stdlib_dtrsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Subroutine</td>
                 <td><p>DTRSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dzasum.html'>stdlib_dzasum</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and
returns a double precision result.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_dznrm2.html'>stdlib_dznrm2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_d.html'>stdlib_linalg_blas_d</a></td>
                 <td>Function</td>
                 <td><p>DZNRM2 returns the euclidean norm of a vector via the function
name, so that
DZNRM2 := sqrt( x*<em>H</em>x )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_icamax.html'>stdlib_icamax</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_idamax.html'>stdlib_idamax</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>IDAMAX finds the index of the first element having maximum absolute value.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_isamax.html'>stdlib_isamax</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>ISAMAX finds the index of the first element having maximum absolute value.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_izamax.html'>stdlib_izamax</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>IZAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_lsame.html'>stdlib_lsame</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>LSAME returns .TRUE. if CA is the same letter as CB regardless of
case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sasum.html'>stdlib_sasum</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>SASUM takes the sum of the absolute values.
uses unrolled loops for increment equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_saxpy.html'>stdlib_saxpy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SAXPY constant times a vector plus a vector.
uses unrolled loops for increments equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_scabs1.html'>stdlib_scabs1</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Function</td>
                 <td><p>SCABS1 computes |Re(.)| + |Im(.)| of a complex number</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_scasum.html'>stdlib_scasum</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and
returns a single precision result.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_scnrm2.html'>stdlib_scnrm2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>SCNRM2 returns the euclidean norm of a vector via the function
name, so that
SCNRM2 := sqrt( x*<em>H</em>x )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_scopy.html'>stdlib_scopy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SCOPY copies a vector, x, to a vector, y.
uses unrolled loops for increments equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sdot.html'>stdlib_sdot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>SDOT forms the dot product of two vectors.
uses unrolled loops for increments equal to one.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sdsdot.html'>stdlib_sdsdot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>Compute the inner product of two vectors with extended
precision accumulation.
Returns S.P. result with dot product accumulated in D.P.
SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I<em>INCX)</em>SY(LY+I<em>INCY),
where LX = 1 if INCX &gt;= 0, else LX = 1+(1-N)</em>INCX, and LY is
defined in a similar way using INCY.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sgbmv.html'>stdlib_sgbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SGBMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<em><em>T</em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sgemm.html'>stdlib_sgemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SGEMM performs one of the matrix-matrix operations
C := alpha<em>op( A )</em>op( B ) + beta<em>C,
where  op( X ) is one of
op( X ) = X   or   op( X ) = X</em>*T,
alpha and beta are scalars, and A, B and C are matrices, with op( A )
an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sgemv.html'>stdlib_sgemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SGEMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<em><em>T</em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sger.html'>stdlib_sger</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SGER performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_snrm2.html'>stdlib_snrm2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Function</td>
                 <td><p>SNRM2 returns the euclidean norm of a vector via the function
name, so that
SNRM2 := sqrt( x'*x ).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_srot.html'>stdlib_srot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>applies a plane rotation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_srotg.html'>stdlib_srotg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>The computation uses the formulas
sigma = sgn(a)    if |a| &gt;  |b|
= sgn(b)    if |b| &gt;= |a|
r = sigma<em>sqrt( a</em><em>2 + b</em><em>2 )
c = 1; s = 0      if r = 0
c = a/r; s = b/r  if r != 0
The subroutine also computes
z = s    if |a| &gt; |b|,
= 1/c  if |b| &gt;= |a| and c != 0
= 1    if c = 0
This allows c and s to be reconstructed from z as follows:
If z = 1, set c = 0, s = 1.
If |z| &lt; 1, set c = sqrt(1 - z</em><em>2) and s = z.
If |z| &gt; 1, set c = 1/z and s = sqrt( 1 - c</em>*2).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_srotm.html'>stdlib_srotm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
(SX<strong>T) , WHERE </strong>T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN
(SX<em><em>T)
SX(LX+I</em>INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX &gt;= 0, ELSE
LX = (-INCX)</em>N, AND SIMILARLY FOR SY USING USING LY AND INCY.
WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS..
SFLAG=-1._sp     SFLAG=0._sp        SFLAG=1._sp     SFLAG=-2.E0
(SH11  SH12)    (1._sp  SH12)    (SH11  1._sp)    (1._sp  0._sp)
H=(          )    (          )    (          )    (          )
(SH21  SH22),   (SH21  1._sp),   (-1._sp SH22),   (0._sp  1._sp).
SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_srotmg.html'>stdlib_srotmg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(SD1)<em>SX1,SQRT(SD2)    SY2)</em>*T.
WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS..
SFLAG=-1._sp     SFLAG=0._sp        SFLAG=1._sp     SFLAG=-2.E0
(SH11  SH12)    (1._sp  SH12)    (SH11  1._sp)    (1._sp  0._sp)
H=(          )    (          )    (          )    (          )
(SH21  SH22),   (SH21  1._sp),   (-1._sp SH22),   (0._sp  1._sp).
LOCATIONS 2-4 OF SPARAM CONTAIN SH11,SH21,SH12, AND SH22
RESPECTIVELY. (VALUES OF 1._sp, -1._sp, OR 0._sp IMPLIED BY THE
VALUE OF SPARAM(1) ARE NOT STORED IN SPARAM.)
THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
OF SD1 AND SD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssbmv.html'>stdlib_ssbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sscal.html'>stdlib_sscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSCAL scales a vector by a constant.
uses unrolled loops for increment equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sspmv.html'>stdlib_sspmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sspr.html'>stdlib_sspr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSPR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sspr2.html'>stdlib_sspr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSPR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n symmetric matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_sswap.html'>stdlib_sswap</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSWAP interchanges two vectors.
uses unrolled loops for increments equal to 1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssymm.html'>stdlib_ssymm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where alpha and beta are scalars,  A is a symmetric matrix and  B and
C are  m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssymv.html'>stdlib_ssymv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssyr.html'>stdlib_ssyr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssyr2.html'>stdlib_ssyr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssyr2k.html'>stdlib_ssyr2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYR2K performs one of the symmetric rank 2k operations
C := alpha<em>A</em>B<strong>T + alpha<em>B</em>A</strong>T + beta<em>C,
or
C := alpha</em>A<strong>T<em>B + alpha</em>B</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
and  A and B  are  n by k  matrices  in the  first  case  and  k by n
matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ssyrk.html'>stdlib_ssyrk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>SSYRK performs one of the symmetric rank k operations
C := alpha<em>A</em>A<strong>T + beta<em>C,
or
C := alpha</em>A</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
and  A  is an  n by k  matrix in the first case and a  k by n  matrix
in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_stbmv.html'>stdlib_stbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STBMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_stbsv.html'>stdlib_stbsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STBSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular band matrix, with ( k + 1 )
diagonals.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_stpmv.html'>stdlib_stpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STPMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_stpsv.html'>stdlib_stpsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STPSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix, supplied in packed form.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_strmm.html'>stdlib_strmm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STRMM performs one of the matrix-matrix operations
B := alpha<em>op( A )</em>B,   or   B := alpha<em>B</em>op( A ),
where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A**T.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_strmv.html'>stdlib_strmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STRMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_strsm.html'>stdlib_strsm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STRSM solves one of the matrix equations
op( A )<em>X = alpha</em>B,   or   X<em>op( A ) = alpha</em>B,
where alpha is a scalar, X and B are m by n matrices, A is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A**T.
The matrix X is overwritten on B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_strsv.html'>stdlib_strsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_s.html'>stdlib_linalg_blas_s</a></td>
                 <td>Subroutine</td>
                 <td><p>STRSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_xerbla.html'>stdlib_xerbla</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Subroutine</td>
                 <td><p>XERBLA is an error handler for the LAPACK routines.
It is called by an LAPACK routine if an input parameter has an
invalid value.  A message is printed and execution stops.
Installers may consider modifying the STOP statement in order to
call system-specific exception-handling facilities.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_xerbla_array.html'>stdlib_xerbla_array</a></td>
                 <td><a href='../module/stdlib_linalg_blas_aux.html'>stdlib_linalg_blas_aux</a></td>
                 <td>Subroutine</td>
                 <td><p>XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK
and BLAS error handler.  Rather than taking a Fortran string argument
as the function's name, XERBLA_ARRAY takes an array of single
characters along with the array's length.  XERBLA_ARRAY then copies
up to 32 characters of that array into a Fortran string and passes
that to XERBLA.  If called with a non-positive SRNAME_LEN,
XERBLA_ARRAY will call XERBLA with a string of all blank characters.
Say some macro or other device makes XERBLA_ARRAY available to C99
by a name lapack_xerbla and with a common Fortran calling convention.
Then a C99 program could invoke XERBLA via:
{
int flen = strlen(<strong>func</strong>);
lapack_xerbla(<strong>func</strong>,
}
Providing XERBLA_ARRAY is not necessary for intercepting LAPACK
errors.  XERBLA_ARRAY calls XERBLA.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zaxpy.html'>stdlib_zaxpy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZAXPY constant times a vector plus a vector.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zcopy.html'>stdlib_zcopy</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZCOPY copies a vector, x, to a vector, y.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zdotc.html'>stdlib_zdotc</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Function</td>
                 <td><p>ZDOTC forms the dot product of two complex vectors
ZDOTC = X^H * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zdotu.html'>stdlib_zdotu</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Function</td>
                 <td><p>ZDOTU forms the dot product of two complex vectors
ZDOTU = X^T * Y</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zdrot.html'>stdlib_zdrot</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies a plane rotation, where the cos and sin (c and s) are real
and the vectors cx and cy are complex.
jack dongarra, linpack, 3/11/78.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zdscal.html'>stdlib_zdscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZDSCAL scales a vector by a constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zgbmv.html'>stdlib_zgbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZGBMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n band matrix, with kl sub-diagonals and ku super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zgemm.html'>stdlib_zgemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZGEMM performs one of the matrix-matrix operations
C := alpha<em>op( A )</em>op( B ) + beta<em>C,
where  op( X ) is one of
op( X ) = X   or   op( X ) = X</em><em>T   or   op( X ) = X</em>*H,
alpha and beta are scalars, and A, B and C are matrices, with op( A )
an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zgemv.html'>stdlib_zgemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZGEMV performs one of the matrix-vector operations
y := alpha<em>A</em>x + beta<em>y,   or   y := alpha</em>A<strong>T<em>x + beta</em>y,   or
y := alpha*A</strong>H<em>x + beta</em>y,
where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zgerc.html'>stdlib_zgerc</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZGERC performs the rank 1 operation
A := alpha<em>x</em>y**H + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zgeru.html'>stdlib_zgeru</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZGERU performs the rank 1 operation
A := alpha<em>x</em>y**T + A,
where alpha is a scalar, x is an m element vector, y is an n element
vector and A is an m by n matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhbmv.html'>stdlib_zhbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHBMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian band matrix, with k super-diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhemm.html'>stdlib_zhemm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHEMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where alpha and beta are scalars, A is an hermitian matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhemv.html'>stdlib_zhemv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHEMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zher.html'>stdlib_zher</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHER performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zher2.html'>stdlib_zher2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHER2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n hermitian matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zher2k.html'>stdlib_zher2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHER2K performs one of the hermitian rank 2k operations
C := alpha<em>A</em>B<strong>H + conjg( alpha )<em>B</em>A</strong>H + beta<em>C,
or
C := alpha</em>A<strong>H<em>B + conjg( alpha )</em>B</strong>H<em>A + beta</em>C,
where  alpha and beta  are scalars with  beta  real,  C is an  n by n
hermitian matrix and  A and B  are  n by k matrices in the first case
and  k by n  matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zherk.html'>stdlib_zherk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHERK performs one of the hermitian rank k operations
C := alpha<em>A</em>A<strong>H + beta<em>C,
or
C := alpha</em>A</strong>H<em>A + beta</em>C,
where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
matrix and  A  is an  n by k  matrix in the  first case and a  k by n
matrix in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhpmv.html'>stdlib_zhpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHPMV performs the matrix-vector operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhpr.html'>stdlib_zhpr</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHPR performs the hermitian rank 1 operation
A := alpha<em>x</em>x**H + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zhpr2.html'>stdlib_zhpr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZHPR2 performs the hermitian rank 2 operation
A := alpha<em>x</em>y<strong>H + conjg( alpha )<em>y</em>x</strong>H + A,
where alpha is a scalar, x and y are n element vectors and A is an
n by n hermitian matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zrotg.html'>stdlib_zrotg</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>The computation uses the formulas
|x| = sqrt( Re(x)<strong>2 + Im(x)</strong>2 )
sgn(x) = x / |x|  if x /= 0
= 1        if x  = 0
c = |a| / sqrt(|a|<strong>2 + |b|</strong>2)
s = sgn(a) * conjg(b) / sqrt(|a|<strong>2 + |b|</strong>2)
When a and b are real and r /= 0, the formulas simplify to
r = sgn(a)<em>sqrt(|a|</em><em>2 + |b|</em>*2)
c = a / r
s = b / r
the same as in DROTG when |a| &gt; |b|.  When |b| &gt;= |a|, the
sign of c and s will be different from those computed by DROTG
if the signs of a and b are not the same.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zscal.html'>stdlib_zscal</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZSCAL scales a vector by a constant.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zswap.html'>stdlib_zswap</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZSWAP interchanges two vectors.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zsymm.html'>stdlib_zsymm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZSYMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where  alpha and beta are scalars, A is a symmetric matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zsyr2k.html'>stdlib_zsyr2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZSYR2K performs one of the symmetric rank 2k operations
C := alpha<em>A</em>B<strong>T + alpha<em>B</em>A</strong>T + beta<em>C,
or
C := alpha</em>A<strong>T<em>B + alpha</em>B</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A and B  are  n by k  matrices  in the  first  case  and  k by n
matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_zsyrk.html'>stdlib_zsyrk</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZSYRK performs one of the symmetric rank k operations
C := alpha<em>A</em>A<strong>T + beta<em>C,
or
C := alpha</em>A</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A  is an  n by k  matrix in the first case and a  k by n  matrix
in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztbmv.html'>stdlib_ztbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTBMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztbsv.html'>stdlib_ztbsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTBSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular band matrix, with ( k + 1 )
diagonals.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztpmv.html'>stdlib_ztpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTPMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztpsv.html'>stdlib_ztpsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTPSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix, supplied in packed form.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztrmm.html'>stdlib_ztrmm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTRMM performs one of the matrix-matrix operations
B := alpha<em>op( A )</em>B,   or   B := alpha<em>B</em>op( A )
where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztrmv.html'>stdlib_ztrmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTRMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztrsm.html'>stdlib_ztrsm</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTRSM solves one of the matrix equations
op( A )<em>X = alpha</em>B,   or   X<em>op( A ) = alpha</em>B,
where alpha is a scalar, X and B are m by n matrices, A is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.
The matrix X is overwritten on B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stdlib_ztrsv.html'>stdlib_ztrsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas_z.html'>stdlib_linalg_blas_z</a></td>
                 <td>Subroutine</td>
                 <td><p>ZTRSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/string_type.html'>string_type</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Constructor for new string instances</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/stringlist_type.html'>stringlist_type</a></td>
                 <td><a href='../module/stdlib_stringlist_type.html'>stdlib_stringlist_type</a></td>
                 <td>Interface</td>
                 <td><p>Constructor for stringlist
Returns an instance of type stringlist_type
<a href="../page/specs/stdlib_stringlist_type.html#stringlist_type">Specifications</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/strip.html'>strip</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Remove leading and trailing whitespace characters.</p><a href="../interface/strip.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/swap.html'>swap</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SWAP interchanges two vectors.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/symm.html'>symm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYMM performs one of the matrix-matrix operations
C := alpha<em>A</em>B + beta<em>C,
or
C := alpha</em>B<em>A + beta</em>C,
where  alpha and beta are scalars, A is a symmetric matrix and  B and
C are m by n matrices.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/symv.html'>symv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYMV performs the matrix-vector  operation
y := alpha<em>A</em>x + beta*y,
where alpha and beta are scalars, x and y are n element vectors and
A is an n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/syr.html'>syr</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYR performs the symmetric rank 1 operation
A := alpha<em>x</em>x**T + A,
where alpha is a real scalar, x is an n element vector and A is an
n by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/syr2.html'>syr2</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYR2 performs the symmetric rank 2 operation
A := alpha<em>x</em>y<strong>T + alpha<em>y</em>x</strong>T + A,
where alpha is a scalar, x and y are n element vectors and A is an n
by n symmetric matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/syr2k.html'>syr2k</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYR2K performs one of the symmetric rank 2k operations
C := alpha<em>A</em>B<strong>T + alpha<em>B</em>A</strong>T + beta<em>C,
or
C := alpha</em>A<strong>T<em>B + alpha</em>B</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A and B  are  n by k  matrices  in the  first  case  and  k by n
matrices in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/syrk.html'>syrk</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>SYRK performs one of the symmetric rank k operations
C := alpha<em>A</em>A<strong>T + beta<em>C,
or
C := alpha</em>A</strong>T<em>A + beta</em>C,
where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
and  A  is an  n by k  matrix in the first case and a  k by n  matrix
in the second case.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/tbmv.html'>tbmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TBMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular band matrix, with ( k + 1 ) diagonals.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/tbsv.html'>tbsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TBSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular band matrix, with ( k + 1 )
diagonals.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/to_lower.html'>to_lower</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Convert character variable to lower case
(<a href="../page/specs/stdlib_ascii.html#to_lower">Specification</a>)</p><a href="../proc/to_lower.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_lower~2.html'>to_lower</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the lowercase version of the character sequence hold by the input string</p><a href="../interface/to_lower~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_num.html'>to_num</a></td>
                 <td><a href='../module/stdlib_str2num.html'>stdlib_str2num</a></td>
                 <td>Interface</td>
                 <td><p>Conversion of strings to numbers
(<a href="../page/specs/stdlib_str2num.html#to-num-conversion-of-strings-to-numbers">Specification</a>) </p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_num_from_stream.html'>to_num_from_stream</a></td>
                 <td><a href='../module/stdlib_str2num.html'>stdlib_str2num</a></td>
                 <td>Interface</td>
                 <td><p>Conversion of a stream of values in a string to numbers
(<a href="../page/specs/stdlib_str2num.html#to-num-p-conversion-of-a-stream-of-values-in-a-strings-to-numbers">Specification</a>) </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/to_sentence.html'>to_sentence</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Converts character sequence to sentence case
(<a href="../page/specs/stdlib_ascii.html#to_sentence">Specification</a>)</p><a href="../proc/to_sentence.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_sentence~2.html'>to_sentence</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the sentencecase version of the character sequence hold by the input string</p><a href="../interface/to_sentence~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_string.html'>to_string</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Format or transfer other types as a string.
(<a href="../page/specs/stdlib_strings.html#to_string">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_string~2.html'>to_string</a></td>
                 <td><a href='../module/stdlib_ansi.html'>stdlib_ansi</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/to_title.html'>to_title</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Converts character sequence to title case
(<a href="../page/specs/stdlib_ascii.html#to_title">Specification</a>)</p><a href="../proc/to_title.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_title~2.html'>to_title</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the titlecase version of the character sequence hold by the input string</p><a href="../interface/to_title~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/to_upper.html'>to_upper</a></td>
                 <td><a href='../module/stdlib_ascii.html'>stdlib_ascii</a></td>
                 <td>Function</td>
                 <td><p>Convert character variable to upper case
(<a href="../page/specs/stdlib_ascii.html#to_upper">Specification</a>)</p><a href="../proc/to_upper.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/to_upper~2.html'>to_upper</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the uppercase version of the character sequence hold by the input string</p><a href="../interface/to_upper~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/tpmv.html'>tpmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TPMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix, supplied in packed form.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/tpsv.html'>tpsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TPSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix, supplied in packed form.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trace.html'>trace</a></td>
                 <td><a href='../module/stdlib_linalg.html'>stdlib_linalg</a></td>
                 <td>Interface</td>
                 <td><p>Computes the trace of a matrix
(<a href="../page/specs/stdlib_linalg.html#
trace-trace-of-a-matrix">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trapz.html'>trapz</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Integrates sampled values using trapezoidal rule
(<a href="../page/specs/stdlib_quadrature.html#description">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trapz_weights.html'>trapz_weights</a></td>
                 <td><a href='../module/stdlib_quadrature.html'>stdlib_quadrature</a></td>
                 <td>Interface</td>
                 <td><p>Integrates sampled values using trapezoidal rule weights for given abscissas
(<a href="../page/specs/stdlib_quadrature.html#description_1">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trim.html'>trim</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Returns the character sequence hold by the string without trailing spaces.</p><a href="../interface/trim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trmm.html'>trmm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TRMM performs one of the matrix-matrix operations
B := alpha<em>op( A )</em>B,   or   B := alpha<em>B</em>op( A )
where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trmv.html'>trmv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TRMV performs one of the matrix-vector operations
x := A<em>x,   or   x := A</em><em>T</em>x,   or   x := A*<em>H</em>x,
where x is an n element vector and  A is an n by n unit, or non-unit,
upper or lower triangular matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trsm.html'>trsm</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TRSM solves one of the matrix equations
op( A )<em>X = alpha</em>B,   or   X<em>op( A ) = alpha</em>B,
where alpha is a scalar, X and B are m by n matrices, A is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
op( A ) = A   or   op( A ) = A<strong>T   or   op( A ) = A</strong>H.
The matrix X is overwritten on B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trsv.html'>trsv</a></td>
                 <td><a href='../module/stdlib_linalg_blas.html'>stdlib_linalg_blas</a></td>
                 <td>Interface</td>
                 <td><p>TRSV solves one of the systems of equations
A<em>x = b,   or   A</em><em>T</em>x = b,   or   A*<em>H</em>x = b,
where b and x are n element vectors and A is an n by n unit, or
non-unit, upper or lower triangular matrix.
No test for singularity or near-singularity is included in this
routine. Such tests must be performed before calling this routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/trueloc.html'>trueloc</a></td>
                 <td><a href='../module/stdlib_array.html'>stdlib_array</a></td>
                 <td>Function</td>
                 <td><p>Return the positions of the true elements in array.
<a href="../page/specs/stdlib_array.html#trueloc">Specification</a></p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/universal_mult_hash.html'>universal_mult_hash</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Function</td>
                 <td><p>Uses the "random" odd 32 bit integer <code>seed</code> to map the 32 bit integer <code>key</code> to
an unsigned integer value with only <code>nbits</code> bits where <code>nbits</code> is less than 32
(<a href="../page/specs/stdlib_hash_procedures.html#universal_mult_hash-maps-an-integer-to-a-smaller-number-of-bits">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/universal_mult_hash~2.html'>universal_mult_hash</a></td>
                 <td><a href='../module/stdlib_hash_64bit.html'>stdlib_hash_64bit</a></td>
                 <td>Function</td>
                 <td><p>Uses the "random" odd 64 bit integer <code>seed</code> to map the 64 bit integer <code>key</code> to
an unsigned integer value with only <code>nbits</code> bits where <code>nbits</code> is less than 64.
(<a href="../page/specs/stdlib_hash_procedures.html#universal_mult_hash-maps-an-integer-to-a-smaller-number-of-bits_1">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/upper_incomplete_gamma.html'>upper_incomplete_gamma</a></td>
                 <td><a href='../module/stdlib_specialfunctions_gamma.html'>stdlib_specialfunctions_gamma</a></td>
                 <td>Interface</td>
                 <td><p>Upper incomplete gamma function</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/var.html'>var</a></td>
                 <td><a href='../module/stdlib_stats.html'>stdlib_stats</a></td>
                 <td>Interface</td>
                 <td><p>Variance of array elements
(<a href="../page/specs/stdlib_stats.html#var-variance-of-array-elements">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/verify.html'>verify</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Scan a string for the absence of a set of characters. Verifies that all
the characters in string belong to the set of characters in set.</p><a href="../interface/verify.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/water_hash.html'>water_hash</a></td>
                 <td><a href='../module/stdlib_hash_32bit.html'>stdlib_hash_32bit</a></td>
                 <td>Interface</td>
                 <td><p>WATER_HASH interfaces
(<a href="../page/specs/stdlib_hash_procedures.html#water_hash-calculates-a-hash-code-from-a-key-and-a-seed">Specification</a>)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/write(formatted).html'>write(formatted)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Write the character sequence hold by the string to a connected formatted
unit.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/write(unformatted).html'>write(unformatted)</a></td>
                 <td><a href='../module/stdlib_string_type.html'>stdlib_string_type</a></td>
                 <td>Interface</td>
                 <td><p>Write the character sequence hold by the string to a connected unformatted
unit.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/xor.html'>xor</a></td>
                 <td><a href='../module/stdlib_bitsets.html'>stdlib_bitsets</a></td>
                 <td>Interface</td>
                 <td><p>Sets the bits in <code>set1</code> to the bitwise <code>xor</code> of the original bits in <code>set1</code>
 and <code>set2</code>. The sets must have the same number of bits
 otherwise the result is undefined.
(<a href="../page/specs/stdlib_bitsets.html#xor-bitwise-exclusive-or">Specification</a>)</p><a href="../interface/xor.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/zfill.html'>zfill</a></td>
                 <td><a href='../module/stdlib_strings.html'>stdlib_strings</a></td>
                 <td>Interface</td>
                 <td><p>Left pad the input string with zeros.
<a href="../page/specs/stdlib_strings.html#zfill">Specifications</a></p></td>
               </tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>Fortran-lang/stdlib was developed by fortran-lang/stdlib contributors<br>&copy; 2024 <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
<br /><small>407798c</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2024-04-11 09:11              </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>