<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="A community driven standard library for (modern) Fortran">
    
    <meta name="author" content="fortran-lang/stdlib contributors" >
    <link rel="icon" href="../favicon.png">

    <title>stdlib_bitsets.fypp &ndash; Fortran-lang/stdlib</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">Fortran-lang/stdlib </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li><a href='../page/index.html'>Contributing and specs</a></li>
      
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
        
            </ul>
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>


          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>stdlib_bitsets.fypp
    <small>Source File</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title=" 3.8% of total for source files.">695 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/stdlib_bitsets.fypp"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
  
     <li class="active">stdlib_bitsets.fypp</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 







<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#mods-0">Modules</a></h3></div>
  <div id="mods-0" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/stdlib_bitsets.html">stdlib_bitsets</a>
      
    </div>
  </div>
</div>
















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../sourcefile/stdlib_bitsets.fypp.html#src">stdlib_bitsets.fypp</a>
  </div>
</div>



</div>

    </div>
    <div class="col-md-9" id='text'>
      
      <br>
    
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">This file depends on</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.1 (20200629.0846)
 -->
<!-- Title: sourcefile~~stdlib_bitsets.fypp~~EfferentGraph Pages: 1 -->
<svg id="sourcefilestdlib_bitsetsfyppEfferentGraph" width="227pt" height="32pt"
 viewBox="0.00 0.00 227.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="sourcefile~~stdlib_bitsets.fypp~~EfferentGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>sourcefile~~stdlib_bitsets.fypp~~EfferentGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 223,-28 223,4 -4,4"/>
<!-- sourcefile~stdlib_bitsets.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~EfferentGraph_node1" class="node">
<title>sourcefile~stdlib_bitsets.fypp</title>
<polygon fill="none" stroke="black" points="219,-24 122,-24 122,0 219,0 219,-24"/>
<text text-anchor="middle" x="170.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">stdlib_bitsets.fypp</text>
</g>
<!-- sourcefile~stdlib_kinds.f90 -->
<g id="sourcefile~~stdlib_bitsets.fypp~~EfferentGraph_node2" class="node">
<title>sourcefile~stdlib_kinds.f90</title>
<g id="a_sourcefile~~stdlib_bitsets.fypp~~EfferentGraph_node2"><a xlink:href=".././sourcefile/stdlib_kinds.f90.html" xlink:title="stdlib_kinds.f90">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="86,-24 0,-24 0,0 86,0 86,-24"/>
<text text-anchor="middle" x="43" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">stdlib_kinds.f90</text>
</a>
</g>
</g>
<!-- sourcefile~stdlib_bitsets.fypp&#45;&gt;sourcefile~stdlib_kinds.f90 -->
<g id="sourcefile~~stdlib_bitsets.fypp~~EfferentGraph_edge1" class="edge">
<title>sourcefile~stdlib_bitsets.fypp&#45;&gt;sourcefile~stdlib_kinds.f90</title>
<path fill="none" stroke="#ff0000" stroke-dasharray="5,2" d="M121.7,-12C113.42,-12 104.78,-12 96.39,-12"/>
<polygon fill="#ff0000" stroke="#ff0000" points="96.33,-8.5 86.33,-12 96.33,-15.5 96.33,-8.5"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.1 (20200629.0846)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="190pt" height="32pt"
 viewBox="0.00 0.00 190.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 186,-28 186,4 -4,4"/>
<!-- Source File -->
<g id="node1" class="node">
<title>Source File</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="67,-24 0,-24 0,0 67,0 67,-24"/>
<text text-anchor="middle" x="33.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Source File</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node2" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="182,-24 85,-24 85,0 182,0 182,-24"/>
<text text-anchor="middle" x="133.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a file to a file which it depends on. A file
    is dependent upon another if the latter must be compiled before the former
    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.
    </p>
    </div></div></div></div>
      </div>
    </div>
    
      
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Files dependent on this one</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.1 (20200629.0846)
 -->
<!-- Title: sourcefile~~stdlib_bitsets.fypp~~AfferentGraph Pages: 1 -->
<svg id="sourcefilestdlib_bitsetsfyppAfferentGraph" width="268pt" height="74pt"
 viewBox="0.00 0.00 268.00 74.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 70)">
<title>sourcefile~~stdlib_bitsets.fypp~~AfferentGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-70 264,-70 264,4 -4,4"/>
<!-- sourcefile~stdlib_bitsets.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_node1" class="node">
<title>sourcefile~stdlib_bitsets.fypp</title>
<polygon fill="none" stroke="black" points="97,-45 0,-45 0,-21 97,-21 97,-45"/>
<text text-anchor="middle" x="48.5" y="-30.6" font-family="Helvetica,sans-Serif" font-size="10.50">stdlib_bitsets.fypp</text>
</g>
<!-- sourcefile~stdlib_bitsets_large.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_node2" class="node">
<title>sourcefile~stdlib_bitsets_large.fypp</title>
<g id="a_sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_node2"><a xlink:href=".././sourcefile/stdlib_bitsets_large.fypp.html" xlink:title="stdlib_bitsets_large.fypp">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="260,-66 133,-66 133,-42 260,-42 260,-66"/>
<text text-anchor="middle" x="196.5" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">stdlib_bitsets_large.fypp</text>
</a>
</g>
</g>
<!-- sourcefile~stdlib_bitsets_large.fypp&#45;&gt;sourcefile~stdlib_bitsets.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_edge1" class="edge">
<title>sourcefile~stdlib_bitsets_large.fypp&#45;&gt;sourcefile~stdlib_bitsets.fypp</title>
<path fill="none" stroke="#ff0000" stroke-dasharray="5,2" d="M132.74,-44.97C124.27,-43.76 115.62,-42.51 107.26,-41.31"/>
<polygon fill="#ff0000" stroke="#ff0000" points="107.61,-37.82 97.22,-39.86 106.62,-44.75 107.61,-37.82"/>
</g>
<!-- sourcefile~stdlib_bitsets_64.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_node3" class="node">
<title>sourcefile~stdlib_bitsets_64.fypp</title>
<g id="a_sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_node3"><a xlink:href=".././sourcefile/stdlib_bitsets_64.fypp.html" xlink:title="stdlib_bitsets_64.fypp">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="254,-24 139,-24 139,0 254,0 254,-24"/>
<text text-anchor="middle" x="196.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">stdlib_bitsets_64.fypp</text>
</a>
</g>
</g>
<!-- sourcefile~stdlib_bitsets_64.fypp&#45;&gt;sourcefile~stdlib_bitsets.fypp -->
<g id="sourcefile~~stdlib_bitsets.fypp~~AfferentGraph_edge2" class="edge">
<title>sourcefile~stdlib_bitsets_64.fypp&#45;&gt;sourcefile~stdlib_bitsets.fypp</title>
<path fill="none" stroke="#ff0000" stroke-dasharray="5,2" d="M138.63,-20.18C128.43,-21.65 117.77,-23.18 107.53,-24.65"/>
<polygon fill="#ff0000" stroke="#ff0000" points="106.86,-21.21 97.46,-26.1 107.86,-28.14 106.86,-21.21"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.1 (20200629.0846)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="190pt" height="32pt"
 viewBox="0.00 0.00 190.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 186,-28 186,4 -4,4"/>
<!-- Source File -->
<g id="node1" class="node">
<title>Source File</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="67,-24 0,-24 0,0 67,0 67,-24"/>
<text text-anchor="middle" x="33.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Source File</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node2" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="182,-24 85,-24 85,0 182,0 182,-24"/>
<text text-anchor="middle" x="133.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a file to a file which it depends on. A file
    is dependent upon another if the latter must be compiled before the former
    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.
    </p>
    </div></div></div></div>
      </div>
    </div>
      
      <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 







<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#mods-1">Modules</a></h3></div>
  <div id="mods-1" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/stdlib_bitsets.html">stdlib_bitsets</a>
      
    </div>
  </div>
</div>
















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../sourcefile/stdlib_bitsets.fypp.html#src">stdlib_bitsets.fypp</a>
  </div>
</div>



    </section>
    <br class="visible-xs visible-sm hidden-md">

    <section>
      <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="hl"><pre><span></span><a name="ln-1"></a><span class="cp">#:include &quot;common.fypp&quot;</span>
<a name="ln-2"></a><span class="k">module </span><span class="n">stdlib_bitsets</span>
<a name="ln-3"></a><span class="c">!! Implements zero based bitsets of size up to `huge(0_int32)`.</span>
<a name="ln-4"></a><span class="c">!! The current code uses 64 bit integers to store the bits and uses all 64 bits.</span>
<a name="ln-5"></a><span class="c">!! The code assumes two&#39;s complement integers, and treats negative integers as</span>
<a name="ln-6"></a><span class="c">!! having the sign bit set.</span>
<a name="ln-7"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html))</span>
<a name="ln-8"></a>
<a name="ln-9"></a>    <span class="k">use</span> <span class="kd">::</span> <span class="n">stdlib_kinds</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span>  <span class="p">&amp;</span>
<a name="ln-10"></a>           <span class="n">bits_kind</span>  <span class="o">=&gt;</span> <span class="n">int32</span><span class="p">,</span> <span class="p">&amp;</span> <span class="c">! If changed change also max_digits, and</span>
<a name="ln-11"></a>           <span class="n">block_kind</span> <span class="o">=&gt;</span> <span class="n">int64</span><span class="p">,</span> <span class="p">&amp;</span> <span class="c">! overflow_bits</span>
<a name="ln-12"></a>           <span class="n">int8</span><span class="p">,</span>                <span class="p">&amp;</span>
<a name="ln-13"></a>           <span class="n">int16</span><span class="p">,</span>               <span class="p">&amp;</span>
<a name="ln-14"></a>           <span class="n">int32</span><span class="p">,</span>               <span class="p">&amp;</span>
<a name="ln-15"></a>           <span class="n">int64</span>
<a name="ln-16"></a>
<a name="ln-17"></a>    <span class="k">use</span><span class="p">,</span> <span class="k">intrinsic</span> <span class="kd">::</span>          <span class="p">&amp;</span>
<a name="ln-18"></a>        <span class="n">iso_fortran_env</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span> <span class="p">&amp;</span>
<a name="ln-19"></a>        <span class="n">error_unit</span>
<a name="ln-20"></a>
<a name="ln-21"></a>    <span class="k">implicit none</span>
<a name="ln-22"></a>
<a name="ln-23"></a><span class="k">    private</span>
<a name="ln-24"></a>
<a name="ln-25"></a><span class="k">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span>        <span class="p">&amp;</span>
<a name="ln-26"></a>        <span class="n">block_size</span>  <span class="o">=</span> <span class="nb">bit_size</span><span class="p">(</span><span class="mi">0_block_kind</span><span class="p">)</span>
<a name="ln-27"></a>
<a name="ln-28"></a>    <span class="k">public</span> <span class="kd">::</span> <span class="n">max_digits</span><span class="p">,</span> <span class="n">overflow_bits</span>
<a name="ln-29"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span> <span class="kd">::</span>                   <span class="p">&amp;</span>
<a name="ln-30"></a>        <span class="n">max_digits</span> <span class="o">=</span> <span class="mi">10</span> <span class="c">! bits_kind == int32</span>
<a name="ln-31"></a><span class="c">!        max_digits = 19 ! bits_kind == int64</span>
<a name="ln-32"></a>
<a name="ln-33"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span>     <span class="p">&amp;</span>
<a name="ln-34"></a>        <span class="n">overflow_bits</span> <span class="o">=</span> <span class="mi">2_bits_kind</span><span class="o">**</span><span class="mi">30</span><span class="o">/</span><span class="mi">5</span> <span class="c">! bits_kind == int32</span>
<a name="ln-35"></a><span class="c">!        overflow_bits = 2_bits_kind**62/5 ! bits_kind == int64</span>
<a name="ln-36"></a>
<a name="ln-37"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">block_kind</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">all_zeros</span>  <span class="o">=</span> <span class="mi">0_block_kind</span>
<a name="ln-38"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">block_kind</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">all_ones</span>   <span class="o">=</span> <span class="nb">not</span><span class="p">(</span><span class="n">all_zeros</span><span class="p">)</span>
<a name="ln-39"></a>
<a name="ln-40"></a>    <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;STDLIB_BITSETS&quot;</span>
<a name="ln-41"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span> <span class="kd">::</span>    <span class="p">&amp;</span>
<a name="ln-42"></a>        <span class="n">ia0</span>   <span class="o">=</span> <span class="nb">iachar</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">&amp;</span>
<a name="ln-43"></a>        <span class="n">ia9</span>   <span class="o">=</span> <span class="nb">iachar</span><span class="p">(</span><span class="s1">&#39;9&#39;</span><span class="p">)</span>
<a name="ln-44"></a>
<a name="ln-45"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
<a name="ln-46"></a><span class="c">!! Error flag indicating no errors</span>
<a name="ln-47"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">alloc_fault</span> <span class="o">=</span> <span class="mi">1</span>
<a name="ln-48"></a><span class="c">!! Error flag indicating a memory allocation failure</span>
<a name="ln-49"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">array_size_invalid_error</span> <span class="o">=</span> <span class="mi">2</span>
<a name="ln-50"></a><span class="c">!! Error flag indicating an invalid bits value</span>
<a name="ln-51"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">char_string_invalid_error</span> <span class="o">=</span> <span class="mi">3</span>
<a name="ln-52"></a><span class="c">!! Error flag indicating an invalid character string</span>
<a name="ln-53"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">char_string_too_large_error</span> <span class="o">=</span> <span class="mi">4</span>
<a name="ln-54"></a><span class="c">!! Error flag indicating a too large character string</span>
<a name="ln-55"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">char_string_too_small_error</span> <span class="o">=</span> <span class="mi">5</span>
<a name="ln-56"></a><span class="c">!! Error flag indicating a too small character string</span>
<a name="ln-57"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">eof_failure</span> <span class="o">=</span> <span class="mi">6</span>
<a name="ln-58"></a><span class="c">!! Error flag indicating unexpected End-of-File on a READ</span>
<a name="ln-59"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">index_invalid_error</span> <span class="o">=</span> <span class="mi">7</span>
<a name="ln-60"></a><span class="c">!! Error flag indicating an invalid index</span>
<a name="ln-61"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">integer_overflow_error</span> <span class="o">=</span> <span class="mi">8</span>
<a name="ln-62"></a><span class="c">!! Error flag indicating integer overflow</span>
<a name="ln-63"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">read_failure</span> <span class="o">=</span> <span class="mi">9</span>
<a name="ln-64"></a><span class="c">!! Error flag indicating failure of a READ statement</span>
<a name="ln-65"></a>    <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span><span class="p">,</span> <span class="k">public</span> <span class="kd">::</span> <span class="n">write_failure</span> <span class="o">=</span> <span class="mi">10</span>
<a name="ln-66"></a><span class="c">!! Error flag indicating a failure on a WRITE statement</span>
<a name="ln-67"></a>
<a name="ln-68"></a>    <span class="k">public</span> <span class="kd">::</span> <span class="n">bits_kind</span>
<a name="ln-69"></a><span class="c">! Public constant</span>
<a name="ln-70"></a>
<a name="ln-71"></a>    <span class="k">public</span> <span class="kd">::</span>         <span class="p">&amp;</span>
<a name="ln-72"></a>        <span class="n">bitset_type</span><span class="p">,</span>  <span class="p">&amp;</span>
<a name="ln-73"></a>        <span class="n">bitset_large</span><span class="p">,</span> <span class="p">&amp;</span>
<a name="ln-74"></a>        <span class="n">bitset_64</span>
<a name="ln-75"></a>
<a name="ln-76"></a><span class="c">! Public types</span>
<a name="ln-77"></a>
<a name="ln-78"></a>    <span class="k">public</span> <span class="kd">::</span>          <span class="p">&amp;</span>
<a name="ln-79"></a>        <span class="n">assignment</span><span class="p">(</span><span class="o">=</span><span class="p">),</span> <span class="p">&amp;</span>
<a name="ln-80"></a>        <span class="nb">and</span><span class="p">,</span>           <span class="p">&amp;</span>
<a name="ln-81"></a>        <span class="n">and_not</span><span class="p">,</span>       <span class="p">&amp;</span>
<a name="ln-82"></a>        <span class="n">bits</span><span class="p">,</span>          <span class="p">&amp;</span>
<a name="ln-83"></a>        <span class="n">extract</span><span class="p">,</span>       <span class="p">&amp;</span>
<a name="ln-84"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">==</span><span class="p">),</span>  <span class="p">&amp;</span>
<a name="ln-85"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">/=</span><span class="p">),</span>  <span class="p">&amp;</span>
<a name="ln-86"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">&gt;</span><span class="p">),</span>   <span class="p">&amp;</span>
<a name="ln-87"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">),</span>  <span class="p">&amp;</span>
<a name="ln-88"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">&lt;</span><span class="p">),</span>   <span class="p">&amp;</span>
<a name="ln-89"></a>        <span class="n">operator</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">),</span>  <span class="p">&amp;</span>
<a name="ln-90"></a>        <span class="nb">or</span><span class="p">,</span>            <span class="p">&amp;</span>
<a name="ln-91"></a>        <span class="nb">xor</span>
<a name="ln-92"></a><span class="c">!! Public procedures</span>
<a name="ln-93"></a>
<a name="ln-94"></a>    <span class="k">public</span> <span class="kd">::</span> <span class="n">error_handler</span>
<a name="ln-95"></a>
<a name="ln-96"></a>    <span class="k">type</span><span class="p">,</span> <span class="k">abstract</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-97"></a><span class="c">!! version: experimental</span>
<a name="ln-98"></a><span class="c">!!</span>
<a name="ln-99"></a><span class="c">!! Parent type for bitset_64 and bitset_large ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types))</span>
<a name="ln-100"></a>
<a name="ln-101"></a>        <span class="k">private</span>
<a name="ln-102"></a><span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">)</span> <span class="kd">::</span> <span class="n">num_bits</span>
<a name="ln-103"></a>
<a name="ln-104"></a>    <span class="k">contains</span>
<a name="ln-105"></a>
<a name="ln-106"></a><span class="k">        procedure</span><span class="p">(</span><span class="n">all_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>         <span class="kd">::</span> <span class="k">all</span>
<a name="ln-107"></a><span class="k">        procedure</span><span class="p">(</span><span class="n">any_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>         <span class="kd">::</span> <span class="nb">any</span>
<a name="ln-108"></a><span class="nb">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">bit_count_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">bit_count</span>
<a name="ln-109"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>                                 <span class="kd">::</span> <span class="n">bits</span>
<a name="ln-110"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">clear_bit_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">clear_bit</span>
<a name="ln-111"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">clear_range_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="n">clear_range</span>
<a name="ln-112"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">clear</span> <span class="o">=&gt;</span> <span class="n">clear_bit</span><span class="p">,</span> <span class="n">clear_range</span>
<a name="ln-113"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">flip_bit_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">flip_bit</span>
<a name="ln-114"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">flip_range_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">flip_range</span>
<a name="ln-115"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">flip</span> <span class="o">=&gt;</span> <span class="n">flip_bit</span><span class="p">,</span> <span class="n">flip_range</span>
<a name="ln-116"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">from_string_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="n">from_string</span>
<a name="ln-117"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">init_zero_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">init_zero</span>
<a name="ln-118"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">init</span> <span class="o">=&gt;</span> <span class="n">init_zero</span>
<a name="ln-119"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">input_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>       <span class="kd">::</span> <span class="n">input</span>
<a name="ln-120"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">none_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>        <span class="kd">::</span> <span class="k">none</span>
<a name="ln-121"></a><span class="k">        procedure</span><span class="p">(</span><span class="n">not_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>         <span class="kd">::</span> <span class="nb">not</span>
<a name="ln-122"></a><span class="nb">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">output_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>      <span class="kd">::</span> <span class="n">output</span>
<a name="ln-123"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">read_bitset_string_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-124"></a>            <span class="n">read_bitset_string</span>
<a name="ln-125"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">read_bitset_unit_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-126"></a>            <span class="n">read_bitset_unit</span>
<a name="ln-127"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">read_bitset</span> <span class="o">=&gt;</span> <span class="n">read_bitset_string</span><span class="p">,</span> <span class="n">read_bitset_unit</span>
<a name="ln-128"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">set_bit_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">set_bit</span>
<a name="ln-129"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">set_range_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">set_range</span>
<a name="ln-130"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">set</span> <span class="o">=&gt;</span> <span class="n">set_bit</span><span class="p">,</span> <span class="n">set_range</span>
<a name="ln-131"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">test_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>        <span class="kd">::</span> <span class="n">test</span>
<a name="ln-132"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">to_string_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">to_string</span>
<a name="ln-133"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">value_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>       <span class="kd">::</span> <span class="k">value</span>
<a name="ln-134"></a><span class="k">        procedure</span><span class="p">(</span><span class="n">write_bitset_string_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-135"></a>            <span class="n">write_bitset_string</span>
<a name="ln-136"></a>        <span class="k">procedure</span><span class="p">(</span><span class="n">write_bitset_unit_abstract</span><span class="p">),</span> <span class="k">deferred</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-137"></a>            <span class="n">write_bitset_unit</span>
<a name="ln-138"></a>        <span class="k">generic</span> <span class="kd">::</span> <span class="n">write_bitset</span> <span class="o">=&gt;</span> <span class="n">write_bitset_string</span><span class="p">,</span> <span class="n">write_bitset_unit</span>
<a name="ln-139"></a>
<a name="ln-140"></a>    <span class="k">end type </span><span class="n">bitset_type</span>
<a name="ln-141"></a>
<a name="ln-142"></a>
<a name="ln-143"></a>    <span class="k">abstract interface</span>
<a name="ln-144"></a>
<a name="ln-145"></a><span class="k">        elemental function </span><span class="n">all_abstract</span><span class="p">(</span> <span class="n">self</span> <span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">all</span><span class="p">)</span>
<a name="ln-146"></a><span class="c">!! Version: experimental</span>
<a name="ln-147"></a><span class="c">!!</span>
<a name="ln-148"></a><span class="c">!! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise.</span>
<a name="ln-149"></a><span class="c">!!</span>
<a name="ln-150"></a><span class="c">!!#### Example</span>
<a name="ln-151"></a><span class="c">!!</span>
<a name="ln-152"></a><span class="c">!!```fortran</span>
<a name="ln-153"></a><span class="c">!!    program demo_all</span>
<a name="ln-154"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-155"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-156"></a><span class="c">!!            bits_all = &#39;111111111111111111111111111111111&#39;</span>
<a name="ln-157"></a><span class="c">!!        type(bitset_64) :: set0</span>
<a name="ln-158"></a><span class="c">!!        call set0 % from_string( bits_all )</span>
<a name="ln-159"></a><span class="c">!!        if ( bits(set0) /= 33 ) then</span>
<a name="ln-160"></a><span class="c">!!            error stop &quot;FROM_STRING failed to interpret &quot; // &amp;</span>
<a name="ln-161"></a><span class="c">!!                &#39;BITS_ALL&#39;s size properly.&quot;</span>
<a name="ln-162"></a><span class="c">!!        else if ( .not. set0 % all() ) then</span>
<a name="ln-163"></a><span class="c">!!            error stop &quot;FROM_STRING failed to interpret&quot; // &amp;</span>
<a name="ln-164"></a><span class="c">!!                &quot;BITS_ALL&#39;s value properly.&quot;</span>
<a name="ln-165"></a><span class="c">!!        else</span>
<a name="ln-166"></a><span class="c">!!            write(*,*) &quot;FROM_STRING transferred BITS_ALL properly&quot; // &amp;</span>
<a name="ln-167"></a><span class="c">!!                &quot; into set0.&quot;</span>
<a name="ln-168"></a><span class="c">!!        end if</span>
<a name="ln-169"></a><span class="c">!!    end program demo_all</span>
<a name="ln-170"></a><span class="c">!!```</span>
<a name="ln-171"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-172"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="k">all</span>
<a name="ln-173"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-174"></a>        <span class="k">end function </span><span class="n">all_abstract</span>
<a name="ln-175"></a>
<a name="ln-176"></a>        <span class="k">elemental function </span><span class="n">any_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="nb">any</span><span class="p">)</span>
<a name="ln-177"></a><span class="c">!! Version: experimental</span>
<a name="ln-178"></a><span class="c">!!</span>
<a name="ln-179"></a><span class="c">!! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise.</span>
<a name="ln-180"></a><span class="c">!!</span>
<a name="ln-181"></a><span class="c">!!#### Example</span>
<a name="ln-182"></a><span class="c">!!</span>
<a name="ln-183"></a><span class="c">!!```fortran</span>
<a name="ln-184"></a><span class="c">!!    program demo_any</span>
<a name="ln-185"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-186"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-187"></a><span class="c">!!            bits_0 = &#39;0000000000000000000&#39;</span>
<a name="ln-188"></a><span class="c">!!        type(bitset_64) :: set0</span>
<a name="ln-189"></a><span class="c">!!        call set0 % from_string( bits_0 )</span>
<a name="ln-190"></a><span class="c">!!        if ( .not. set0 % any() ) then</span>
<a name="ln-191"></a><span class="c">!!            write(*,*) &quot;FROM_STRING interpreted &quot; // &amp;</span>
<a name="ln-192"></a><span class="c">!!                &quot;BITS_0&#39;s value properly.&quot;</span>
<a name="ln-193"></a><span class="c">!!        end if</span>
<a name="ln-194"></a><span class="c">!!        call set0 % set(5)</span>
<a name="ln-195"></a><span class="c">!!        if ( set0 % any() ) then</span>
<a name="ln-196"></a><span class="c">!!            write(*,*) &quot;ANY interpreted SET0&#39;s value properly.&quot;</span>
<a name="ln-197"></a><span class="c">!!        end if</span>
<a name="ln-198"></a><span class="c">!!    end program demo_any</span>
<a name="ln-199"></a><span class="c">!!```</span>
<a name="ln-200"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-201"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="nb">any</span>
<a name="ln-202"></a><span class="nb">            </span><span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-203"></a>        <span class="k">end function </span><span class="n">any_abstract</span>
<a name="ln-204"></a>
<a name="ln-205"></a>        <span class="k">elemental function </span><span class="n">bit_count_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">bit_count</span><span class="p">)</span>
<a name="ln-206"></a><span class="c">!! Version: experimental</span>
<a name="ln-207"></a><span class="c">!!</span>
<a name="ln-208"></a><span class="c">!! Returns the number of non-zero bits in `self`.</span>
<a name="ln-209"></a><span class="c">!!</span>
<a name="ln-210"></a><span class="c">!!#### Example</span>
<a name="ln-211"></a><span class="c">!!</span>
<a name="ln-212"></a><span class="c">!!```fortran</span>
<a name="ln-213"></a><span class="c">!!    program demo_bit_count</span>
<a name="ln-214"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-215"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-216"></a><span class="c">!!            bits_0 = &#39;0000000000000000000&#39;</span>
<a name="ln-217"></a><span class="c">!!        type(bitset_64) :: set0</span>
<a name="ln-218"></a><span class="c">!!        call set0 % from_string( bits_0 )</span>
<a name="ln-219"></a><span class="c">!!        if ( set0 % bit_count() == 0 ) then</span>
<a name="ln-220"></a><span class="c">!!            write(*,*) &quot;FROM_STRING interpreted &quot; // &amp;</span>
<a name="ln-221"></a><span class="c">!!                &quot;BITS_0&#39;s value properly.&quot;</span>
<a name="ln-222"></a><span class="c">!!        end if</span>
<a name="ln-223"></a><span class="c">!!        call set0 % set(5)</span>
<a name="ln-224"></a><span class="c">!!        if ( set0 % bit_count() == 1 ) then</span>
<a name="ln-225"></a><span class="c">!!            write(*,*) &quot;BIT_COUNT interpreted SET0&#39;s value properly.&quot;</span>
<a name="ln-226"></a><span class="c">!!        end if</span>
<a name="ln-227"></a><span class="c">!!    end program demo_bit_count</span>
<a name="ln-228"></a><span class="c">!!```</span>
<a name="ln-229"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-230"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">)</span>             <span class="kd">::</span>  <span class="n">bit_count</span>
<a name="ln-231"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-232"></a>        <span class="k">end function </span><span class="n">bit_count_abstract</span>
<a name="ln-233"></a>
<a name="ln-234"></a>        <span class="k">elemental subroutine </span><span class="n">clear_bit_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-235"></a><span class="c">!! Version: experimental</span>
<a name="ln-236"></a><span class="c">!!</span>
<a name="ln-237"></a><span class="c">!! Sets to zero the `pos` position in `self`. If `pos` is less than zero or</span>
<a name="ln-238"></a><span class="c">!! greater than `bits(self)-1` it is ignored.</span>
<a name="ln-239"></a><span class="c">!!</span>
<a name="ln-240"></a><span class="c">!!#### Example</span>
<a name="ln-241"></a><span class="c">!!</span>
<a name="ln-242"></a><span class="c">!!```fortran</span>
<a name="ln-243"></a><span class="c">!!    program demo_clear</span>
<a name="ln-244"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-245"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-246"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-247"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-248"></a><span class="c">!!        if ( set0 % all() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-249"></a><span class="c">!!        call set0 % clear(165)</span>
<a name="ln-250"></a><span class="c">!!        if ( .not. set0 % test(165) ) write(*,*) &#39;Bit 165 is cleared.&#39;</span>
<a name="ln-251"></a><span class="c">!!        call set0 % clear(0,164)</span>
<a name="ln-252"></a><span class="c">!!        if ( set0 % none() ) write(*,*) &#39;All bits are cleared.&#39;</span>
<a name="ln-253"></a><span class="c">!!    end program demo_clear</span>
<a name="ln-254"></a><span class="c">!!```</span>
<a name="ln-255"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-256"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-257"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-258"></a>        <span class="k">end subroutine </span><span class="n">clear_bit_abstract</span>
<a name="ln-259"></a>
<a name="ln-260"></a>        <span class="k">pure subroutine </span><span class="n">clear_range_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-261"></a><span class="c">!! Version: experimental</span>
<a name="ln-262"></a><span class="c">!!</span>
<a name="ln-263"></a><span class="c">!! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `set`.</span>
<a name="ln-264"></a><span class="c">!! If `stop_pos &lt; start_pos` then no bits are modified. Positions outside</span>
<a name="ln-265"></a><span class="c">!! the range 0 to `bits(self)-1` are ignored.</span>
<a name="ln-266"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-267"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-268"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-269"></a>        <span class="k">end subroutine </span><span class="n">clear_range_abstract</span>
<a name="ln-270"></a>
<a name="ln-271"></a>        <span class="k">elemental subroutine </span><span class="n">flip_bit_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-272"></a><span class="c">!! Version: experimental</span>
<a name="ln-273"></a><span class="c">!!</span>
<a name="ln-274"></a><span class="c">!! Flips the value at the `pos` position in `self`, provided the position is</span>
<a name="ln-275"></a><span class="c">!! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is</span>
<a name="ln-276"></a><span class="c">!! changed.</span>
<a name="ln-277"></a><span class="c">!!</span>
<a name="ln-278"></a><span class="c">!!#### Example</span>
<a name="ln-279"></a><span class="c">!!</span>
<a name="ln-280"></a><span class="c">!!```fortran</span>
<a name="ln-281"></a><span class="c">!!    program demo_flip</span>
<a name="ln-282"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-283"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-284"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-285"></a><span class="c">!!        if ( set0 % none() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-286"></a><span class="c">!!        call set0 % flip(165)</span>
<a name="ln-287"></a><span class="c">!!        if ( set0 % test(165) ) write(*,*) &#39;Bit 165 is flipped.&#39;</span>
<a name="ln-288"></a><span class="c">!!        call set0 % flip(0,164)</span>
<a name="ln-289"></a><span class="c">!!        if ( set0 % all() ) write(*,*) &#39;All bits are flipped.&#39;</span>
<a name="ln-290"></a><span class="c">!!    end program demo_flip</span>
<a name="ln-291"></a><span class="c">!!```</span>
<a name="ln-292"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-293"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-294"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-295"></a>        <span class="k">end subroutine </span><span class="n">flip_bit_abstract</span>
<a name="ln-296"></a>
<a name="ln-297"></a>        <span class="k">pure subroutine </span><span class="n">flip_range_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-298"></a><span class="c">!! Version: experimental</span>
<a name="ln-299"></a><span class="c">!!</span>
<a name="ln-300"></a><span class="c">!! Flips all valid bits from the `start_pos` to the `stop_pos` positions in</span>
<a name="ln-301"></a><span class="c">!! `self`. If `stop_pos &lt; start_pos` no bits are flipped. Positions less than</span>
<a name="ln-302"></a><span class="c">!! 0 or greater than `bits(self)-1` are ignored.</span>
<a name="ln-303"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-304"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-305"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-306"></a>        <span class="k">end subroutine </span><span class="n">flip_range_abstract</span>
<a name="ln-307"></a>
<a name="ln-308"></a>        <span class="k">subroutine </span><span class="n">from_string_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-309"></a><span class="c">!! Version: experimental</span>
<a name="ln-310"></a><span class="c">!!</span>
<a name="ln-311"></a><span class="c">!! Initializes the bitset `self` treating `string` as a binary literal</span>
<a name="ln-312"></a><span class="c">!! `status` may have the values:</span>
<a name="ln-313"></a><span class="c">!! * `success` - if no problems were found,</span>
<a name="ln-314"></a><span class="c">!! * `alloc_fault` - if allocation of the bitset failed</span>
<a name="ln-315"></a><span class="c">!! * `char_string_too_large_error` - if `string` was too large, or</span>
<a name="ln-316"></a><span class="c">!! * `char_string_invalid_error` - if string had an invalid character.</span>
<a name="ln-317"></a><span class="c">!!</span>
<a name="ln-318"></a><span class="c">!!#### Example</span>
<a name="ln-319"></a><span class="c">!!</span>
<a name="ln-320"></a><span class="c">!!```fortran</span>
<a name="ln-321"></a><span class="c">!!    program demo_from_string</span>
<a name="ln-322"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-323"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-324"></a><span class="c">!!            bits_all = &#39;111111111111111111111111111111111&#39;</span>
<a name="ln-325"></a><span class="c">!!        type(bitset_64) :: set0</span>
<a name="ln-326"></a><span class="c">!!        call set0 % from_string( bits_all )</span>
<a name="ln-327"></a><span class="c">!!        if ( bits(set0) /= 33 ) then</span>
<a name="ln-328"></a><span class="c">!!            error stop &quot;FROM_STRING failed to interpret &quot; // &amp;</span>
<a name="ln-329"></a><span class="c">!!                &#39;BITS_ALL&#39;s size properly.&quot;</span>
<a name="ln-330"></a><span class="c">!!        else if ( .not. set0 % all() ) then</span>
<a name="ln-331"></a><span class="c">!!            error stop &quot;FROM_STRING failed to interpret&quot; // &amp;</span>
<a name="ln-332"></a><span class="c">!!                &quot;BITS_ALL&#39;s value properly.&quot;</span>
<a name="ln-333"></a><span class="c">!!        else</span>
<a name="ln-334"></a><span class="c">!!            write(*,*) &quot;FROM_STRING transferred BITS_ALL properly&quot; // &amp;</span>
<a name="ln-335"></a><span class="c">!!                &quot; into set0.&quot;</span>
<a name="ln-336"></a><span class="c">!!        end if</span>
<a name="ln-337"></a><span class="c">!!    end program demo_from_string</span>
<a name="ln-338"></a><span class="c">!!```</span>
<a name="ln-339"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-340"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-341"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>        <span class="kd">::</span> <span class="n">string</span>
<a name="ln-342"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-343"></a>        <span class="k">end subroutine </span><span class="n">from_string_abstract</span>
<a name="ln-344"></a>
<a name="ln-345"></a>        <span class="k">subroutine </span><span class="n">init_zero_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-346"></a><span class="c">!! Creates the bitset, `self`, of size `bits`, with all bits initialized to</span>
<a name="ln-347"></a><span class="c">!! zero. `bits` must be non-negative.  If an error occurs and `status` is</span>
<a name="ln-348"></a><span class="c">!! absent then processing stops with an informative stop code. `status`</span>
<a name="ln-349"></a><span class="c">!! will have one of the values;</span>
<a name="ln-350"></a><span class="c">!! * `success` -  if no problems were found,</span>
<a name="ln-351"></a><span class="c">!! * `alloc_fault` - if memory allocation failed</span>
<a name="ln-352"></a><span class="c">!! * `array_size_invalid_error` - if `bits` is either negative or larger</span>
<a name="ln-353"></a><span class="c">!!   than 64 with `self` of class `bitset_64`, or</span>
<a name="ln-354"></a><span class="c">!!</span>
<a name="ln-355"></a><span class="c">!!#### Example</span>
<a name="ln-356"></a><span class="c">!!</span>
<a name="ln-357"></a><span class="c">!!```fortran</span>
<a name="ln-358"></a><span class="c">!!    program demo_init</span>
<a name="ln-359"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-360"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-361"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-362"></a><span class="c">!!        if ( set0 % bits() == 166 ) &amp;</span>
<a name="ln-363"></a><span class="c">!!            write(*,*) `SET0 has the proper size.&#39;</span>
<a name="ln-364"></a><span class="c">!!        if ( set0 % none() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-365"></a><span class="c">!!    end program demo_init</span>
<a name="ln-366"></a><span class="c">!!```</span>
<a name="ln-367"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-368"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-369"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">bits</span>
<a name="ln-370"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-371"></a>        <span class="k">end subroutine </span><span class="n">init_zero_abstract</span>
<a name="ln-372"></a>
<a name="ln-373"></a>        <span class="k">subroutine </span><span class="n">input_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-374"></a><span class="c">!! Version: experimental</span>
<a name="ln-375"></a><span class="c">!!</span>
<a name="ln-376"></a><span class="c">!! Reads the components of the bitset, `self`, from the unformatted I/O</span>
<a name="ln-377"></a><span class="c">!! unit, `unit`, assuming that the components were written using `output`.</span>
<a name="ln-378"></a><span class="c">!! If an error occurs and `status` is absent then processing stops with</span>
<a name="ln-379"></a><span class="c">!! an informative stop code. `status` has one of the values:</span>
<a name="ln-380"></a><span class="c">!! * `success` - if no problem was found</span>
<a name="ln-381"></a><span class="c">!! * `alloc_fault` - if it failed allocating memory for `self`, or</span>
<a name="ln-382"></a><span class="c">!! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative</span>
<a name="ln-383"></a><span class="c">!!   or greater than 64 for a `bitset_64` input.</span>
<a name="ln-384"></a><span class="c">!! * `read_failure` - if it failed during the reads from `unit`</span>
<a name="ln-385"></a><span class="c">!!</span>
<a name="ln-386"></a><span class="c">!!#### Example</span>
<a name="ln-387"></a><span class="c">!!</span>
<a name="ln-388"></a><span class="c">!!```fortran</span>
<a name="ln-389"></a><span class="c">!!    program demo_input</span>
<a name="ln-390"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-391"></a><span class="c">!!            bits_0   = &#39;000000000000000000000000000000000&#39;, &amp;</span>
<a name="ln-392"></a><span class="c">!!            bits_1   = &#39;000000000000000000000000000000001&#39;, &amp;</span>
<a name="ln-393"></a><span class="c">!!            bits_33  = &#39;100000000000000000000000000000000&#39;</span>
<a name="ln-394"></a><span class="c">!!        integer :: unit</span>
<a name="ln-395"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2, set3, set4, set5</span>
<a name="ln-396"></a><span class="c">!!        call set0 % from_string( bits_0 )</span>
<a name="ln-397"></a><span class="c">!!        call set1 % from_string( bits_1 )</span>
<a name="ln-398"></a><span class="c">!!        call set2 % from_string( bits_33 )</span>
<a name="ln-399"></a><span class="c">!!        open( newunit=unit, file=&#39;test.bin&#39;, status=&#39;replace&#39;, &amp;</span>
<a name="ln-400"></a><span class="c">!!            form=&#39;unformatted&#39;, action=&#39;write&#39; )</span>
<a name="ln-401"></a><span class="c">!!        call set2 % output(unit)</span>
<a name="ln-402"></a><span class="c">!!        call set1 % output(unit)</span>
<a name="ln-403"></a><span class="c">!!        call set0 % output(unit)</span>
<a name="ln-404"></a><span class="c">!!        close( unit )</span>
<a name="ln-405"></a><span class="c">!!        open( newunit=unit, file=&#39;test.bin&#39;, status=&#39;old&#39;, &amp;</span>
<a name="ln-406"></a><span class="c">!!            form=&#39;unformatted&#39;, action=&#39;read&#39; )</span>
<a name="ln-407"></a><span class="c">!!        call set5 % input(unit)</span>
<a name="ln-408"></a><span class="c">!!        call set4 % input(unit)</span>
<a name="ln-409"></a><span class="c">!!        call set3 % input(unit)</span>
<a name="ln-410"></a><span class="c">!!        close( unit )</span>
<a name="ln-411"></a><span class="c">!!        if ( set3 /= set0 .or. set4 /= set1 .or. set5 /= set2 ) then</span>
<a name="ln-412"></a><span class="c">!!            error stop &#39;Transfer to and from units using &#39; // &amp;</span>
<a name="ln-413"></a><span class="c">!!                &#39; output and input failed.&#39;</span>
<a name="ln-414"></a><span class="c">!!        else</span>
<a name="ln-415"></a><span class="c">!!            write(*,*) &#39;Transfer to and from units using &#39; // &amp;</span>
<a name="ln-416"></a><span class="c">!!                &#39;output and input succeeded.&#39;</span>
<a name="ln-417"></a><span class="c">!!        end if</span>
<a name="ln-418"></a><span class="c">!!    end program demo_input</span>
<a name="ln-419"></a><span class="c">!!```</span>
<a name="ln-420"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-421"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-422"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>             <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-423"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-424"></a>        <span class="k">end subroutine </span><span class="n">input_abstract</span>
<a name="ln-425"></a>
<a name="ln-426"></a>        <span class="k">elemental function </span><span class="n">none_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">none</span><span class="p">)</span>
<a name="ln-427"></a><span class="c">!! Version: experimental</span>
<a name="ln-428"></a><span class="c">!!</span>
<a name="ln-429"></a><span class="c">!! Returns `.true.` if none of the bits in `self` have the value 1.</span>
<a name="ln-430"></a><span class="c">!!</span>
<a name="ln-431"></a><span class="c">!!#### Example</span>
<a name="ln-432"></a><span class="c">!!</span>
<a name="ln-433"></a><span class="c">!!```fortran</span>
<a name="ln-434"></a><span class="c">!!    program demo_none</span>
<a name="ln-435"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-436"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-437"></a><span class="c">!!            bits_0 = &#39;0000000000000000000&#39;</span>
<a name="ln-438"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-439"></a><span class="c">!!        call set0 % from_string( bits_0 )</span>
<a name="ln-440"></a><span class="c">!!        if ( set0 % none() ) then</span>
<a name="ln-441"></a><span class="c">!!            write(*,*) &quot;FROM_STRING interpreted &quot; // &amp;</span>
<a name="ln-442"></a><span class="c">!!                &quot;BITS_0&#39;s value properly.&quot;</span>
<a name="ln-443"></a><span class="c">!!        end if</span>
<a name="ln-444"></a><span class="c">!!        call set0 % set(5)</span>
<a name="ln-445"></a><span class="c">!!        if ( .not. set0 % none() ) then</span>
<a name="ln-446"></a><span class="c">!!            write(*,*) &quot;NONE interpreted SET0&#39;s value properly.&quot;</span>
<a name="ln-447"></a><span class="c">!!        end if</span>
<a name="ln-448"></a><span class="c">!!    end program demo_none</span>
<a name="ln-449"></a><span class="c">!!```</span>
<a name="ln-450"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-451"></a>            <span class="kt">logical</span> <span class="kd">::</span>  <span class="k">none</span>
<a name="ln-452"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-453"></a>        <span class="k">end function </span><span class="n">none_abstract</span>
<a name="ln-454"></a>
<a name="ln-455"></a>        <span class="k">elemental subroutine </span><span class="n">not_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<a name="ln-456"></a><span class="c">!! Version: experimental</span>
<a name="ln-457"></a><span class="c">!!</span>
<a name="ln-458"></a><span class="c">!! Sets the bits in `self` to their logical complement</span>
<a name="ln-459"></a><span class="c">!!</span>
<a name="ln-460"></a><span class="c">!!#### Example</span>
<a name="ln-461"></a><span class="c">!!</span>
<a name="ln-462"></a><span class="c">!!```fortran</span>
<a name="ln-463"></a><span class="c">!!    program demo_not</span>
<a name="ln-464"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-465"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-466"></a><span class="c">!!        call set0 % init( 155 )</span>
<a name="ln-467"></a><span class="c">!!        if ( set0 % none() ) then</span>
<a name="ln-468"></a><span class="c">!!            write(*,*) &quot;FROM_STRING interpreted &quot; // &amp;</span>
<a name="ln-469"></a><span class="c">!!                &quot;BITS_0&#39;s value properly.&quot;</span>
<a name="ln-470"></a><span class="c">!!        end if</span>
<a name="ln-471"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-472"></a><span class="c">!!        if ( set0 % all() ) then</span>
<a name="ln-473"></a><span class="c">!!            write(*,*) &quot;ALL interpreted SET0&#39;s value properly.&quot;</span>
<a name="ln-474"></a><span class="c">!!        end if</span>
<a name="ln-475"></a><span class="c">!!    end program demo_not</span>
<a name="ln-476"></a><span class="c">!!```</span>
<a name="ln-477"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-478"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-479"></a>        <span class="k">end subroutine </span><span class="n">not_abstract</span>
<a name="ln-480"></a>
<a name="ln-481"></a>        <span class="k">subroutine </span><span class="n">output_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-482"></a><span class="c">!! Version: experimental</span>
<a name="ln-483"></a><span class="c">!!</span>
<a name="ln-484"></a><span class="c">!! Writes the components of the bitset, `self`, to the unformatted I/O</span>
<a name="ln-485"></a><span class="c">!! unit, `unit`, in a unformatted sequence compatible with `input`. If</span>
<a name="ln-486"></a><span class="c">!! `status` is absent an error results in an error stop with an</span>
<a name="ln-487"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-488"></a><span class="c">!! value of `success`, or the value `write_failure` if the write failed.</span>
<a name="ln-489"></a><span class="c">!!</span>
<a name="ln-490"></a><span class="c">!!#### Example</span>
<a name="ln-491"></a><span class="c">!!</span>
<a name="ln-492"></a><span class="c">!!```fortran</span>
<a name="ln-493"></a><span class="c">!!    program demo_output</span>
<a name="ln-494"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-495"></a><span class="c">!!            bits_0   = &#39;000000000000000000000000000000000&#39;, &amp;</span>
<a name="ln-496"></a><span class="c">!!            bits_1   = &#39;000000000000000000000000000000001&#39;, &amp;</span>
<a name="ln-497"></a><span class="c">!!            bits_33  = &#39;100000000000000000000000000000000&#39;</span>
<a name="ln-498"></a><span class="c">!!        integer :: unit</span>
<a name="ln-499"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2, set3, set4, set5</span>
<a name="ln-500"></a><span class="c">!!        call set0 % from_string( bits_0 )</span>
<a name="ln-501"></a><span class="c">!!        call set1 % from_string( bits_1 )</span>
<a name="ln-502"></a><span class="c">!!        call set2 % from_string( bits_33 )</span>
<a name="ln-503"></a><span class="c">!!        open( newunit=unit, file=&#39;test.bin&#39;, status=&#39;replace&#39;, &amp;</span>
<a name="ln-504"></a><span class="c">!!            form=&#39;unformatted&#39;, action=&#39;write&#39; )</span>
<a name="ln-505"></a><span class="c">!!        call set2 % output(unit)</span>
<a name="ln-506"></a><span class="c">!!        call set1 % output(unit)</span>
<a name="ln-507"></a><span class="c">!!        call set0 % output(unit)</span>
<a name="ln-508"></a><span class="c">!!        close( unit )</span>
<a name="ln-509"></a><span class="c">!!        open( newunit=unit, file=&#39;test.bin&#39;, status=&#39;old&#39;, &amp;</span>
<a name="ln-510"></a><span class="c">!!            form=&#39;unformatted&#39;, action=&#39;read&#39; )</span>
<a name="ln-511"></a><span class="c">!!        call set5 % input(unit)</span>
<a name="ln-512"></a><span class="c">!!        call set4 % input(unit)</span>
<a name="ln-513"></a><span class="c">!!        call set3 % input(unit)</span>
<a name="ln-514"></a><span class="c">!!        close( unit )</span>
<a name="ln-515"></a><span class="c">!!        if ( set3 /= set0 .or. set4 /= set1 .or. set5 /= set2 ) then</span>
<a name="ln-516"></a><span class="c">!!            error stop &#39;Transfer to and from units using &#39; // &amp;</span>
<a name="ln-517"></a><span class="c">!!                &#39; output and input failed.&#39;</span>
<a name="ln-518"></a><span class="c">!!        else</span>
<a name="ln-519"></a><span class="c">!!            write(*,*) &#39;Transfer to and from units using &#39; // &amp;</span>
<a name="ln-520"></a><span class="c">!!                &#39;output and input succeeded.&#39;</span>
<a name="ln-521"></a><span class="c">!!        end if</span>
<a name="ln-522"></a><span class="c">!!    end program demo_output</span>
<a name="ln-523"></a><span class="c">!!```</span>
<a name="ln-524"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-525"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-526"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-527"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-528"></a>        <span class="k">end subroutine </span><span class="n">output_abstract</span>
<a name="ln-529"></a>
<a name="ln-530"></a>        <span class="k">subroutine </span><span class="n">read_bitset_string_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-531"></a><span class="c">!! Version: experimental</span>
<a name="ln-532"></a><span class="c">!!</span>
<a name="ln-533"></a><span class="c">!! Uses the bitset literal in the default character `string`, to define</span>
<a name="ln-534"></a><span class="c">!! the bitset, `self`. The literal may be preceded by an an arbitrary</span>
<a name="ln-535"></a><span class="c">!! sequence of blank characters. If `status` is absent an error results</span>
<a name="ln-536"></a><span class="c">!! in an error stop with an informative stop code. If `status`</span>
<a name="ln-537"></a><span class="c">!! is present it has one of the values</span>
<a name="ln-538"></a><span class="c">!! * `success` - if no problems occurred,</span>
<a name="ln-539"></a><span class="c">!! * `alloc_fault` - if allocation of memory for SELF failed,</span>
<a name="ln-540"></a><span class="c">!! * `array_size_invalid_error - if `bits(self)` in `string` is greater</span>
<a name="ln-541"></a><span class="c">!!   than 64 for a `bitset_64`,</span>
<a name="ln-542"></a><span class="c">!! * `char_string_invalid_error` - if the bitset literal has an invalid</span>
<a name="ln-543"></a><span class="c">!!   character,</span>
<a name="ln-544"></a><span class="c">!! * `char_string_too_small_error - if the string ends before all the bits</span>
<a name="ln-545"></a><span class="c">!!   are read.</span>
<a name="ln-546"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-547"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-548"></a><span class="c">!!</span>
<a name="ln-549"></a><span class="c">!!#### Example</span>
<a name="ln-550"></a><span class="c">!!</span>
<a name="ln-551"></a><span class="c">!!```fortran</span>
<a name="ln-552"></a><span class="c">!!    program demo_read_bitset</span>
<a name="ln-553"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-554"></a><span class="c">!!            bits_0   = &#39;S33B000000000000000000000000000000000&#39;, &amp;</span>
<a name="ln-555"></a><span class="c">!!            bits_1   = &#39;S33B000000000000000000000000000000001&#39;, &amp;</span>
<a name="ln-556"></a><span class="c">!!            bits_33  = &#39;S33B100000000000000000000000000000000&#39;</span>
<a name="ln-557"></a><span class="c">!!        character(:), allocatable :: test_0, test_1, test_2</span>
<a name="ln-558"></a><span class="c">!!        integer :: unit</span>
<a name="ln-559"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2, set3, set4, set5</span>
<a name="ln-560"></a><span class="c">!!        call set0 % read_bitset( bits_0, status )</span>
<a name="ln-561"></a><span class="c">!!        call set1 % read_bitset( bits_1, status )</span>
<a name="ln-562"></a><span class="c">!!        call set2 % read_bitset( bits_2, status )</span>
<a name="ln-563"></a><span class="c">!!        call set0 % write_bitset( test_0, status )</span>
<a name="ln-564"></a><span class="c">!!        call set1 % write_bitset( test_1, status )</span>
<a name="ln-565"></a><span class="c">!!        call set2 % write_bitset( test_2, status )</span>
<a name="ln-566"></a><span class="c">!!        if ( bits_0 == test_0 .and. bits_1 == test_1 .and. &amp;</span>
<a name="ln-567"></a><span class="c">!!            bits_2 == test_2 ) then</span>
<a name="ln-568"></a><span class="c">!!            write(*,*) &#39;READ_BITSET to WRITE_BITSET strings worked.&#39;</span>
<a name="ln-569"></a><span class="c">!!        end if</span>
<a name="ln-570"></a><span class="c">!!        open( newunit=unit, file=&#39;test.txt&#39;, status=&#39;replace&#39;, &amp;</span>
<a name="ln-571"></a><span class="c">!!            form=&#39;formatted&#39;, action=&#39;write&#39; )</span>
<a name="ln-572"></a><span class="c">!!        call set2 % write_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-573"></a><span class="c">!!        call set1 % write_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-574"></a><span class="c">!!        call set0 % write_bitset(unit)</span>
<a name="ln-575"></a><span class="c">!!        close( unit )</span>
<a name="ln-576"></a><span class="c">!!        open( newunit=unit, file=&#39;test.txt&#39;, status=&#39;old&#39;, &amp;</span>
<a name="ln-577"></a><span class="c">!!            form=&#39;formatted&#39;, action=&#39;read&#39; )</span>
<a name="ln-578"></a><span class="c">!!        call set3 % read_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-579"></a><span class="c">!!        call set4 % read_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-580"></a><span class="c">!!        call set5 % read_bitset(unit)</span>
<a name="ln-581"></a><span class="c">!!        if ( set3 == set0 .and. set4 == set1 .and. set5 == set2 ) then</span>
<a name="ln-582"></a><span class="c">!!            write(*,*) WRITE_BITSET to READ_BITSET through unit worked.&#39;</span>
<a name="ln-583"></a><span class="c">!!        end if</span>
<a name="ln-584"></a><span class="c">!!    end program demo_read_bitset</span>
<a name="ln-585"></a><span class="c">!!```</span>
<a name="ln-586"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-587"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-588"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">string</span>
<a name="ln-589"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-590"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_string_abstract</span>
<a name="ln-591"></a>
<a name="ln-592"></a>        <span class="k">subroutine </span><span class="n">read_bitset_unit_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-593"></a><span class="c">!! Version: experimental</span>
<a name="ln-594"></a><span class="c">!!</span>
<a name="ln-595"></a><span class="c">!! Uses the bitset literal at the current position in the formatted</span>
<a name="ln-596"></a><span class="c">!! file with I/O unit, `unit`, to define the bitset, `self`. The literal</span>
<a name="ln-597"></a><span class="c">!! may be preceded by an an arbitrary sequence of blank characters.</span>
<a name="ln-598"></a><span class="c">!! If `advance` is present it must be either &#39;YES&#39; or &#39;NO&#39;. If absent</span>
<a name="ln-599"></a><span class="c">!! it has the default value of &#39;YES&#39; to determine whether advancing</span>
<a name="ln-600"></a><span class="c">!! I/O occurs. If `status` is absent an error results in an error stop</span>
<a name="ln-601"></a><span class="c">!! with an informative stop code. If `status` is present it has one of</span>
<a name="ln-602"></a><span class="c">!! the values:</span>
<a name="ln-603"></a><span class="c">!! * `success` - if no problem occurred,</span>
<a name="ln-604"></a><span class="c">!! * `alloc_fault` - if allocation of `self` failed,</span>
<a name="ln-605"></a><span class="c">!! * `array_size_invalid_error` - if `bits(self)` in the bitset literal</span>
<a name="ln-606"></a><span class="c">!!   is greater than 64 for a `bitset_64`,</span>
<a name="ln-607"></a><span class="c">!! * `char_string_invalid_error` - if the read of the bitset literal found</span>
<a name="ln-608"></a><span class="c">!!   an invalid character,</span>
<a name="ln-609"></a><span class="c">!! * `eof_failure` - if a `read` statement reached an end-of-file before</span>
<a name="ln-610"></a><span class="c">!!   completing the read of the bitset literal,</span>
<a name="ln-611"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-612"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-613"></a><span class="c">!! * `read_failure` - if a `read` statement fails,</span>
<a name="ln-614"></a><span class="c">!</span>
<a name="ln-615"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-616"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">self</span>
<a name="ln-617"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-618"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-619"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>     <span class="kd">::</span> <span class="n">status</span>
<a name="ln-620"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_unit_abstract</span>
<a name="ln-621"></a>
<a name="ln-622"></a>        <span class="k">elemental subroutine </span><span class="n">set_bit_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-623"></a><span class="c">!! Version: experimental</span>
<a name="ln-624"></a><span class="c">!!</span>
<a name="ln-625"></a><span class="c">!! Sets the value at the `pos` position in `self`, provided the position is</span>
<a name="ln-626"></a><span class="c">!! valid. If the position is less than 0 or greater than `bits(self)-1`</span>
<a name="ln-627"></a><span class="c">!! then `self` is unchanged.</span>
<a name="ln-628"></a><span class="c">!!</span>
<a name="ln-629"></a><span class="c">!!#### Example</span>
<a name="ln-630"></a><span class="c">!!</span>
<a name="ln-631"></a><span class="c">!!```fortran</span>
<a name="ln-632"></a><span class="c">!!    program demo_set</span>
<a name="ln-633"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-634"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-635"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-636"></a><span class="c">!!        if ( set0 % none() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-637"></a><span class="c">!!        call set0 % set(165)</span>
<a name="ln-638"></a><span class="c">!!        if ( set0 % test(165) ) write(*,*) &#39;Bit 165 is set.&#39;</span>
<a name="ln-639"></a><span class="c">!!        call set0 % set(0,164)</span>
<a name="ln-640"></a><span class="c">!!        if ( set0 % all() ) write(*,*) &#39;All bits are set.&#39;</span>
<a name="ln-641"></a><span class="c">!!    end program demo_set</span>
<a name="ln-642"></a><span class="c">!!```</span>
<a name="ln-643"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-644"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-645"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-646"></a>        <span class="k">end subroutine </span><span class="n">set_bit_abstract</span>
<a name="ln-647"></a>
<a name="ln-648"></a>        <span class="k">pure subroutine </span><span class="n">set_range_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-649"></a><span class="c">!! Version: experimental</span>
<a name="ln-650"></a><span class="c">!!</span>
<a name="ln-651"></a><span class="c">!! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions</span>
<a name="ln-652"></a><span class="c">!! in `self`. If `stop_pos &lt; start_pos` no bits are changed. Positions outside</span>
<a name="ln-653"></a><span class="c">!! the range 0 to `bits(self)-1` are ignored.</span>
<a name="ln-654"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-655"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-656"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-657"></a>        <span class="k">end subroutine </span><span class="n">set_range_abstract</span>
<a name="ln-658"></a>
<a name="ln-659"></a>        <span class="k">elemental function </span><span class="n">test_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<a name="ln-660"></a><span class="c">!! Version: experimental</span>
<a name="ln-661"></a><span class="c">!!</span>
<a name="ln-662"></a><span class="c">!! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos`</span>
<a name="ln-663"></a><span class="c">!! is negative or greater than `bits(self) - 1` the result is `.false.`.</span>
<a name="ln-664"></a><span class="c">!!</span>
<a name="ln-665"></a><span class="c">!!#### Example</span>
<a name="ln-666"></a><span class="c">!!</span>
<a name="ln-667"></a><span class="c">!!```fortran</span>
<a name="ln-668"></a><span class="c">!!    program demo_test</span>
<a name="ln-669"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-670"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-671"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-672"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-673"></a><span class="c">!!        if ( set0 % all() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-674"></a><span class="c">!!        call set0 % clear(165)</span>
<a name="ln-675"></a><span class="c">!!        if ( .not. set0 % test(165) ) write(*,*) &#39;Bit 165 is cleared.&#39;</span>
<a name="ln-676"></a><span class="c">!!        call set0 % set(165)</span>
<a name="ln-677"></a><span class="c">!!        if ( set0 % test(165) ) write(*,*) &#39;Bit 165 is set.&#39;</span>
<a name="ln-678"></a><span class="c">!!    end program demo_test</span>
<a name="ln-679"></a><span class="c">!!```</span>
<a name="ln-680"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-681"></a>            <span class="kt">logical</span> <span class="kd">::</span>  <span class="n">test</span>
<a name="ln-682"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-683"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-684"></a>        <span class="k">end function </span><span class="n">test_abstract</span>
<a name="ln-685"></a>
<a name="ln-686"></a>        <span class="k">subroutine </span><span class="n">to_string_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-687"></a><span class="c">!! Version: experimental</span>
<a name="ln-688"></a><span class="c">!!</span>
<a name="ln-689"></a><span class="c">!! Represents the value of `self` as a binary literal in `string`</span>
<a name="ln-690"></a><span class="c">!! Status may have the values `success` or `alloc_fault`.</span>
<a name="ln-691"></a><span class="c">!!</span>
<a name="ln-692"></a><span class="c">!!#### Example</span>
<a name="ln-693"></a><span class="c">!!</span>
<a name="ln-694"></a><span class="c">!!```fortran</span>
<a name="ln-695"></a><span class="c">!!    program demo_to_string</span>
<a name="ln-696"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-697"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-698"></a><span class="c">!!            bits_all = &#39;111111111111111111111111111111111&#39;</span>
<a name="ln-699"></a><span class="c">!!        type(bitset_64) :: set0</span>
<a name="ln-700"></a><span class="c">!!        character(:), allocatable :: new_string</span>
<a name="ln-701"></a><span class="c">!!        call set0 % init(33)</span>
<a name="ln-702"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-703"></a><span class="c">!!        call set0 % to_string( new_string )</span>
<a name="ln-704"></a><span class="c">!!        if ( new_string == bits_all ) then</span>
<a name="ln-705"></a><span class="c">!!            write(*,*) &quot;TO_STRING transferred BITS0 properly&quot; // &amp;</span>
<a name="ln-706"></a><span class="c">!!                &quot; into NEW_STRING.&quot;</span>
<a name="ln-707"></a><span class="c">!!        end if</span>
<a name="ln-708"></a><span class="c">!!    end program demo_to_string</span>
<a name="ln-709"></a><span class="c">!!```</span>
<a name="ln-710"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-711"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>         <span class="kd">::</span> <span class="n">self</span>
<a name="ln-712"></a>            <span class="kt">character</span><span class="p">(:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-713"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>         <span class="kd">::</span> <span class="n">status</span>
<a name="ln-714"></a>        <span class="k">end subroutine </span><span class="n">to_string_abstract</span>
<a name="ln-715"></a>
<a name="ln-716"></a>        <span class="k">elemental function </span><span class="n">value_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>
<a name="ln-717"></a><span class="c">!! Version: experimental</span>
<a name="ln-718"></a><span class="c">!!</span>
<a name="ln-719"></a><span class="c">!! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative</span>
<a name="ln-720"></a><span class="c">!! or greater than `bits(set) - 1` the result is 0.</span>
<a name="ln-721"></a><span class="c">!!</span>
<a name="ln-722"></a><span class="c">!!#### Example</span>
<a name="ln-723"></a><span class="c">!!</span>
<a name="ln-724"></a><span class="c">!!```fortran</span>
<a name="ln-725"></a><span class="c">!!    program demo_value</span>
<a name="ln-726"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-727"></a><span class="c">!!        type(bitset_large) :: set0</span>
<a name="ln-728"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-729"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-730"></a><span class="c">!!        if ( set0 % all() ) write(*,*) &#39;SET0 is properly initialized.&#39;</span>
<a name="ln-731"></a><span class="c">!!        call set0 % clear(165)</span>
<a name="ln-732"></a><span class="c">!!        if ( set0 % value(165) == 0 ) write(*,*) &#39;Bit 165 is cleared.&#39;</span>
<a name="ln-733"></a><span class="c">!!        call set0 % set(165)</span>
<a name="ln-734"></a><span class="c">!!        if ( set0 % value(165) == 1 ) write(*,*) &#39;Bit 165 is set.&#39;</span>
<a name="ln-735"></a><span class="c">!!    end program demo_value</span>
<a name="ln-736"></a><span class="c">!!```</span>
<a name="ln-737"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span><span class="p">,</span> <span class="n">bits_kind</span>
<a name="ln-738"></a>            <span class="kt">integer</span> <span class="kd">::</span>  <span class="k">value</span>
<a name="ln-739"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-740"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-741"></a>        <span class="k">end function </span><span class="n">value_abstract</span>
<a name="ln-742"></a>
<a name="ln-743"></a>        <span class="k">subroutine </span><span class="n">write_bitset_string_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-744"></a><span class="c">!! Version: experimental</span>
<a name="ln-745"></a><span class="c">!!</span>
<a name="ln-746"></a><span class="c">!! Writes a bitset literal to the allocatable default character `string`,</span>
<a name="ln-747"></a><span class="c">!! representing the individual bit values in the `bitset_type`, `self`.</span>
<a name="ln-748"></a><span class="c">!! If `status` is absent an error results in an error stop with an</span>
<a name="ln-749"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-750"></a><span class="c">!! value of `success`, or the value `alloc_fault` if allocation of</span>
<a name="ln-751"></a><span class="c">!! the output string failed.</span>
<a name="ln-752"></a><span class="c">!!</span>
<a name="ln-753"></a><span class="c">!!#### Example</span>
<a name="ln-754"></a><span class="c">!!</span>
<a name="ln-755"></a><span class="c">!!```fortran</span>
<a name="ln-756"></a><span class="c">!!    program demo_write_bitset</span>
<a name="ln-757"></a><span class="c">!!        character(*), parameter :: &amp;</span>
<a name="ln-758"></a><span class="c">!!            bits_0   = &#39;S33B000000000000000000000000000000000&#39;, &amp;</span>
<a name="ln-759"></a><span class="c">!!            bits_1   = &#39;S33B000000000000000000000000000000001&#39;, &amp;</span>
<a name="ln-760"></a><span class="c">!!            bits_33  = &#39;S33B100000000000000000000000000000000&#39;</span>
<a name="ln-761"></a><span class="c">!!        character(:), allocatable :: test_0, test_1, test_2</span>
<a name="ln-762"></a><span class="c">!!        integer :: unit</span>
<a name="ln-763"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2, set3, set4, set5</span>
<a name="ln-764"></a><span class="c">!!        call set0 % read_bitset( bits_0, status )</span>
<a name="ln-765"></a><span class="c">!!        call set1 % read_bitset( bits_1, status )</span>
<a name="ln-766"></a><span class="c">!!        call set2 % read_bitset( bits_2, status )</span>
<a name="ln-767"></a><span class="c">!!        call set0 % write_bitset( test_0, status )</span>
<a name="ln-768"></a><span class="c">!!        call set1 % write_bitset( test_1, status )</span>
<a name="ln-769"></a><span class="c">!!        call set2 % write_bitset( test_2, status )</span>
<a name="ln-770"></a><span class="c">!!        if ( bits_0 == test_0 .and. bits_1 == test_1 .and. &amp;</span>
<a name="ln-771"></a><span class="c">!!            bits_2 == test_2 ) then</span>
<a name="ln-772"></a><span class="c">!!            write(*,*) &#39;READ_BITSET to WRITE_BITSET strings worked.&#39;</span>
<a name="ln-773"></a><span class="c">!!        end if</span>
<a name="ln-774"></a><span class="c">!!        open( newunit=unit, file=&#39;test.txt&#39;, status=&#39;replace&#39;, &amp;</span>
<a name="ln-775"></a><span class="c">!!            form=&#39;formatted&#39;, action=&#39;write&#39; )</span>
<a name="ln-776"></a><span class="c">!!        call set2 % write_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-777"></a><span class="c">!!        call set1 % write_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-778"></a><span class="c">!!        call set0 % write_bitset(unit)</span>
<a name="ln-779"></a><span class="c">!!        close( unit )</span>
<a name="ln-780"></a><span class="c">!!        open( newunit=unit, file=&#39;test.txt&#39;, status=&#39;old&#39;, &amp;</span>
<a name="ln-781"></a><span class="c">!!            form=&#39;formatted&#39;, action=&#39;read&#39; )</span>
<a name="ln-782"></a><span class="c">!!        call set3 % read_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-783"></a><span class="c">!!        call set4 % read_bitset(unit, advance=&#39;no&#39;)</span>
<a name="ln-784"></a><span class="c">!!        call set5 % read_bitset(unit)</span>
<a name="ln-785"></a><span class="c">!!        if ( set3 == set0 .and. set4 == set1 .and. set5 == set2 ) then</span>
<a name="ln-786"></a><span class="c">!!            write(*,*) WRITE_BITSET to READ_BITSET through unit worked.&#39;</span>
<a name="ln-787"></a><span class="c">!!        end if</span>
<a name="ln-788"></a><span class="c">!!    end program demo_write_bitset</span>
<a name="ln-789"></a><span class="c">!!```</span>
<a name="ln-790"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-791"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>             <span class="kd">::</span> <span class="n">self</span>
<a name="ln-792"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="p">:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-793"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>             <span class="kd">::</span> <span class="n">status</span>
<a name="ln-794"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_string_abstract</span>
<a name="ln-795"></a>
<a name="ln-796"></a>        <span class="k">subroutine </span><span class="n">write_bitset_unit_abstract</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="p">&amp;</span>
<a name="ln-797"></a>            <span class="n">status</span><span class="p">)</span>
<a name="ln-798"></a><span class="c">!! Version: experimental</span>
<a name="ln-799"></a><span class="c">!!</span>
<a name="ln-800"></a><span class="c">!! Writes a bitset literal to the I/O unit, `unit`, representing the</span>
<a name="ln-801"></a><span class="c">!! individual bit values in the `bitset_t`, `self`. If an error occurs then</span>
<a name="ln-802"></a><span class="c">!! processing stops with a message to `error_unit`. By default or if</span>
<a name="ln-803"></a><span class="c">!! `advance` is present with the value &#39;YES&#39;, advancing output is used.</span>
<a name="ln-804"></a><span class="c">!! If `advance` is present with the value &#39;NO&#39;, then the current record</span>
<a name="ln-805"></a><span class="c">!! is not advanced by the write. If `status` is absent, an error results</span>
<a name="ln-806"></a><span class="c">!! in an error stop with an informative stop code. If `status` is</span>
<a name="ln-807"></a><span class="c">!! present it has the default value of `success`, the value</span>
<a name="ln-808"></a><span class="c">!! `alloc_fault` if allocation of the output string failed,</span>
<a name="ln-809"></a><span class="c">!! `write_failure` if the `write` statement outputting the literal failed.</span>
<a name="ln-810"></a>            <span class="k">import</span> <span class="kd">::</span> <span class="n">bitset_type</span>
<a name="ln-811"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>         <span class="kd">::</span> <span class="n">self</span>
<a name="ln-812"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                    <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-813"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-814"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>         <span class="kd">::</span> <span class="n">status</span>
<a name="ln-815"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_unit_abstract</span>
<a name="ln-816"></a>
<a name="ln-817"></a>    <span class="k">end interface</span>
<a name="ln-818"></a>
<a name="ln-819"></a><span class="k">    type</span><span class="p">,</span> <span class="k">extends</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bitset_large</span>
<a name="ln-820"></a><span class="c">!! Version: experimental</span>
<a name="ln-821"></a><span class="c">!!</span>
<a name="ln-822"></a><span class="c">!! Type for bitsets with more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types))</span>
<a name="ln-823"></a>
<a name="ln-824"></a>        <span class="k">private</span>
<a name="ln-825"></a><span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">block_kind</span><span class="p">),</span> <span class="k">private</span><span class="p">,</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">blocks</span><span class="p">(:)</span>
<a name="ln-826"></a>
<a name="ln-827"></a>    <span class="k">contains</span>
<a name="ln-828"></a>
<a name="ln-829"></a><span class="k">        procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">all</span> <span class="o">=&gt;</span> <span class="n">all_large</span>
<a name="ln-830"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="nb">any</span> <span class="o">=&gt;</span> <span class="n">any_large</span>
<a name="ln-831"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">bit_count</span> <span class="o">=&gt;</span> <span class="n">bit_count_large</span>
<a name="ln-832"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">clear_bit</span> <span class="o">=&gt;</span> <span class="n">clear_bit_large</span>
<a name="ln-833"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">clear_range</span> <span class="o">=&gt;</span> <span class="n">clear_range_large</span>
<a name="ln-834"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">flip_bit</span> <span class="o">=&gt;</span> <span class="n">flip_bit_large</span>
<a name="ln-835"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">flip_range</span> <span class="o">=&gt;</span> <span class="n">flip_range_large</span>
<a name="ln-836"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">from_string</span> <span class="o">=&gt;</span> <span class="n">from_string_large</span>
<a name="ln-837"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">init_zero</span> <span class="o">=&gt;</span> <span class="n">init_zero_large</span>
<a name="ln-838"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">input</span> <span class="o">=&gt;</span> <span class="n">input_large</span>
<a name="ln-839"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">none</span> <span class="o">=&gt;</span> <span class="n">none_large</span>
<a name="ln-840"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="nb">not</span> <span class="o">=&gt;</span> <span class="n">not_large</span>
<a name="ln-841"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">output</span> <span class="o">=&gt;</span> <span class="n">output_large</span>
<a name="ln-842"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-843"></a>            <span class="n">read_bitset_string</span> <span class="o">=&gt;</span> <span class="n">read_bitset_string_large</span>
<a name="ln-844"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">read_bitset_unit</span> <span class="o">=&gt;</span> <span class="n">read_bitset_unit_large</span>
<a name="ln-845"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set_bit</span> <span class="o">=&gt;</span> <span class="n">set_bit_large</span>
<a name="ln-846"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set_range</span> <span class="o">=&gt;</span> <span class="n">set_range_large</span>
<a name="ln-847"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">test</span> <span class="o">=&gt;</span> <span class="n">test_large</span>
<a name="ln-848"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">to_string</span> <span class="o">=&gt;</span> <span class="n">to_string_large</span>
<a name="ln-849"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">value</span> <span class="o">=&gt;</span> <span class="n">value_large</span>
<a name="ln-850"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="p">&amp;</span>
<a name="ln-851"></a>            <span class="n">write_bitset_string</span> <span class="o">=&gt;</span> <span class="n">write_bitset_string_large</span>
<a name="ln-852"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">write_bitset_unit</span> <span class="o">=&gt;</span> <span class="n">write_bitset_unit_large</span>
<a name="ln-853"></a>
<a name="ln-854"></a>    <span class="k">end type </span><span class="n">bitset_large</span>
<a name="ln-855"></a>
<a name="ln-856"></a>
<a name="ln-857"></a>    <span class="k">interface</span>
<a name="ln-858"></a>
<a name="ln-859"></a><span class="k">        elemental module function </span><span class="n">all_large</span><span class="p">(</span> <span class="n">self</span> <span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">all</span><span class="p">)</span>
<a name="ln-860"></a><span class="c">!! Version: experimental</span>
<a name="ln-861"></a><span class="c">!!</span>
<a name="ln-862"></a><span class="c">!! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise.</span>
<a name="ln-863"></a>            <span class="kt">logical</span>                         <span class="kd">::</span> <span class="k">all</span>
<a name="ln-864"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-865"></a>        <span class="k">end function </span><span class="n">all_large</span>
<a name="ln-866"></a>
<a name="ln-867"></a>        <span class="k">elemental module function </span><span class="n">any_large</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="nb">any</span><span class="p">)</span>
<a name="ln-868"></a><span class="c">!! Version: experimental</span>
<a name="ln-869"></a><span class="c">!!</span>
<a name="ln-870"></a><span class="c">!! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise.</span>
<a name="ln-871"></a>            <span class="kt">logical</span>                         <span class="kd">::</span> <span class="nb">any</span>
<a name="ln-872"></a><span class="nb">            </span><span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-873"></a>        <span class="k">end function </span><span class="n">any_large</span>
<a name="ln-874"></a>
<a name="ln-875"></a>        <span class="k">elemental module function </span><span class="n">bit_count_large</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">bit_count</span><span class="p">)</span>
<a name="ln-876"></a><span class="c">!! Version: experimental</span>
<a name="ln-877"></a><span class="c">!!</span>
<a name="ln-878"></a><span class="c">!! Returns the number of non-zero bits in `self`.</span>
<a name="ln-879"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">)</span>              <span class="kd">::</span>  <span class="n">bit_count</span>
<a name="ln-880"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-881"></a>        <span class="k">end function </span><span class="n">bit_count_large</span>
<a name="ln-882"></a>
<a name="ln-883"></a>        <span class="k">elemental module subroutine </span><span class="n">clear_bit_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-884"></a><span class="c">!! Version: experimental</span>
<a name="ln-885"></a><span class="c">!!</span>
<a name="ln-886"></a><span class="c">!! Sets to zero the bit at `pos` position in `self`. If `pos` is less than</span>
<a name="ln-887"></a><span class="c">!! zero or greater than `bits(self)-1` it is ignored.</span>
<a name="ln-888"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-889"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-890"></a>        <span class="k">end subroutine </span><span class="n">clear_bit_large</span>
<a name="ln-891"></a>
<a name="ln-892"></a>        <span class="k">pure module subroutine </span><span class="n">clear_range_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-893"></a><span class="c">!! Version: experimental</span>
<a name="ln-894"></a><span class="c">!!</span>
<a name="ln-895"></a><span class="c">!! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `self`.</span>
<a name="ln-896"></a><span class="c">!! If `stop_pos &lt; start_pos` then no bits are modified. Positions outside</span>
<a name="ln-897"></a><span class="c">!! the range 0 to `bits(set)-1` are ignored.</span>
<a name="ln-898"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-899"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-900"></a>        <span class="k">end subroutine </span><span class="n">clear_range_large</span>
<a name="ln-901"></a>
<a name="ln-902"></a>        <span class="k">elemental module subroutine </span><span class="n">flip_bit_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-903"></a><span class="c">!! Version: experimental</span>
<a name="ln-904"></a><span class="c">!!</span>
<a name="ln-905"></a><span class="c">!! Flips the bit value at the `pos` position in `self`, provided the position is</span>
<a name="ln-906"></a><span class="c">!! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is</span>
<a name="ln-907"></a><span class="c">!! changed.</span>
<a name="ln-908"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-909"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-910"></a>        <span class="k">end subroutine </span><span class="n">flip_bit_large</span>
<a name="ln-911"></a>
<a name="ln-912"></a>        <span class="k">pure module subroutine </span><span class="n">flip_range_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-913"></a><span class="c">!! Version: experimental</span>
<a name="ln-914"></a><span class="c">!!</span>
<a name="ln-915"></a><span class="c">!! Flips all valid bits from the `start_pos` to the `stop_pos` positions in</span>
<a name="ln-916"></a><span class="c">!! `self`. If `stop_pos &lt; start_pos` no bits are flipped. Positions less than</span>
<a name="ln-917"></a><span class="c">!! 0 or greater than `bits(self)-1` are ignored.</span>
<a name="ln-918"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-919"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-920"></a>        <span class="k">end subroutine </span><span class="n">flip_range_large</span>
<a name="ln-921"></a>
<a name="ln-922"></a>        <span class="k">module subroutine </span><span class="n">from_string_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-923"></a><span class="c">!! Version: experimental</span>
<a name="ln-924"></a><span class="c">!!</span>
<a name="ln-925"></a><span class="c">!! Initializes the bitset `self` treating `string` as a binary literal</span>
<a name="ln-926"></a><span class="c">!! `status` may have the values:</span>
<a name="ln-927"></a><span class="c">!! * `success` - if no problems were found,</span>
<a name="ln-928"></a><span class="c">!! * `alloc_fault` - if allocation of the bitset failed</span>
<a name="ln-929"></a><span class="c">!! * `char_string_too_large_error` - if `string` was too large, or</span>
<a name="ln-930"></a><span class="c">!! * `char_string_invalid_error` - if string had an invalid character.</span>
<a name="ln-931"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-932"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>         <span class="kd">::</span> <span class="n">string</span>
<a name="ln-933"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>   <span class="kd">::</span> <span class="n">status</span>
<a name="ln-934"></a>        <span class="k">end subroutine </span><span class="n">from_string_large</span>
<a name="ln-935"></a>
<a name="ln-936"></a>        <span class="k">module subroutine </span><span class="n">init_zero_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-937"></a><span class="c">!! Version: experimental</span>
<a name="ln-938"></a><span class="c">!!</span>
<a name="ln-939"></a><span class="c">!! Creates the bitset, `self`, of size `bits`, with all bits initialized to</span>
<a name="ln-940"></a><span class="c">!! zero. `bits` must be non-negative.  If an error occurs and `status` is</span>
<a name="ln-941"></a><span class="c">!! absent then processing stops with an informative stop code. `status`</span>
<a name="ln-942"></a><span class="c">!! will have one of the values;</span>
<a name="ln-943"></a><span class="c">!! * `success` -  if no problems were found,</span>
<a name="ln-944"></a><span class="c">!! * `alloc_fault` - if memory allocation failed</span>
<a name="ln-945"></a><span class="c">!! * `array_size_invalid_error` - if `bits` is either negative or larger</span>
<a name="ln-946"></a><span class="c">!!   than 64 with `self` of class `bitset_64`, or</span>
<a name="ln-947"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-948"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">bits</span>
<a name="ln-949"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>   <span class="kd">::</span> <span class="n">status</span>
<a name="ln-950"></a>        <span class="k">end subroutine </span><span class="n">init_zero_large</span>
<a name="ln-951"></a>
<a name="ln-952"></a>        <span class="k">module subroutine </span><span class="n">input_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-953"></a><span class="c">!! Version: experimental</span>
<a name="ln-954"></a><span class="c">!!</span>
<a name="ln-955"></a><span class="c">!! Reads the components of the bitset, `self`, from the unformatted I/O</span>
<a name="ln-956"></a><span class="c">!! unit, `unit`, assuming that the components were written using `output`.</span>
<a name="ln-957"></a><span class="c">!! If an error occurs and `status` is absent then processing stops with</span>
<a name="ln-958"></a><span class="c">!! an informative stop code. `status` has one of the values:</span>
<a name="ln-959"></a><span class="c">!! * `success` - if no problem was found</span>
<a name="ln-960"></a><span class="c">!! * `alloc_fault` - if it failed allocating memory for `self`, or</span>
<a name="ln-961"></a><span class="c">!! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative</span>
<a name="ln-962"></a><span class="c">!!   or greater than 64 for a `bitset_64` input.</span>
<a name="ln-963"></a><span class="c">!! * `read_failure` - if it failed during the reads from `unit`</span>
<a name="ln-964"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-965"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>              <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-966"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>   <span class="kd">::</span> <span class="n">status</span>
<a name="ln-967"></a>        <span class="k">end subroutine </span><span class="n">input_large</span>
<a name="ln-968"></a>
<a name="ln-969"></a>        <span class="k">elemental module function </span><span class="n">none_large</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">none</span><span class="p">)</span>
<a name="ln-970"></a><span class="c">!! Version: experimental</span>
<a name="ln-971"></a><span class="c">!!</span>
<a name="ln-972"></a><span class="c">!! Returns `.true.` if none of the bits in `self` have the value 1.</span>
<a name="ln-973"></a>            <span class="kt">logical</span>                         <span class="kd">::</span>  <span class="k">none</span>
<a name="ln-974"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-975"></a>        <span class="k">end function </span><span class="n">none_large</span>
<a name="ln-976"></a>
<a name="ln-977"></a>        <span class="k">elemental module subroutine </span><span class="n">not_large</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<a name="ln-978"></a><span class="c">!! Version: experimental</span>
<a name="ln-979"></a><span class="c">!!</span>
<a name="ln-980"></a><span class="c">!! Sets the bits in `self` to their logical complement</span>
<a name="ln-981"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-982"></a>        <span class="k">end subroutine </span><span class="n">not_large</span>
<a name="ln-983"></a>
<a name="ln-984"></a>        <span class="k">module subroutine </span><span class="n">output_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-985"></a><span class="c">!! Version: experimental</span>
<a name="ln-986"></a><span class="c">!!</span>
<a name="ln-987"></a><span class="c">!! Writes the components of the bitset, `self`, to the unformatted I/O</span>
<a name="ln-988"></a><span class="c">!! unit, `unit`, in a unformatted sequence compatible with `input`. If</span>
<a name="ln-989"></a><span class="c">!! `status` is absent an error results in an error stop with an</span>
<a name="ln-990"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-991"></a><span class="c">!! value of `success`, or the value `write_failure` if the write failed.</span>
<a name="ln-992"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-993"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>             <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-994"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-995"></a>        <span class="k">end subroutine </span><span class="n">output_large</span>
<a name="ln-996"></a>
<a name="ln-997"></a>        <span class="k">module subroutine </span><span class="n">read_bitset_string_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-998"></a><span class="c">!! Version: experimental</span>
<a name="ln-999"></a><span class="c">!!</span>
<a name="ln-1000"></a><span class="c">!! Uses the bitset literal in the default character `string`, to define</span>
<a name="ln-1001"></a><span class="c">!! the bitset, `self`. The literal may be preceded by an an arbitrary</span>
<a name="ln-1002"></a><span class="c">!! sequence of blank characters. If `status` is absent an error results</span>
<a name="ln-1003"></a><span class="c">!! in an error stop with an informative stop code. If `status`</span>
<a name="ln-1004"></a><span class="c">!! is present it has one of the values</span>
<a name="ln-1005"></a><span class="c">!! * `success` - if no problems occurred,</span>
<a name="ln-1006"></a><span class="c">!! * `alloc_fault` - if allocation of memory for SELF failed,</span>
<a name="ln-1007"></a><span class="c">!! * `array_size_invalid_error - if `bits(self)` in `string` is greater</span>
<a name="ln-1008"></a><span class="c">!!   than 64 for a `bitset_64`,</span>
<a name="ln-1009"></a><span class="c">!! * `char_string_invalid_error` - if the bitset literal has an invalid</span>
<a name="ln-1010"></a><span class="c">!!   character,</span>
<a name="ln-1011"></a><span class="c">!! * `char_string_too_small_error - if the string ends before all the bits</span>
<a name="ln-1012"></a><span class="c">!!   are read.</span>
<a name="ln-1013"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-1014"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-1015"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1016"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1017"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>   <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1018"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_string_large</span>
<a name="ln-1019"></a>
<a name="ln-1020"></a>        <span class="k">module subroutine </span><span class="n">read_bitset_unit_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1021"></a><span class="c">!! Version: experimental</span>
<a name="ln-1022"></a><span class="c">!!</span>
<a name="ln-1023"></a><span class="c">!! Uses the bitset literal at the current position in the formatted</span>
<a name="ln-1024"></a><span class="c">!! file with I/O unit, `unit`, to define the bitset, `self`. The literal</span>
<a name="ln-1025"></a><span class="c">!! may be preceded by an an arbitrary sequence of blank characters.</span>
<a name="ln-1026"></a><span class="c">!! If `advance` is present it must be either &#39;YES&#39; or &#39;NO&#39;. If absent</span>
<a name="ln-1027"></a><span class="c">!! it has the default value of &#39;YES&#39; to determine whether advancing</span>
<a name="ln-1028"></a><span class="c">!! I/O occurs. If `status` is absent an error results in an error stop</span>
<a name="ln-1029"></a><span class="c">!! with an informative stop code. If `status` is present it has one of</span>
<a name="ln-1030"></a><span class="c">!! the values:</span>
<a name="ln-1031"></a><span class="c">!! * `success` - if no problem occurred,</span>
<a name="ln-1032"></a><span class="c">!! * `alloc_fault` - if allocation of `self` failed,</span>
<a name="ln-1033"></a><span class="c">!! * `array_size_invalid_error` - if `bits(self)` in the bitset literal</span>
<a name="ln-1034"></a><span class="c">!!   is greater than 64 for a `bitset_64`,</span>
<a name="ln-1035"></a><span class="c">!! * `char_string_invalid_error` - if the read of the bitset literal found</span>
<a name="ln-1036"></a><span class="c">!!   an invalid character,</span>
<a name="ln-1037"></a><span class="c">!! * `eof_failure` - if a `read` statement reached an end-of-file before</span>
<a name="ln-1038"></a><span class="c">!!   completing the read of the bitset literal,</span>
<a name="ln-1039"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-1040"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-1041"></a><span class="c">!! * `read_failure` - if a `read` statement fails,</span>
<a name="ln-1042"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1043"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1044"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-1045"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>     <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1046"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_unit_large</span>
<a name="ln-1047"></a>
<a name="ln-1048"></a>        <span class="k">elemental module subroutine </span><span class="n">set_bit_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-1049"></a><span class="c">!! Version: experimental</span>
<a name="ln-1050"></a><span class="c">!!</span>
<a name="ln-1051"></a><span class="c">!! Sets the value at the `pos` position in `self`, provided the position is</span>
<a name="ln-1052"></a><span class="c">!! valid. If the position is less than 0 or greater than `bits(self)-1`</span>
<a name="ln-1053"></a><span class="c">!! then `self` is unchanged.</span>
<a name="ln-1054"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1055"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1056"></a>        <span class="k">end subroutine </span><span class="n">set_bit_large</span>
<a name="ln-1057"></a>
<a name="ln-1058"></a>        <span class="k">pure module subroutine </span><span class="n">set_range_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-1059"></a><span class="c">!! Version: experimental</span>
<a name="ln-1060"></a><span class="c">!!</span>
<a name="ln-1061"></a><span class="c">!! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions</span>
<a name="ln-1062"></a><span class="c">!! in `self`. If `stop_pos &lt; start_pos` no bits are changed. Positions outside</span>
<a name="ln-1063"></a><span class="c">!! the range 0 to `bits(self)-1` are ignored.</span>
<a name="ln-1064"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1065"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>     <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1066"></a>        <span class="k">end subroutine </span><span class="n">set_range_large</span>
<a name="ln-1067"></a>
<a name="ln-1068"></a>        <span class="k">elemental module function </span><span class="n">test_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<a name="ln-1069"></a><span class="c">!! Version: experimental</span>
<a name="ln-1070"></a><span class="c">!!</span>
<a name="ln-1071"></a><span class="c">!! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos`</span>
<a name="ln-1072"></a><span class="c">!! is negative or greater than `bits(self) - 1` the result is `.false.`.</span>
<a name="ln-1073"></a>            <span class="kt">logical</span> <span class="kd">::</span>  <span class="n">test</span>
<a name="ln-1074"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1075"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1076"></a>        <span class="k">end function </span><span class="n">test_large</span>
<a name="ln-1077"></a>
<a name="ln-1078"></a>        <span class="k">module subroutine </span><span class="n">to_string_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1079"></a><span class="c">!! Version: experimental</span>
<a name="ln-1080"></a><span class="c">!!</span>
<a name="ln-1081"></a><span class="c">!! Represents the value of `self` as a binary literal in `string`</span>
<a name="ln-1082"></a><span class="c">!! Status may have the values `success` or `alloc_fault`.</span>
<a name="ln-1083"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1084"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="p">:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1085"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>             <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1086"></a>        <span class="k">end subroutine </span><span class="n">to_string_large</span>
<a name="ln-1087"></a>
<a name="ln-1088"></a>        <span class="k">elemental module function </span><span class="n">value_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>
<a name="ln-1089"></a><span class="c">!! Version: experimental</span>
<a name="ln-1090"></a><span class="c">!!</span>
<a name="ln-1091"></a><span class="c">!! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative</span>
<a name="ln-1092"></a><span class="c">!! or greater than `bits(set) - 1` the result is 0.</span>
<a name="ln-1093"></a>            <span class="kt">integer</span> <span class="kd">::</span>  <span class="k">value</span>
<a name="ln-1094"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1095"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1096"></a>        <span class="k">end function </span><span class="n">value_large</span>
<a name="ln-1097"></a>
<a name="ln-1098"></a>        <span class="k">module subroutine </span><span class="n">write_bitset_string_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1099"></a><span class="c">!! Version: experimental</span>
<a name="ln-1100"></a><span class="c">!!</span>
<a name="ln-1101"></a><span class="c">!! Writes a bitset literal to the allocatable default character `string`,</span>
<a name="ln-1102"></a><span class="c">!! representing the individual bit values in the bitset_large, `self`.</span>
<a name="ln-1103"></a><span class="c">!! If `status` is absent an error results in an error stop with an</span>
<a name="ln-1104"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-1105"></a><span class="c">!! value of `success, or the value `alloc_fault` if allocation of</span>
<a name="ln-1106"></a><span class="c">!! the output string failed.</span>
<a name="ln-1107"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1108"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="p">:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1109"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>             <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1110"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_string_large</span>
<a name="ln-1111"></a>
<a name="ln-1112"></a>        <span class="k">module subroutine </span><span class="n">write_bitset_unit_large</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1113"></a><span class="c">!! Version: experimental</span>
<a name="ln-1114"></a><span class="c">!!</span>
<a name="ln-1115"></a><span class="c">!! Writes a bitset literal to the I/O unit, `unit`, representing the</span>
<a name="ln-1116"></a><span class="c">!! individual bit values in the bitset, `self`. By default or if</span>
<a name="ln-1117"></a><span class="c">!! `advance` is present with the value &#39;YES&#39;, advancing output is used.</span>
<a name="ln-1118"></a><span class="c">!! If `advance` is present with the value &#39;NO&#39;, then the current record</span>
<a name="ln-1119"></a><span class="c">!! is not advanced by the write. If `status` is absent an error results</span>
<a name="ln-1120"></a><span class="c">!! in an error stop with an informative stop code. If `status` is</span>
<a name="ln-1121"></a><span class="c">!! present it has the default value of `success`, the value</span>
<a name="ln-1122"></a><span class="c">!! `alloc_fault` if allocation of the output string failed, or</span>
<a name="ln-1123"></a><span class="c">!! `write_failure` if the `write` statement outputting the literal failed.</span>
<a name="ln-1124"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>        <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1125"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                    <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1126"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-1127"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>         <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1128"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_unit_large</span>
<a name="ln-1129"></a>
<a name="ln-1130"></a>    <span class="k">end interface</span>
<a name="ln-1131"></a>
<a name="ln-1132"></a>
<a name="ln-1133"></a><span class="k">    interface </span><span class="n">assignment</span><span class="p">(</span><span class="o">=</span><span class="p">)</span>
<a name="ln-1134"></a><span class="c">!! Version: experimental</span>
<a name="ln-1135"></a><span class="c">!!</span>
<a name="ln-1136"></a><span class="c">!! Used to define assignment for `bitset_large`.</span>
<a name="ln-1137"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value))</span>
<a name="ln-1138"></a><span class="c">!!</span>
<a name="ln-1139"></a><span class="c">!!#### Example</span>
<a name="ln-1140"></a><span class="c">!!</span>
<a name="ln-1141"></a><span class="c">!!```fortran</span>
<a name="ln-1142"></a><span class="c">!!    program demo_assignment</span>
<a name="ln-1143"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1144"></a><span class="c">!!        logical(int8)  :: logical1(64) = .true.</span>
<a name="ln-1145"></a><span class="c">!!        logical(int32), allocatable :: logical2(:)</span>
<a name="ln-1146"></a><span class="c">!!        type(bitset_64) :: set0, set1</span>
<a name="ln-1147"></a><span class="c">!!        set0 = logical1</span>
<a name="ln-1148"></a><span class="c">!!        if ( set0 % bits() /= 64 ) then</span>
<a name="ln-1149"></a><span class="c">!!            error stop procedure // &amp;</span>
<a name="ln-1150"></a><span class="c">!!                &#39; initialization with logical(int8) failed to set&#39; // &amp;</span>
<a name="ln-1151"></a><span class="c">!!                &#39; the right size.&#39;</span>
<a name="ln-1152"></a><span class="c">!!        else if ( .not. set0 % all() ) then</span>
<a name="ln-1153"></a><span class="c">!!            error stop procedure // &#39; initialization with&#39; // &amp;</span>
<a name="ln-1154"></a><span class="c">!!                &#39; logical(int8) failed to set the right values.&#39;</span>
<a name="ln-1155"></a><span class="c">!!        else</span>
<a name="ln-1156"></a><span class="c">!!            write(*,*) &#39;Initialization with logical(int8) succeeded.&#39;</span>
<a name="ln-1157"></a><span class="c">!!        end if</span>
<a name="ln-1158"></a><span class="c">!!        set1 = set0</span>
<a name="ln-1159"></a><span class="c">!!        if ( set1 == set0 ) &amp;</span>
<a name="ln-1160"></a><span class="c">!!            write(*,*) &#39;Initialization by assignment succeeded&#39;</span>
<a name="ln-1161"></a><span class="c">!!        logical2 = set1</span>
<a name="ln-1162"></a><span class="c">!!        if ( all( logical2 ) ) then</span>
<a name="ln-1163"></a><span class="c">!!            write(*,*) &#39;Initialization of logical(int32) succeeded.&#39;</span>
<a name="ln-1164"></a><span class="c">!!        end if</span>
<a name="ln-1165"></a><span class="c">!!    end program demo_assignment</span>
<a name="ln-1166"></a><span class="c">!!```</span>
<a name="ln-1167"></a>
<a name="ln-1168"></a>        <span class="k">pure module subroutine </span><span class="n">assign_large</span><span class="p">(</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span> <span class="p">)</span>
<a name="ln-1169"></a><span class="c">!! Version: experimental</span>
<a name="ln-1170"></a><span class="c">!!</span>
<a name="ln-1171"></a><span class="c">!! Used to define assignment for `bitset_large`.</span>
<a name="ln-1172"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1173"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1174"></a>        <span class="k">end subroutine </span><span class="n">assign_large</span>
<a name="ln-1175"></a>
<a name="ln-1176"></a>    <span class="err">#</span><span class="p">:</span><span class="n">for</span> <span class="n">k1</span> <span class="n">in</span> <span class="n">INT_KINDS</span>
<a name="ln-1177"></a>        <span class="k">pure module subroutine </span><span class="n">assign_log$</span><span class="err">{</span><span class="n">k1</span><span class="err">}$_</span><span class="n">large</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">logical_vector</span> <span class="p">)</span>
<a name="ln-1178"></a><span class="c">!! Version: experimental</span>
<a name="ln-1179"></a><span class="c">!!</span>
<a name="ln-1180"></a><span class="c">!! Used to define assignment from an array of type `logical(${k1}$)` to a</span>
<a name="ln-1181"></a><span class="c">!! `bitset_large`.</span>
<a name="ln-1182"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1183"></a>            <span class="kt">logical</span><span class="p">(</span><span class="err">${</span><span class="n">k1</span><span class="err">}$</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>       <span class="kd">::</span> <span class="n">logical_vector</span><span class="p">(:)</span>
<a name="ln-1184"></a>        <span class="k">end subroutine </span><span class="n">assign_log$</span><span class="err">{</span><span class="n">k1</span><span class="err">}$_</span><span class="n">large</span>
<a name="ln-1185"></a>
<a name="ln-1186"></a>        <span class="k">pure module subroutine </span><span class="nb">log</span><span class="err">${</span><span class="n">k1</span><span class="err">}$_</span><span class="n">assign_large</span><span class="p">(</span> <span class="n">logical_vector</span><span class="p">,</span> <span class="n">set</span> <span class="p">)</span>
<a name="ln-1187"></a><span class="c">!! Version: experimental</span>
<a name="ln-1188"></a><span class="c">!!</span>
<a name="ln-1189"></a><span class="c">!! Used to define assignment to an array of type `logical(${k1}$)` from a</span>
<a name="ln-1190"></a><span class="c">!! `bitset_large`.</span>
<a name="ln-1191"></a>            <span class="kt">logical</span><span class="p">(</span><span class="err">${</span><span class="n">k1</span><span class="err">}$</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">logical_vector</span><span class="p">(:)</span>
<a name="ln-1192"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>          <span class="kd">::</span> <span class="n">set</span>
<a name="ln-1193"></a>        <span class="k">end subroutine </span><span class="nb">log</span><span class="err">${</span><span class="n">k1</span><span class="err">}$_</span><span class="n">assign_large</span>
<a name="ln-1194"></a>    <span class="err">#</span><span class="p">:</span><span class="n">endfor</span>
<a name="ln-1195"></a>
<a name="ln-1196"></a>    <span class="k">end interface </span><span class="n">assignment</span><span class="p">(</span><span class="o">=</span><span class="p">)</span>
<a name="ln-1197"></a>
<a name="ln-1198"></a>
<a name="ln-1199"></a>    <span class="k">type</span><span class="p">,</span> <span class="k">extends</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bitset_64</span>
<a name="ln-1200"></a><span class="c">!! Version: experimental</span>
<a name="ln-1201"></a><span class="c">!!</span>
<a name="ln-1202"></a><span class="c">!! Type for bitsets with no more than 64 bits ([Specification](../page/specs/stdlib_bitsets.html#the-stdlib_bitsets-derived-types))</span>
<a name="ln-1203"></a>        <span class="k">private</span>
<a name="ln-1204"></a><span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">block_kind</span><span class="p">),</span> <span class="k">private</span> <span class="kd">::</span> <span class="k">block</span> <span class="o">=</span> <span class="mi">0</span>
<a name="ln-1205"></a>
<a name="ln-1206"></a>    <span class="k">contains</span>
<a name="ln-1207"></a>
<a name="ln-1208"></a><span class="k">        procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">all</span> <span class="o">=&gt;</span> <span class="n">all_64</span>
<a name="ln-1209"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="nb">any</span> <span class="o">=&gt;</span> <span class="n">any_64</span>
<a name="ln-1210"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">bit_count</span> <span class="o">=&gt;</span> <span class="n">bit_count_64</span>
<a name="ln-1211"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">clear_bit</span> <span class="o">=&gt;</span> <span class="n">clear_bit_64</span>
<a name="ln-1212"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">clear_range</span> <span class="o">=&gt;</span> <span class="n">clear_range_64</span>
<a name="ln-1213"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">flip_bit</span> <span class="o">=&gt;</span> <span class="n">flip_bit_64</span>
<a name="ln-1214"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">flip_range</span> <span class="o">=&gt;</span> <span class="n">flip_range_64</span>
<a name="ln-1215"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">from_string</span> <span class="o">=&gt;</span> <span class="n">from_string_64</span>
<a name="ln-1216"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">init_zero</span> <span class="o">=&gt;</span> <span class="n">init_zero_64</span>
<a name="ln-1217"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">input</span> <span class="o">=&gt;</span> <span class="n">input_64</span>
<a name="ln-1218"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">none</span> <span class="o">=&gt;</span> <span class="n">none_64</span>
<a name="ln-1219"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="nb">not</span> <span class="o">=&gt;</span> <span class="n">not_64</span>
<a name="ln-1220"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">output</span> <span class="o">=&gt;</span> <span class="n">output_64</span>
<a name="ln-1221"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">read_bitset_string</span> <span class="o">=&gt;</span> <span class="n">read_bitset_string_64</span>
<a name="ln-1222"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">read_bitset_unit</span> <span class="o">=&gt;</span> <span class="n">read_bitset_unit_64</span>
<a name="ln-1223"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set_bit</span> <span class="o">=&gt;</span> <span class="n">set_bit_64</span>
<a name="ln-1224"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set_range</span> <span class="o">=&gt;</span> <span class="n">set_range_64</span>
<a name="ln-1225"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">test</span> <span class="o">=&gt;</span> <span class="n">test_64</span>
<a name="ln-1226"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">to_string</span> <span class="o">=&gt;</span> <span class="n">to_string_64</span>
<a name="ln-1227"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="k">value</span> <span class="o">=&gt;</span> <span class="n">value_64</span>
<a name="ln-1228"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">write_bitset_string</span> <span class="o">=&gt;</span> <span class="n">write_bitset_string_64</span>
<a name="ln-1229"></a>        <span class="k">procedure</span><span class="p">,</span> <span class="k">pass</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">write_bitset_unit</span> <span class="o">=&gt;</span> <span class="n">write_bitset_unit_64</span>
<a name="ln-1230"></a>
<a name="ln-1231"></a>    <span class="k">end type </span><span class="n">bitset_64</span>
<a name="ln-1232"></a>
<a name="ln-1233"></a>
<a name="ln-1234"></a>    <span class="k">interface</span>
<a name="ln-1235"></a>
<a name="ln-1236"></a><span class="k">        elemental module function </span><span class="n">all_64</span><span class="p">(</span> <span class="n">self</span> <span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">all</span><span class="p">)</span>
<a name="ln-1237"></a><span class="c">!! Version: experimental</span>
<a name="ln-1238"></a><span class="c">!!</span>
<a name="ln-1239"></a><span class="c">!! Returns `.true.` if all bits in `self` are 1, `.false.` otherwise.</span>
<a name="ln-1240"></a>            <span class="kt">logical</span>                      <span class="kd">::</span> <span class="k">all</span>
<a name="ln-1241"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1242"></a>        <span class="k">end function </span><span class="n">all_64</span>
<a name="ln-1243"></a>
<a name="ln-1244"></a>        <span class="k">elemental module function </span><span class="n">any_64</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="nb">any</span><span class="p">)</span>
<a name="ln-1245"></a><span class="c">!! Version: experimental</span>
<a name="ln-1246"></a><span class="c">!!</span>
<a name="ln-1247"></a><span class="c">!! Returns `.true.` if any bit in `self` is 1, `.false.` otherwise.</span>
<a name="ln-1248"></a>            <span class="kt">logical</span>                      <span class="kd">::</span> <span class="nb">any</span>
<a name="ln-1249"></a><span class="nb">            </span><span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1250"></a>        <span class="k">end function </span><span class="n">any_64</span>
<a name="ln-1251"></a>
<a name="ln-1252"></a>        <span class="k">elemental module function </span><span class="n">bit_count_64</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">bit_count</span><span class="p">)</span>
<a name="ln-1253"></a><span class="c">!! Version: experimental</span>
<a name="ln-1254"></a><span class="c">!!</span>
<a name="ln-1255"></a><span class="c">!! Returns the number of non-zero bits in `self`.</span>
<a name="ln-1256"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">)</span>           <span class="kd">::</span> <span class="n">bit_count</span>
<a name="ln-1257"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1258"></a>        <span class="k">end function </span><span class="n">bit_count_64</span>
<a name="ln-1259"></a>
<a name="ln-1260"></a>        <span class="k">elemental module subroutine </span><span class="n">clear_bit_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-1261"></a><span class="c">!! Version: experimental</span>
<a name="ln-1262"></a><span class="c">!!</span>
<a name="ln-1263"></a><span class="c">!! Sets to zero the bit at `pos` position in `self`. If `pos` is less than</span>
<a name="ln-1264"></a><span class="c">!! zero or greater than `bits(self)-1` it is ignored.</span>
<a name="ln-1265"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1266"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1267"></a>        <span class="k">end subroutine </span><span class="n">clear_bit_64</span>
<a name="ln-1268"></a>
<a name="ln-1269"></a>        <span class="k">pure module subroutine </span><span class="n">clear_range_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-1270"></a><span class="c">!! Version: experimental</span>
<a name="ln-1271"></a><span class="c">!!</span>
<a name="ln-1272"></a><span class="c">!! Sets to zero all bits from the `start_pos` to `stop_pos` positions in `self`.</span>
<a name="ln-1273"></a><span class="c">!! If `stop_pos &lt; start_pos` then no bits are modified. Positions outside</span>
<a name="ln-1274"></a><span class="c">!! the range 0 to `bits(set)-1` are ignored.</span>
<a name="ln-1275"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1276"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1277"></a>        <span class="k">end subroutine </span><span class="n">clear_range_64</span>
<a name="ln-1278"></a>
<a name="ln-1279"></a>        <span class="k">elemental module subroutine </span><span class="n">flip_bit_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-1280"></a><span class="c">!! Version: experimental</span>
<a name="ln-1281"></a><span class="c">!!</span>
<a name="ln-1282"></a><span class="c">!! Flips the bit value at the `pos` position in `self`, provided the position is</span>
<a name="ln-1283"></a><span class="c">!! valid. If `pos` is less than 0 or greater than `bits(self)-1`, no value is</span>
<a name="ln-1284"></a><span class="c">!! changed.</span>
<a name="ln-1285"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1286"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1287"></a>        <span class="k">end subroutine </span><span class="n">flip_bit_64</span>
<a name="ln-1288"></a>
<a name="ln-1289"></a>        <span class="k">pure module subroutine </span><span class="n">flip_range_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-1290"></a><span class="c">!! Version: experimental</span>
<a name="ln-1291"></a><span class="c">!!</span>
<a name="ln-1292"></a><span class="c">!! Flips all valid bits from the `start_pos` to the `stop_pos` positions in</span>
<a name="ln-1293"></a><span class="c">!! `self`. If `stop_pos &lt; start_pos` no bits are flipped. Positions less than</span>
<a name="ln-1294"></a><span class="c">!! 0 or greater than `bits(self)-1` are ignored.</span>
<a name="ln-1295"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1296"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1297"></a>        <span class="k">end subroutine </span><span class="n">flip_range_64</span>
<a name="ln-1298"></a>
<a name="ln-1299"></a>        <span class="k">module subroutine </span><span class="n">from_string_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1300"></a><span class="c">!! Version: experimental</span>
<a name="ln-1301"></a><span class="c">!!</span>
<a name="ln-1302"></a><span class="c">!! Initializes the bitset `self` treating `string` as a binary literal</span>
<a name="ln-1303"></a><span class="c">!! `status` may have the values:</span>
<a name="ln-1304"></a><span class="c">!! * `success` - if no problems were found,</span>
<a name="ln-1305"></a><span class="c">!! * `alloc_fault` - if allocation of the bitset failed</span>
<a name="ln-1306"></a><span class="c">!! * `char_string_too_large_error` - if `string` was too large, or</span>
<a name="ln-1307"></a><span class="c">!! * `char_string_invalid_error` - if string had an invalid character.</span>
<a name="ln-1308"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1309"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>       <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1310"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1311"></a>        <span class="k">end subroutine </span><span class="n">from_string_64</span>
<a name="ln-1312"></a>
<a name="ln-1313"></a>        <span class="k">module subroutine </span><span class="n">init_zero_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1314"></a><span class="c">!! Version: experimental</span>
<a name="ln-1315"></a><span class="c">!!</span>
<a name="ln-1316"></a><span class="c">!! Creates the bitset, `self`, of size `bits`, with all bits initialized to</span>
<a name="ln-1317"></a><span class="c">!! zero. `bits` must be non-negative.  If an error occurs and `status` is</span>
<a name="ln-1318"></a><span class="c">!! absent then processing stops with an informative stop code. `status`</span>
<a name="ln-1319"></a><span class="c">!! will have one of the values:</span>
<a name="ln-1320"></a><span class="c">!! * `success` -  if no problems were found,</span>
<a name="ln-1321"></a><span class="c">!! * `alloc_fault` - if memory allocation failed</span>
<a name="ln-1322"></a><span class="c">!! * `array_size_invalid_error` - if `bits` is either negative or larger</span>
<a name="ln-1323"></a><span class="c">!!   than 64 with `self` of class `bitset_64`.</span>
<a name="ln-1324"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1325"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bits</span>
<a name="ln-1326"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1327"></a>        <span class="k">end subroutine </span><span class="n">init_zero_64</span>
<a name="ln-1328"></a>
<a name="ln-1329"></a>        <span class="k">module subroutine </span><span class="n">input_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1330"></a><span class="c">!! Version: experimental</span>
<a name="ln-1331"></a><span class="c">!!</span>
<a name="ln-1332"></a><span class="c">!! Reads the components of the bitset, `self`, from the unformatted I/O</span>
<a name="ln-1333"></a><span class="c">!! unit, `unit`, assuming that the components were written using `output`.</span>
<a name="ln-1334"></a><span class="c">!! If an error occurs and `status` is absent then processing stops with</span>
<a name="ln-1335"></a><span class="c">!! an informative stop code. `status` has one of the values:</span>
<a name="ln-1336"></a><span class="c">!! * `success` - if no problem was found</span>
<a name="ln-1337"></a><span class="c">!! * `alloc_fault` - if it failed allocating memory for `self`, or</span>
<a name="ln-1338"></a><span class="c">!! * `array_size_invalid_error` if the `bits(self)` in `unit` is negative</span>
<a name="ln-1339"></a><span class="c">!!   or greater than 64 for a `bitset_64` input.</span>
<a name="ln-1340"></a><span class="c">!! * `read_failure` - if it failed during the reads from `unit`</span>
<a name="ln-1341"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1342"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1343"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1344"></a>        <span class="k">end subroutine </span><span class="n">input_64</span>
<a name="ln-1345"></a>
<a name="ln-1346"></a>        <span class="k">elemental module function </span><span class="n">none_64</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">none</span><span class="p">)</span>
<a name="ln-1347"></a><span class="c">!! Version: experimental</span>
<a name="ln-1348"></a><span class="c">!!</span>
<a name="ln-1349"></a><span class="c">!! Returns `.true.` if none of the bits in `self` have the value 1.</span>
<a name="ln-1350"></a>            <span class="kt">logical</span> <span class="kd">::</span>  <span class="k">none</span>
<a name="ln-1351"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1352"></a>        <span class="k">end function </span><span class="n">none_64</span>
<a name="ln-1353"></a>
<a name="ln-1354"></a>        <span class="k">elemental module subroutine </span><span class="n">not_64</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<a name="ln-1355"></a><span class="c">!! Version: experimental</span>
<a name="ln-1356"></a><span class="c">!!</span>
<a name="ln-1357"></a><span class="c">!! Sets the bits in `self` to their logical complement.</span>
<a name="ln-1358"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1359"></a>        <span class="k">end subroutine </span><span class="n">not_64</span>
<a name="ln-1360"></a>
<a name="ln-1361"></a>        <span class="k">module subroutine </span><span class="n">output_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1362"></a><span class="c">!! Version: experimental</span>
<a name="ln-1363"></a><span class="c">!!</span>
<a name="ln-1364"></a><span class="c">!! Writes the components of the bitset, `self`, to the unformatted I/O</span>
<a name="ln-1365"></a><span class="c">!! unit, `unit`, in a unformatted sequence compatible with `input`. If</span>
<a name="ln-1366"></a><span class="c">!! `status` is absent an error results in an error stop with an</span>
<a name="ln-1367"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-1368"></a><span class="c">!! value of `success`, or the value `write_failure` if the write failed.</span>
<a name="ln-1369"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1370"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1371"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1372"></a>        <span class="k">end subroutine </span><span class="n">output_64</span>
<a name="ln-1373"></a>
<a name="ln-1374"></a>        <span class="k">module subroutine </span><span class="n">read_bitset_string_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1375"></a><span class="c">!! Version: experimental</span>
<a name="ln-1376"></a><span class="c">!!</span>
<a name="ln-1377"></a><span class="c">!! Uses the bitset literal in the default character `string`, to define</span>
<a name="ln-1378"></a><span class="c">!! the bitset, `self`. The literal may be preceded by an an arbitrary</span>
<a name="ln-1379"></a><span class="c">!! sequence of blank characters. If `status` is absent an error results</span>
<a name="ln-1380"></a><span class="c">!! in an error stop with an informative stop code. If `status`</span>
<a name="ln-1381"></a><span class="c">!! is present it has one of the values:</span>
<a name="ln-1382"></a><span class="c">!! * `success` - if no problems occurred,</span>
<a name="ln-1383"></a><span class="c">!! * `alloc_fault` - if allocation of memory for SELF failed,</span>
<a name="ln-1384"></a><span class="c">!! * `array_size_invalid_error - if `bits(self)` in `string` is greater</span>
<a name="ln-1385"></a><span class="c">!!   than 64 for a `bitset_64`,</span>
<a name="ln-1386"></a><span class="c">!! * `char_string_invalid_error` - if the bitset literal has an invalid</span>
<a name="ln-1387"></a><span class="c">!!   character,</span>
<a name="ln-1388"></a><span class="c">!! * `char_string_too_small_error - if the string ends before all the bits</span>
<a name="ln-1389"></a><span class="c">!!   are read.</span>
<a name="ln-1390"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-1391"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-1392"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1393"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1394"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1395"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_string_64</span>
<a name="ln-1396"></a>
<a name="ln-1397"></a>        <span class="k">module subroutine </span><span class="n">read_bitset_unit_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1398"></a><span class="c">!! Version: experimental</span>
<a name="ln-1399"></a><span class="c">!!</span>
<a name="ln-1400"></a><span class="c">!! Uses the bitset literal at the current position in the formatted</span>
<a name="ln-1401"></a><span class="c">!! file with I/O unit, `unit`, to define the bitset, `self`. The literal</span>
<a name="ln-1402"></a><span class="c">!! may be preceded by an an arbitrary sequence of blank characters.</span>
<a name="ln-1403"></a><span class="c">!! If `advance` is present it must be either &#39;YES&#39; or &#39;NO&#39;. If absent</span>
<a name="ln-1404"></a><span class="c">!! it has the default value of &#39;YES&#39; to determine whether advancing</span>
<a name="ln-1405"></a><span class="c">!! I/O occurs. If `status` is absent an error results in an error stop</span>
<a name="ln-1406"></a><span class="c">!! with an informative stop code. If `status` is present it has one of</span>
<a name="ln-1407"></a><span class="c">!! the values:</span>
<a name="ln-1408"></a><span class="c">!! * `success` - if no problem occurred,</span>
<a name="ln-1409"></a><span class="c">!! * `alloc_fault` - if allocation of `self` failed,</span>
<a name="ln-1410"></a><span class="c">!! * `array_size_invalid_error` - if `bits(self)` in the bitset literal</span>
<a name="ln-1411"></a><span class="c">!!   is greater than 64 for a `bitset_64`,</span>
<a name="ln-1412"></a><span class="c">!! * `char_string_invalid_error` - if the read of the bitset literal found</span>
<a name="ln-1413"></a><span class="c">!!   an invalid character,</span>
<a name="ln-1414"></a><span class="c">!! * `eof_failure` - if a `read` statement reached an end-of-file before</span>
<a name="ln-1415"></a><span class="c">!!   completing the read of the bitset literal,</span>
<a name="ln-1416"></a><span class="c">!! * `integer_overflow_error` - if the bitset literal has a `bits(self)`</span>
<a name="ln-1417"></a><span class="c">!!   value too large to be represented,</span>
<a name="ln-1418"></a><span class="c">!! * `read_failure` - if a `read` statement fails,</span>
<a name="ln-1419"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>      <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1420"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1421"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-1422"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>     <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1423"></a>        <span class="k">end subroutine </span><span class="n">read_bitset_unit_64</span>
<a name="ln-1424"></a>
<a name="ln-1425"></a>        <span class="k">elemental module subroutine </span><span class="n">set_bit_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<a name="ln-1426"></a><span class="c">!! Version: experimental</span>
<a name="ln-1427"></a><span class="c">!!</span>
<a name="ln-1428"></a><span class="c">!! Sets the value at the `pos` position in `self`, provided the position is</span>
<a name="ln-1429"></a><span class="c">!! valid. If the position is less than 0 or greater than `bits(self)-1`</span>
<a name="ln-1430"></a><span class="c">!! then `self` is unchanged.</span>
<a name="ln-1431"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1432"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1433"></a>        <span class="k">end subroutine </span><span class="n">set_bit_64</span>
<a name="ln-1434"></a>
<a name="ln-1435"></a>        <span class="k">pure module subroutine </span><span class="n">set_range_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">)</span>
<a name="ln-1436"></a><span class="c">!! Version: experimental</span>
<a name="ln-1437"></a><span class="c">!!</span>
<a name="ln-1438"></a><span class="c">!! Sets all valid bits to 1 from the `start_pos` to the `stop_pos` positions</span>
<a name="ln-1439"></a><span class="c">!! in `self`. If `stop_pos &lt; start_pos` no bits are changed. Positions outside</span>
<a name="ln-1440"></a><span class="c">!! the range 0 to `bits(self)-1` are ignored.</span>
<a name="ln-1441"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1442"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1443"></a>        <span class="k">end subroutine </span><span class="n">set_range_64</span>
<a name="ln-1444"></a>
<a name="ln-1445"></a>        <span class="k">elemental module function </span><span class="n">test_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<a name="ln-1446"></a><span class="c">!! Version: experimental</span>
<a name="ln-1447"></a><span class="c">!!</span>
<a name="ln-1448"></a><span class="c">!! Returns `.true.` if the `pos` position is set, `.false.` otherwise. If `pos`</span>
<a name="ln-1449"></a><span class="c">!! is negative or greater than `bits(self)-1` the result is `.false.`.</span>
<a name="ln-1450"></a>            <span class="kt">logical</span> <span class="kd">::</span>  <span class="n">test</span>
<a name="ln-1451"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1452"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1453"></a>        <span class="k">end function </span><span class="n">test_64</span>
<a name="ln-1454"></a>
<a name="ln-1455"></a>        <span class="k">module subroutine </span><span class="n">to_string_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1456"></a><span class="c">!! Version: experimental</span>
<a name="ln-1457"></a><span class="c">!!</span>
<a name="ln-1458"></a><span class="c">!! Represents the value of `self` as a binary literal in `string`.</span>
<a name="ln-1459"></a><span class="c">!! Status may have the values `success` or `alloc_fault`</span>
<a name="ln-1460"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>               <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1461"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="p">:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1462"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>             <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1463"></a>        <span class="k">end subroutine </span><span class="n">to_string_64</span>
<a name="ln-1464"></a>
<a name="ln-1465"></a>        <span class="k">elemental module function </span><span class="n">value_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>
<a name="ln-1466"></a><span class="c">!! Version: experimental</span>
<a name="ln-1467"></a><span class="c">!!</span>
<a name="ln-1468"></a><span class="c">!! Returns 1 if the `pos` position is set, 0 otherwise. If `pos` is negative</span>
<a name="ln-1469"></a><span class="c">!! or greater than `bits(set)-1` the result is 0.</span>
<a name="ln-1470"></a>            <span class="kt">integer</span> <span class="kd">::</span>  <span class="k">value</span>
<a name="ln-1471"></a><span class="k">            class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1472"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span>
<a name="ln-1473"></a>        <span class="k">end function </span><span class="n">value_64</span>
<a name="ln-1474"></a>
<a name="ln-1475"></a>        <span class="k">module subroutine </span><span class="n">write_bitset_string_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1476"></a><span class="c">!! Version: experimental</span>
<a name="ln-1477"></a><span class="c">!!</span>
<a name="ln-1478"></a><span class="c">!! Writes a bitset literal to the allocatable default character `string`,</span>
<a name="ln-1479"></a><span class="c">!! representing the individual bit values in the `bitset_64`, `self`.</span>
<a name="ln-1480"></a><span class="c">!! If `status` is absent an error results in an error stop with an</span>
<a name="ln-1481"></a><span class="c">!! informative stop code. If `status` is present it has the default</span>
<a name="ln-1482"></a><span class="c">!! value of `success`, or the value `alloc_fault` if allocation of</span>
<a name="ln-1483"></a><span class="c">!! the output string failed.</span>
<a name="ln-1484"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>               <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1485"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="p">:),</span> <span class="k">allocatable</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">string</span>
<a name="ln-1486"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>             <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1487"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_string_64</span>
<a name="ln-1488"></a>
<a name="ln-1489"></a>        <span class="k">module subroutine </span><span class="n">write_bitset_unit_64</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">advance</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1490"></a><span class="c">!! Version: experimental</span>
<a name="ln-1491"></a><span class="c">!!</span>
<a name="ln-1492"></a><span class="c">!! Writes a bitset literal to the I/O unit, `unit`, representing the</span>
<a name="ln-1493"></a><span class="c">!! individual bit values in the bitset, `self`. By default or if</span>
<a name="ln-1494"></a><span class="c">!! `advance` is present with the value &#39;YES&#39;, advancing output is used.</span>
<a name="ln-1495"></a><span class="c">!! If `advance` is present with the value &#39;NO&#39;, then the current record</span>
<a name="ln-1496"></a><span class="c">!! is not advanced by the write. If `status` is absent an error results</span>
<a name="ln-1497"></a><span class="c">!! in an error stop with an informative stop code. If `status` is</span>
<a name="ln-1498"></a><span class="c">!! present it has the default value of `success`, the value</span>
<a name="ln-1499"></a><span class="c">!! `alloc_fault` if allocation of the output string failed, or</span>
<a name="ln-1500"></a><span class="c">!! `write_failure` if the `write` statement outputting the literal failed.</span>
<a name="ln-1501"></a>            <span class="k">class</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>           <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1502"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                    <span class="kd">::</span> <span class="n">unit</span>
<a name="ln-1503"></a>            <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">advance</span>
<a name="ln-1504"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>         <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1505"></a>        <span class="k">end subroutine </span><span class="n">write_bitset_unit_64</span>
<a name="ln-1506"></a>
<a name="ln-1507"></a>    <span class="k">end interface</span>
<a name="ln-1508"></a>
<a name="ln-1509"></a>
<a name="ln-1510"></a><span class="k">    interface </span><span class="n">assignment</span><span class="p">(</span><span class="o">=</span><span class="p">)</span>
<a name="ln-1511"></a>
<a name="ln-1512"></a>        <span class="k">pure module subroutine </span><span class="n">assign_64</span><span class="p">(</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span> <span class="p">)</span>
<a name="ln-1513"></a><span class="c">!! Version: experimental</span>
<a name="ln-1514"></a><span class="c">!!</span>
<a name="ln-1515"></a><span class="c">!! Used to define assignment for `bitset_64`.</span>
<a name="ln-1516"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1517"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1518"></a>        <span class="k">end subroutine </span><span class="n">assign_64</span>
<a name="ln-1519"></a>
<a name="ln-1520"></a>    <span class="err">#</span><span class="p">:</span><span class="n">for</span> <span class="n">k1</span> <span class="n">in</span> <span class="n">INT_KINDS</span>
<a name="ln-1521"></a>        <span class="k">module subroutine </span><span class="n">assign_log$</span><span class="err">{</span><span class="n">k1</span><span class="err">}$_</span><span class="mi">64</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">logical_vector</span> <span class="p">)</span>
<a name="ln-1522"></a><span class="c">!! Version: experimental</span>
<a name="ln-1523"></a><span class="c">!!</span>
<a name="ln-1524"></a><span class="c">!! Used to define assignment from an array of type `logical(${k1}$)` to a</span>
<a name="ln-1525"></a><span class="c">!! `bitset_64`.</span>
<a name="ln-1526"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-1527"></a>            <span class="kt">logical</span><span class="p">(</span><span class="err">${</span><span class="n">k1</span><span class="err">}$</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">logical_vector</span><span class="p">(:)</span>
<a name="ln-1528"></a>        <span class="k">end subroutine </span><span class="n">assign_log$</span><span class="err">{</span><span class="n">k1</span><span class="err">}$_</span><span class="mi">64</span>
<a name="ln-1529"></a>
<a name="ln-1530"></a>        <span class="k">pure module subroutine </span><span class="nb">log</span><span class="err">${</span><span class="n">k1</span><span class="err">}$_</span><span class="n">assign_64</span><span class="p">(</span> <span class="n">logical_vector</span><span class="p">,</span> <span class="n">set</span> <span class="p">)</span>
<a name="ln-1531"></a><span class="c">!! Version: experimental</span>
<a name="ln-1532"></a><span class="c">!!</span>
<a name="ln-1533"></a><span class="c">!! Used to define assignment to an array of type `logical(${k1}$)` from a</span>
<a name="ln-1534"></a><span class="c">!! `bitset_64`.</span>
<a name="ln-1535"></a>            <span class="kt">logical</span><span class="p">(</span><span class="err">${</span><span class="n">k1</span><span class="err">}$</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">logical_vector</span><span class="p">(:)</span>
<a name="ln-1536"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>             <span class="kd">::</span> <span class="n">set</span>
<a name="ln-1537"></a>        <span class="k">end subroutine </span><span class="nb">log</span><span class="err">${</span><span class="n">k1</span><span class="err">}$_</span><span class="n">assign_64</span>
<a name="ln-1538"></a>    <span class="err">#</span><span class="p">:</span><span class="n">endfor</span>
<a name="ln-1539"></a>
<a name="ln-1540"></a>    <span class="k">end interface </span><span class="n">assignment</span><span class="p">(</span><span class="o">=</span><span class="p">)</span>
<a name="ln-1541"></a>
<a name="ln-1542"></a>
<a name="ln-1543"></a>    <span class="k">interface </span><span class="nb">and</span>
<a name="ln-1544"></a><span class="c">!! Version: experimental</span>
<a name="ln-1545"></a><span class="c">!!</span>
<a name="ln-1546"></a><span class="c">!! Sets the bits in `set1` to the bitwise `and` of the original bits in `set1`</span>
<a name="ln-1547"></a><span class="c">!! and `set2`. The sets must have the same number of bits</span>
<a name="ln-1548"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1549"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#and-bitwise-and-of-the-bits-of-two-bitsets))</span>
<a name="ln-1550"></a><span class="c">!!</span>
<a name="ln-1551"></a><span class="c">!!#### Example</span>
<a name="ln-1552"></a><span class="c">!!</span>
<a name="ln-1553"></a><span class="c">!!```fortran</span>
<a name="ln-1554"></a><span class="c">!!    program demo_and</span>
<a name="ln-1555"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1556"></a><span class="c">!!        type(bitset_large) :: set0, set1</span>
<a name="ln-1557"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-1558"></a><span class="c">!!        call set1 % init(166)</span>
<a name="ln-1559"></a><span class="c">!!        call and( set0, set1 ) ! none none</span>
<a name="ln-1560"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;First test of AND worked.&#39;</span>
<a name="ln-1561"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1562"></a><span class="c">!!        call and( set0, set1 ) ! all none</span>
<a name="ln-1563"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;Second test of AND worked.&#39;</span>
<a name="ln-1564"></a><span class="c">!!        call set1 % not()</span>
<a name="ln-1565"></a><span class="c">!!        call and( set0, set1 ) ! none all</span>
<a name="ln-1566"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;Third test of AND worked.&#39;</span>
<a name="ln-1567"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1568"></a><span class="c">!!        call and( set0, set1 ) ! all all</span>
<a name="ln-1569"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Fourth test of AND worked.&#39;</span>
<a name="ln-1570"></a><span class="c">!!    end program demo_and</span>
<a name="ln-1571"></a><span class="c">!!```</span>
<a name="ln-1572"></a>        <span class="k">elemental module subroutine </span><span class="n">and_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1573"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1574"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1575"></a>        <span class="k">end subroutine </span><span class="n">and_large</span>
<a name="ln-1576"></a>
<a name="ln-1577"></a>        <span class="k">elemental module subroutine </span><span class="n">and_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1578"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1579"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1580"></a>        <span class="k">end subroutine </span><span class="n">and_64</span>
<a name="ln-1581"></a>
<a name="ln-1582"></a>    <span class="k">end interface </span><span class="nb">and</span>
<a name="ln-1583"></a>
<a name="ln-1584"></a>
<a name="ln-1585"></a><span class="nb">    </span><span class="k">interface </span><span class="n">and_not</span>
<a name="ln-1586"></a><span class="c">!! Version: experimental</span>
<a name="ln-1587"></a><span class="c">!!</span>
<a name="ln-1588"></a><span class="c">!! Sets the bits in `set1` to the bitwise and of the original bits in `set1`</span>
<a name="ln-1589"></a><span class="c">!! with the bitwise negation of `set2`. The sets must have the same</span>
<a name="ln-1590"></a><span class="c">!! number of bits otherwise the result is undefined.</span>
<a name="ln-1591"></a><span class="c">!!</span>
<a name="ln-1592"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#and_not-bitwise-and-of-one-bitset-with-the-negation-of-another))</span>
<a name="ln-1593"></a><span class="c">!!</span>
<a name="ln-1594"></a><span class="c">!!#### Example</span>
<a name="ln-1595"></a><span class="c">!!</span>
<a name="ln-1596"></a><span class="c">!!```fortran</span>
<a name="ln-1597"></a><span class="c">!!    program demo_and_not</span>
<a name="ln-1598"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1599"></a><span class="c">!!        type(bitset_large) :: set0, set1</span>
<a name="ln-1600"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-1601"></a><span class="c">!!        call set1 % init(166)</span>
<a name="ln-1602"></a><span class="c">!!        call and_not( set0, set1 ) ! none none</span>
<a name="ln-1603"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;First test of AND_NOT worked.&#39;</span>
<a name="ln-1604"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1605"></a><span class="c">!!        call and_not( set0, set1 ) ! all none</span>
<a name="ln-1606"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Second test of AND_NOT worked.&#39;</span>
<a name="ln-1607"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1608"></a><span class="c">!!        call set1 % not()</span>
<a name="ln-1609"></a><span class="c">!!        call and_not( set0, set1 ) ! none all</span>
<a name="ln-1610"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;Third test of AND_NOT worked.&#39;</span>
<a name="ln-1611"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1612"></a><span class="c">!!        call and_not( set0, set1 ) ! all all</span>
<a name="ln-1613"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;Fourth test of AND_NOT worked.&#39;</span>
<a name="ln-1614"></a><span class="c">!!    end program demo_and_not</span>
<a name="ln-1615"></a><span class="c">!!```</span>
<a name="ln-1616"></a>
<a name="ln-1617"></a>        <span class="k">elemental module subroutine </span><span class="n">and_not_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1618"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1619"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1620"></a>        <span class="k">end subroutine </span><span class="n">and_not_large</span>
<a name="ln-1621"></a>
<a name="ln-1622"></a>        <span class="k">elemental module subroutine </span><span class="n">and_not_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1623"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1624"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1625"></a>        <span class="k">end subroutine </span><span class="n">and_not_64</span>
<a name="ln-1626"></a>
<a name="ln-1627"></a>    <span class="k">end interface </span><span class="n">and_not</span>
<a name="ln-1628"></a>
<a name="ln-1629"></a>    <span class="k">interface </span><span class="n">extract</span>
<a name="ln-1630"></a><span class="c">!! Version: experimental</span>
<a name="ln-1631"></a><span class="c">!!</span>
<a name="ln-1632"></a><span class="c">!! Creates a new bitset, `new`, from a range, `start_pos` to `stop_pos`, in</span>
<a name="ln-1633"></a><span class="c">!! bitset `old`. If `start_pos` is greater than `stop_pos` the new bitset is</span>
<a name="ln-1634"></a><span class="c">!! empty. If `start_pos` is less than zero or `stop_pos` is greater than</span>
<a name="ln-1635"></a><span class="c">!! `bits(old)-1` then if `status` is present it has the value</span>
<a name="ln-1636"></a><span class="c">!! `index_invalid_error` and `new` is undefined, otherwise processing stops</span>
<a name="ln-1637"></a><span class="c">!! with an informative message.</span>
<a name="ln-1638"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#extract-create-a-new-bitset-from-a-range-in-an-old-bitset))</span>
<a name="ln-1639"></a><span class="c">!!</span>
<a name="ln-1640"></a><span class="c">!!#### Example</span>
<a name="ln-1641"></a><span class="c">!!</span>
<a name="ln-1642"></a><span class="c">!!```fortran</span>
<a name="ln-1643"></a><span class="c">!!    program demo_extract</span>
<a name="ln-1644"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1645"></a><span class="c">!!        type(bitset_large) :: set0, set1</span>
<a name="ln-1646"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-1647"></a><span class="c">!!        call set0 % set(100,150)</span>
<a name="ln-1648"></a><span class="c">!!        call extract( set1, set0, 100, 150)</span>
<a name="ln-1649"></a><span class="c">!!        if ( set1 % bits() == 51 ) &amp;</span>
<a name="ln-1650"></a><span class="c">!!            write(*,*) &#39;SET1 has the proper size.&#39;</span>
<a name="ln-1651"></a><span class="c">!!        if ( set1 % all() ) write(*,*) &#39;SET1 has the proper values.&#39;</span>
<a name="ln-1652"></a><span class="c">!!    end program demo_extract</span>
<a name="ln-1653"></a><span class="c">!!```</span>
<a name="ln-1654"></a>
<a name="ln-1655"></a>        <span class="k">module subroutine </span><span class="n">extract_large</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1656"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">new</span>
<a name="ln-1657"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">old</span>
<a name="ln-1658"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1659"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>  <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1660"></a>        <span class="k">end subroutine </span><span class="n">extract_large</span>
<a name="ln-1661"></a>
<a name="ln-1662"></a>       <span class="k">module subroutine </span><span class="n">extract_64</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<a name="ln-1663"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">new</span>
<a name="ln-1664"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">old</span>
<a name="ln-1665"></a>            <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">stop_pos</span>
<a name="ln-1666"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="n">status</span>
<a name="ln-1667"></a>        <span class="k">end subroutine </span><span class="n">extract_64</span>
<a name="ln-1668"></a>
<a name="ln-1669"></a>    <span class="k">end interface </span><span class="n">extract</span>
<a name="ln-1670"></a>
<a name="ln-1671"></a>
<a name="ln-1672"></a>    <span class="k">interface </span><span class="nb">or</span>
<a name="ln-1673"></a><span class="c">!! Version: experimental</span>
<a name="ln-1674"></a><span class="c">!!</span>
<a name="ln-1675"></a><span class="c">!! Sets the bits in `set1` to the bitwise `or` of the original bits in `set1`</span>
<a name="ln-1676"></a><span class="c">!! and `set2`. The sets must have the same number of bits otherwise</span>
<a name="ln-1677"></a><span class="c">!! the result is undefined.</span>
<a name="ln-1678"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#or-bitwise-or-of-the-bits-of-two-bitsets))</span>
<a name="ln-1679"></a><span class="c">!!</span>
<a name="ln-1680"></a><span class="c">!!#### Example</span>
<a name="ln-1681"></a><span class="c">!!</span>
<a name="ln-1682"></a><span class="c">!!```fortran</span>
<a name="ln-1683"></a><span class="c">!!    program demo_or</span>
<a name="ln-1684"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1685"></a><span class="c">!!        type(bitset_large) :: set0, set1</span>
<a name="ln-1686"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-1687"></a><span class="c">!!        call set1 % init(166)</span>
<a name="ln-1688"></a><span class="c">!!        call or( set0, set1 ) ! none none</span>
<a name="ln-1689"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;First test of OR worked.&#39;</span>
<a name="ln-1690"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1691"></a><span class="c">!!        call or( set0, set1 ) ! all none</span>
<a name="ln-1692"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Second test of OR worked.&#39;</span>
<a name="ln-1693"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1694"></a><span class="c">!!        call set1 % not()</span>
<a name="ln-1695"></a><span class="c">!!        call or( set0, set1 ) ! none all</span>
<a name="ln-1696"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Third test of OR worked.&#39;</span>
<a name="ln-1697"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1698"></a><span class="c">!!        call or( set0, set1 ) ! all all</span>
<a name="ln-1699"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Fourth test of OR worked.&#39;</span>
<a name="ln-1700"></a><span class="c">!!    end program demo_or</span>
<a name="ln-1701"></a><span class="c">!!```</span>
<a name="ln-1702"></a>        <span class="k">elemental module subroutine </span><span class="n">or_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1703"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1704"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1705"></a>        <span class="k">end subroutine </span><span class="n">or_large</span>
<a name="ln-1706"></a>
<a name="ln-1707"></a>        <span class="k">elemental module subroutine </span><span class="n">or_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1708"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1709"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1710"></a>        <span class="k">end subroutine </span><span class="n">or_64</span>
<a name="ln-1711"></a>
<a name="ln-1712"></a>    <span class="k">end interface </span><span class="nb">or</span>
<a name="ln-1713"></a>
<a name="ln-1714"></a>
<a name="ln-1715"></a><span class="nb">    </span><span class="k">interface </span><span class="nb">xor</span>
<a name="ln-1716"></a><span class="c">!! Version: experimental</span>
<a name="ln-1717"></a><span class="c">!!</span>
<a name="ln-1718"></a><span class="c">!! Sets the bits in `set1` to the bitwise `xor` of the original bits in `set1`</span>
<a name="ln-1719"></a><span class="c">!! and `set2`. The sets must have the same number of bits</span>
<a name="ln-1720"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1721"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#xor-bitwise-exclusive-or))</span>
<a name="ln-1722"></a><span class="c">!!</span>
<a name="ln-1723"></a><span class="c">!!#### Example</span>
<a name="ln-1724"></a><span class="c">!!</span>
<a name="ln-1725"></a><span class="c">!!```fortran</span>
<a name="ln-1726"></a><span class="c">!!    program demo_xor</span>
<a name="ln-1727"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1728"></a><span class="c">!!        type(bitset_large) :: set0, set1</span>
<a name="ln-1729"></a><span class="c">!!        call set0 % init(166)</span>
<a name="ln-1730"></a><span class="c">!!        call set1 % init(166)</span>
<a name="ln-1731"></a><span class="c">!!        call xor( set0, set1 ) ! none none</span>
<a name="ln-1732"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;First test of XOR worked.&#39;</span>
<a name="ln-1733"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1734"></a><span class="c">!!        call xor( set0, set1 ) ! all none</span>
<a name="ln-1735"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Second test of XOR worked.&#39;</span>
<a name="ln-1736"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1737"></a><span class="c">!!        call set1 % not()</span>
<a name="ln-1738"></a><span class="c">!!        call xor( set0, set1 ) ! none all</span>
<a name="ln-1739"></a><span class="c">!!        if ( all(set0) ) write(*,*) &#39;Third test of XOR worked.&#39;</span>
<a name="ln-1740"></a><span class="c">!!        call set0 % not()</span>
<a name="ln-1741"></a><span class="c">!!        call xor( set0, set1 ) ! all all</span>
<a name="ln-1742"></a><span class="c">!!        if ( none(set0) ) write(*,*) &#39;Fourth test of XOR worked.&#39;</span>
<a name="ln-1743"></a><span class="c">!!    end program demo_xor</span>
<a name="ln-1744"></a><span class="c">!!```</span>
<a name="ln-1745"></a>        <span class="k">elemental module subroutine </span><span class="n">xor_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1746"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1747"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1748"></a>        <span class="k">end subroutine </span><span class="n">xor_large</span>
<a name="ln-1749"></a>
<a name="ln-1750"></a>        <span class="k">elemental module subroutine </span><span class="n">xor_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<a name="ln-1751"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span>
<a name="ln-1752"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">set2</span>
<a name="ln-1753"></a>        <span class="k">end subroutine </span><span class="n">xor_64</span>
<a name="ln-1754"></a>
<a name="ln-1755"></a>    <span class="k">end interface </span><span class="nb">xor</span>
<a name="ln-1756"></a>
<a name="ln-1757"></a>
<a name="ln-1758"></a><span class="nb">    </span><span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">==</span><span class="p">)</span>
<a name="ln-1759"></a><span class="c">!! Version: experimental</span>
<a name="ln-1760"></a><span class="c">!!</span>
<a name="ln-1761"></a><span class="c">!! Returns `.true.` if all bits in `set1` and `set2` have the same value,</span>
<a name="ln-1762"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1763"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1764"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-the-bits-have-the-same-value))</span>
<a name="ln-1765"></a><span class="c">!!</span>
<a name="ln-1766"></a><span class="c">!!#### Example</span>
<a name="ln-1767"></a><span class="c">!!</span>
<a name="ln-1768"></a><span class="c">!!```fortran</span>
<a name="ln-1769"></a><span class="c">!!    program demo_equality</span>
<a name="ln-1770"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1771"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1772"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1773"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1774"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1775"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1776"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1777"></a><span class="c">!!        if ( set0 == set0 .and. set1 == set1 .and. set2 == set2 .and. &amp;</span>
<a name="ln-1778"></a><span class="c">!!            .not. set0 == set1 .and. .not. set0 == set2 .and. .not.   &amp;</span>
<a name="ln-1779"></a><span class="c">!!            set1 == set2 ) then</span>
<a name="ln-1780"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit equality tests.&#39;</span>
<a name="ln-1781"></a><span class="c">!!        else</span>
<a name="ln-1782"></a><span class="c">!!            error stop &#39;Failed 64 bit equality tests.&#39;</span>
<a name="ln-1783"></a><span class="c">!!        end if</span>
<a name="ln-1784"></a><span class="c">!!    end program demo_equality</span>
<a name="ln-1785"></a><span class="c">!!```</span>
<a name="ln-1786"></a>        <span class="k">elemental module function </span><span class="n">eqv_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">eqv</span><span class="p">)</span>
<a name="ln-1787"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">eqv</span>
<a name="ln-1788"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1789"></a>        <span class="k">end function </span><span class="n">eqv_large</span>
<a name="ln-1790"></a>
<a name="ln-1791"></a>        <span class="k">elemental module function </span><span class="n">eqv_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">eqv</span><span class="p">)</span>
<a name="ln-1792"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">eqv</span>
<a name="ln-1793"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1794"></a>        <span class="k">end function </span><span class="n">eqv_64</span>
<a name="ln-1795"></a>
<a name="ln-1796"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">==</span><span class="p">)</span>
<a name="ln-1797"></a>
<a name="ln-1798"></a>
<a name="ln-1799"></a>    <span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">/=</span><span class="p">)</span>
<a name="ln-1800"></a><span class="c">!! Version: experimental</span>
<a name="ln-1801"></a><span class="c">!!</span>
<a name="ln-1802"></a><span class="c">!! Returns `.true.` if not all bits in `set1` and `set2` have the same value,</span>
<a name="ln-1803"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1804"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1805"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#-compare-two-bitsets-to-determine-whether-any-bits-differ-in-value))</span>
<a name="ln-1806"></a><span class="c">!!</span>
<a name="ln-1807"></a><span class="c">!!#### Example</span>
<a name="ln-1808"></a><span class="c">!!</span>
<a name="ln-1809"></a><span class="c">!!```fortran</span>
<a name="ln-1810"></a><span class="c">!!    program demo_inequality</span>
<a name="ln-1811"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1812"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1813"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1814"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1815"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1816"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1817"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1818"></a><span class="c">!!        if ( set0 /= set1 .and. set0 /= set2 .and. set1 /= set2 .and. &amp;</span>
<a name="ln-1819"></a><span class="c">!!            .not. set0 /= set0 .and. .not. set1 /= set1 .and. .not.   &amp;</span>
<a name="ln-1820"></a><span class="c">!!            set2 /= set2 ) then</span>
<a name="ln-1821"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit inequality tests.&#39;</span>
<a name="ln-1822"></a><span class="c">!!        else</span>
<a name="ln-1823"></a><span class="c">!!            error stop &#39;Failed 64 bit inequality tests.&#39;</span>
<a name="ln-1824"></a><span class="c">!!        end if</span>
<a name="ln-1825"></a><span class="c">!!    end program demo_inequality</span>
<a name="ln-1826"></a><span class="c">!!```</span>
<a name="ln-1827"></a>        <span class="k">elemental module function </span><span class="n">neqv_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">neqv</span><span class="p">)</span>
<a name="ln-1828"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">neqv</span>
<a name="ln-1829"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1830"></a>        <span class="k">end function </span><span class="n">neqv_large</span>
<a name="ln-1831"></a>
<a name="ln-1832"></a>        <span class="k">elemental module function </span><span class="n">neqv_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">neqv</span><span class="p">)</span>
<a name="ln-1833"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">neqv</span>
<a name="ln-1834"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1835"></a>        <span class="k">end function </span><span class="n">neqv_64</span>
<a name="ln-1836"></a>
<a name="ln-1837"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">/=</span><span class="p">)</span>
<a name="ln-1838"></a>
<a name="ln-1839"></a>
<a name="ln-1840"></a>    <span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
<a name="ln-1841"></a><span class="c">!! Version: experimental</span>
<a name="ln-1842"></a><span class="c">!!</span>
<a name="ln-1843"></a><span class="c">!! Returns `.true.` if the bits in `set1` and `set2` differ and the</span>
<a name="ln-1844"></a><span class="c">!! highest order different bit is set to 1 in `set1` and to 0 in `set2`,</span>
<a name="ln-1845"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1846"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1847"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-the-other))</span>
<a name="ln-1848"></a><span class="c">!!</span>
<a name="ln-1849"></a><span class="c">!!#### Example</span>
<a name="ln-1850"></a><span class="c">!!</span>
<a name="ln-1851"></a><span class="c">!!```fortran</span>
<a name="ln-1852"></a><span class="c">!!    program demo_gt</span>
<a name="ln-1853"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1854"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1855"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1856"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1857"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1858"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1859"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1860"></a><span class="c">!!        if ( set1 &gt; set0 .and. set2 &gt; set1 .and. set2 &gt; set0 .and. &amp;</span>
<a name="ln-1861"></a><span class="c">!!            .not. set0 &gt; set0 .and. .not. set0 &gt; set1 .and. .not.   &amp;</span>
<a name="ln-1862"></a><span class="c">!!            set1 &gt; set2 ) then</span>
<a name="ln-1863"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit greater than tests.&#39;</span>
<a name="ln-1864"></a><span class="c">!!        else</span>
<a name="ln-1865"></a><span class="c">!!            error stop &#39;Failed 64 bit greater than tests.&#39;</span>
<a name="ln-1866"></a><span class="c">!!        end if</span>
<a name="ln-1867"></a><span class="c">!!    end program demo_gt</span>
<a name="ln-1868"></a><span class="c">!!```</span>
<a name="ln-1869"></a>        <span class="k">elemental module function </span><span class="n">gt_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">gt</span><span class="p">)</span>
<a name="ln-1870"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">gt</span>
<a name="ln-1871"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1872"></a>        <span class="k">end function </span><span class="n">gt_large</span>
<a name="ln-1873"></a>
<a name="ln-1874"></a>        <span class="k">elemental module function </span><span class="n">gt_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">gt</span><span class="p">)</span>
<a name="ln-1875"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">gt</span>
<a name="ln-1876"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1877"></a>        <span class="k">end function </span><span class="n">gt_64</span>
<a name="ln-1878"></a>
<a name="ln-1879"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
<a name="ln-1880"></a>
<a name="ln-1881"></a>
<a name="ln-1882"></a>    <span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">)</span>
<a name="ln-1883"></a><span class="c">!! Version: experimental</span>
<a name="ln-1884"></a><span class="c">!!</span>
<a name="ln-1885"></a><span class="c">!! Returns `.true.` if the bits in `set1` and `set2` are the same or the</span>
<a name="ln-1886"></a><span class="c">!! highest order different bit is set to 1 in `set1` and to 0 in `set2`,</span>
<a name="ln-1887"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1888"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1889"></a><span class="c">!! ([Specification](../page/specs/stdlib_bitsets.html#gt-compare-two-bitsets-to-determine-whether-the-first-is-greater-than-or-equal-to-the-second))</span>
<a name="ln-1890"></a><span class="c">!!</span>
<a name="ln-1891"></a><span class="c">!!#### Example</span>
<a name="ln-1892"></a><span class="c">!!</span>
<a name="ln-1893"></a><span class="c">!!```fortran</span>
<a name="ln-1894"></a><span class="c">!!    program demo_ge</span>
<a name="ln-1895"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1896"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1897"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1898"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1899"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1900"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1901"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1902"></a><span class="c">!!        if ( set1 &gt;= set0 .and. set2 &gt;= set1 .and. set2 &gt;= set0 .and. &amp;</span>
<a name="ln-1903"></a><span class="c">!!            set0 &gt;= set0 .and. set1 &gt;= set1 .and. set2 &gt;= set2 .and. &amp;</span>
<a name="ln-1904"></a><span class="c">!!            .not. set0 &gt;= set1 .and. .not. set0 &gt;= set2 .and. .not.   &amp;</span>
<a name="ln-1905"></a><span class="c">!!            set1 &gt;= set2 ) then</span>
<a name="ln-1906"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit greater than or equals tests.&#39;</span>
<a name="ln-1907"></a><span class="c">!!        else</span>
<a name="ln-1908"></a><span class="c">!!            error stop &#39;Failed 64 bit greater than or equals tests.&#39;</span>
<a name="ln-1909"></a><span class="c">!!        end if</span>
<a name="ln-1910"></a><span class="c">!!    end program demo_ge</span>
<a name="ln-1911"></a><span class="c">!!```</span>
<a name="ln-1912"></a>        <span class="k">elemental module function </span><span class="n">ge_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">ge</span><span class="p">)</span>
<a name="ln-1913"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">ge</span>
<a name="ln-1914"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1915"></a>        <span class="k">end function </span><span class="n">ge_large</span>
<a name="ln-1916"></a>
<a name="ln-1917"></a>        <span class="k">elemental module function </span><span class="n">ge_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">ge</span><span class="p">)</span>
<a name="ln-1918"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">ge</span>
<a name="ln-1919"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1920"></a>        <span class="k">end function </span><span class="n">ge_64</span>
<a name="ln-1921"></a>
<a name="ln-1922"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">)</span>
<a name="ln-1923"></a>
<a name="ln-1924"></a>
<a name="ln-1925"></a>    <span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
<a name="ln-1926"></a><span class="c">!! Version: experimental</span>
<a name="ln-1927"></a><span class="c">!!</span>
<a name="ln-1928"></a><span class="c">!! Returns `.true.` if the bits in `set1` and `set2` differ and the</span>
<a name="ln-1929"></a><span class="c">!! highest order different bit is set to 0 in `set1` and to 1 in `set2`,</span>
<a name="ln-1930"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1931"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1932"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-the-other))</span>
<a name="ln-1933"></a><span class="c">!!</span>
<a name="ln-1934"></a><span class="c">!!#### Example</span>
<a name="ln-1935"></a><span class="c">!!</span>
<a name="ln-1936"></a><span class="c">!!```fortran</span>
<a name="ln-1937"></a><span class="c">!!    program demo_lt</span>
<a name="ln-1938"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1939"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1940"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1941"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1942"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1943"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1944"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1945"></a><span class="c">!!        if ( set0 &lt; set1 .and. set1 &lt; set2 .and. set0 &lt; set2 .and. &amp;</span>
<a name="ln-1946"></a><span class="c">!!            .not. set0 &lt; set0 .and. .not. set2 &lt; set0 .and. .not.   &amp;</span>
<a name="ln-1947"></a><span class="c">!!            set2 &lt; set1 ) then</span>
<a name="ln-1948"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit less than tests.&#39;</span>
<a name="ln-1949"></a><span class="c">!!        else</span>
<a name="ln-1950"></a><span class="c">!!            error stop &#39;Failed 64 bit less than tests.&#39;</span>
<a name="ln-1951"></a><span class="c">!!        end if</span>
<a name="ln-1952"></a><span class="c">!!    end program demo_lt</span>
<a name="ln-1953"></a><span class="c">!!```</span>
<a name="ln-1954"></a>        <span class="k">elemental module function </span><span class="n">lt_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span>
<a name="ln-1955"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">lt</span>
<a name="ln-1956"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1957"></a>        <span class="k">end function </span><span class="n">lt_large</span>
<a name="ln-1958"></a>
<a name="ln-1959"></a>        <span class="k">elemental module function </span><span class="n">lt_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span>
<a name="ln-1960"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">lt</span>
<a name="ln-1961"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-1962"></a>        <span class="k">end function </span><span class="n">lt_64</span>
<a name="ln-1963"></a>
<a name="ln-1964"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
<a name="ln-1965"></a>
<a name="ln-1966"></a>
<a name="ln-1967"></a>    <span class="k">interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span>
<a name="ln-1968"></a><span class="c">!! Version: experimental</span>
<a name="ln-1969"></a><span class="c">!!</span>
<a name="ln-1970"></a><span class="c">!! Returns `.true.` if the bits in `set1` and `set2` are the same or the</span>
<a name="ln-1971"></a><span class="c">!! highest order different bit is set to 0 in `set1` and to 1 in `set2`,</span>
<a name="ln-1972"></a><span class="c">!! `.false.`  otherwise. The sets must have the same number of bits</span>
<a name="ln-1973"></a><span class="c">!! otherwise the result is undefined.</span>
<a name="ln-1974"></a><span class="c">!!([Specification](../page/specs/stdlib_bitsets.html#lt-compare-two-bitsets-to-determine-whether-the-first-is-less-than-or-equal-to-the-other))</span>
<a name="ln-1975"></a><span class="c">!!</span>
<a name="ln-1976"></a><span class="c">!!#### Example</span>
<a name="ln-1977"></a><span class="c">!!</span>
<a name="ln-1978"></a><span class="c">!!```fortran</span>
<a name="ln-1979"></a><span class="c">!!    program demo_le</span>
<a name="ln-1980"></a><span class="c">!!        use stdlib_bitsets</span>
<a name="ln-1981"></a><span class="c">!!        type(bitset_64) :: set0, set1, set2</span>
<a name="ln-1982"></a><span class="c">!!        call set0 % init( 33 )</span>
<a name="ln-1983"></a><span class="c">!!        call set1 % init( 33 )</span>
<a name="ln-1984"></a><span class="c">!!        call set2 % init( 33 )</span>
<a name="ln-1985"></a><span class="c">!!        call set1 % set( 0 )</span>
<a name="ln-1986"></a><span class="c">!!        call set2 % set( 32 )</span>
<a name="ln-1987"></a><span class="c">!!        if ( set0 &lt;= set1 .and. set1 &lt;= set2 .and. set0 &lt;= set2 .and. &amp;</span>
<a name="ln-1988"></a><span class="c">!!            set0 &lt;= set0 .and. set1 &lt;= set1 .and. set2 &lt;= set2 .and. &amp;</span>
<a name="ln-1989"></a><span class="c">!!            .not. set1 &lt;= set0 .and. .not. set2 &lt;= set0 .and. .not.   &amp;</span>
<a name="ln-1990"></a><span class="c">!!            set2 &lt;= set1 ) then</span>
<a name="ln-1991"></a><span class="c">!!            write(*,*) &#39;Passed 64 bit less than or equal tests.&#39;</span>
<a name="ln-1992"></a><span class="c">!!        else</span>
<a name="ln-1993"></a><span class="c">!!            error stop &#39;Failed 64 bit less than or equal tests.&#39;</span>
<a name="ln-1994"></a><span class="c">!!        end if</span>
<a name="ln-1995"></a><span class="c">!!    end program demo_le</span>
<a name="ln-1996"></a><span class="c">!!```</span>
<a name="ln-1997"></a>        <span class="k">elemental module function </span><span class="n">le_large</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">le</span><span class="p">)</span>
<a name="ln-1998"></a>            <span class="kt">logical</span>                        <span class="kd">::</span> <span class="n">le</span>
<a name="ln-1999"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_large</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-2000"></a>        <span class="k">end function </span><span class="n">le_large</span>
<a name="ln-2001"></a>
<a name="ln-2002"></a>        <span class="k">elemental module function </span><span class="n">le_64</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">le</span><span class="p">)</span>
<a name="ln-2003"></a>            <span class="kt">logical</span>                     <span class="kd">::</span> <span class="n">le</span>
<a name="ln-2004"></a>            <span class="k">type</span><span class="p">(</span><span class="n">bitset_64</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span>
<a name="ln-2005"></a>        <span class="k">end function </span><span class="n">le_64</span>
<a name="ln-2006"></a>
<a name="ln-2007"></a>    <span class="k">end interface </span><span class="n">operator</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span>
<a name="ln-2008"></a>
<a name="ln-2009"></a>    <span class="k">interface </span><span class="n">error_handler</span>
<a name="ln-2010"></a>        <span class="k">module subroutine </span><span class="n">error_handler</span><span class="p">(</span> <span class="n">message</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="p">&amp;</span>
<a name="ln-2011"></a>            <span class="k">module</span><span class="p">,</span> <span class="k">procedure</span> <span class="p">)</span>
<a name="ln-2012"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>           <span class="kd">::</span> <span class="n">message</span>
<a name="ln-2013"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">error</span>
<a name="ln-2014"></a>            <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>     <span class="kd">::</span> <span class="n">status</span>
<a name="ln-2015"></a>            <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="k">module</span>
<a name="ln-2016"></a><span class="k">            </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="k">procedure</span>
<a name="ln-2017"></a><span class="k">        end subroutine </span><span class="n">error_handler</span>
<a name="ln-2018"></a>    <span class="k">end interface </span><span class="n">error_handler</span>
<a name="ln-2019"></a>
<a name="ln-2020"></a><span class="k">contains</span>
<a name="ln-2021"></a>
<a name="ln-2022"></a><span class="k">    elemental function </span><span class="n">bits</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<a name="ln-2023"></a><span class="c">!! Version: experimental</span>
<a name="ln-2024"></a><span class="c">!!</span>
<a name="ln-2025"></a><span class="c">!! Returns the number of bit positions in `self`.</span>
<a name="ln-2026"></a>       <span class="kt">integer</span><span class="p">(</span><span class="n">bits_kind</span><span class="p">)</span>             <span class="kd">::</span> <span class="n">bits</span>
<a name="ln-2027"></a>       <span class="k">class</span><span class="p">(</span><span class="n">bitset_type</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">self</span>
<a name="ln-2028"></a>
<a name="ln-2029"></a>       <span class="n">bits</span> <span class="o">=</span> <span class="n">self</span> <span class="p">%</span> <span class="n">num_bits</span>
<a name="ln-2030"></a>
<a name="ln-2031"></a>       <span class="k">return</span>
<a name="ln-2032"></a><span class="k">    end function </span><span class="n">bits</span>
<a name="ln-2033"></a>
<a name="ln-2034"></a>    <span class="k">module subroutine </span><span class="n">error_handler</span><span class="p">(</span> <span class="n">message</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="k">module</span><span class="p">,</span> <span class="k">procedure</span> <span class="p">)</span>
<a name="ln-2035"></a>        <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>           <span class="kd">::</span> <span class="n">message</span>
<a name="ln-2036"></a>        <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">error</span>
<a name="ln-2037"></a>        <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="k">optional</span>     <span class="kd">::</span> <span class="n">status</span>
<a name="ln-2038"></a>        <span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="k">module</span>
<a name="ln-2039"></a><span class="k">        </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">optional</span> <span class="kd">::</span> <span class="k">procedure</span>
<a name="ln-2040"></a>
<a name="ln-2041"></a><span class="k">        if</span> <span class="p">(</span> <span class="nb">present</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<a name="ln-2042"></a><span class="k">            </span><span class="n">status</span> <span class="o">=</span> <span class="n">error</span>
<a name="ln-2043"></a>        <span class="k">else</span>
<a name="ln-2044"></a><span class="k">            if</span> <span class="p">(</span> <span class="nb">present</span><span class="p">(</span><span class="k">module</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<a name="ln-2045"></a><span class="k">                if</span> <span class="p">(</span> <span class="nb">present</span><span class="p">(</span><span class="k">procedure</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<a name="ln-2046"></a><span class="k">                    write</span><span class="p">(</span><span class="n">error_unit</span><span class="p">,</span> <span class="s1">&#39;(a)&#39;</span><span class="p">)</span> <span class="nb">trim</span><span class="p">(</span><span class="k">module</span><span class="p">)</span> <span class="o">//</span> <span class="s1">&#39; % &#39;</span> <span class="o">//</span> <span class="p">&amp;</span>
<a name="ln-2047"></a>                        <span class="nb">trim</span><span class="p">(</span><span class="k">procedure</span><span class="p">)</span> <span class="o">//</span> <span class="s1">&#39;: &#39;</span> <span class="o">//</span> <span class="nb">trim</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<a name="ln-2048"></a>                <span class="k">else</span>
<a name="ln-2049"></a><span class="k">                    write</span><span class="p">(</span><span class="n">error_unit</span><span class="p">,</span> <span class="s1">&#39;(a)&#39;</span><span class="p">)</span> <span class="nb">trim</span><span class="p">(</span><span class="k">module</span><span class="p">)</span> <span class="o">//</span> <span class="s1">&#39; % N/A: &#39;</span> <span class="o">//</span> <span class="p">&amp;</span>
<a name="ln-2050"></a>                        <span class="nb">trim</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<a name="ln-2051"></a>                <span class="k">end if</span>
<a name="ln-2052"></a><span class="k">            else if</span> <span class="p">(</span> <span class="nb">present</span><span class="p">(</span><span class="k">procedure</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<a name="ln-2053"></a><span class="k">                write</span><span class="p">(</span><span class="n">error_unit</span><span class="p">,</span> <span class="s1">&#39;(a)&#39;</span><span class="p">)</span> <span class="nb">trim</span><span class="p">(</span><span class="k">procedure</span><span class="p">)</span> <span class="o">//</span> <span class="s1">&#39;: &#39;</span> <span class="o">//</span> <span class="p">&amp;</span>
<a name="ln-2054"></a>                    <span class="nb">trim</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<a name="ln-2055"></a>            <span class="k">else</span>
<a name="ln-2056"></a><span class="k">                write</span><span class="p">(</span><span class="n">error_unit</span><span class="p">,</span> <span class="s1">&#39;(a)&#39;</span><span class="p">)</span> <span class="nb">trim</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<a name="ln-2057"></a>            <span class="k">end if</span>
<a name="ln-2058"></a><span class="k">            select case</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<a name="ln-2059"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">alloc_fault</span> <span class="p">)</span>
<a name="ln-2060"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s1">&#39;A memory allocation failed.&#39;</span>
<a name="ln-2061"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">array_size_invalid_error</span> <span class="p">)</span>
<a name="ln-2062"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;An array size was invalid.&quot;</span>
<a name="ln-2063"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">char_string_invalid_error</span> <span class="p">)</span>
<a name="ln-2064"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;A character string had an invalid character.&quot;</span>
<a name="ln-2065"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">char_string_too_large_error</span> <span class="p">)</span>
<a name="ln-2066"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;A character string was too large.&quot;</span>
<a name="ln-2067"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">char_string_too_small_error</span> <span class="p">)</span>
<a name="ln-2068"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;A character string was too small.&quot;</span>
<a name="ln-2069"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">eof_failure</span> <span class="p">)</span>
<a name="ln-2070"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;An End-Of-File failure occurred on a READ &quot;</span> <span class="o">//</span> <span class="p">&amp;</span>
<a name="ln-2071"></a>                    <span class="s2">&quot;statement.&quot;</span>
<a name="ln-2072"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">index_invalid_error</span> <span class="p">)</span>
<a name="ln-2073"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;An index was invalid.&quot;</span>
<a name="ln-2074"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">integer_overflow_error</span> <span class="p">)</span>
<a name="ln-2075"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;An integer overflow error occurred.&quot;</span>
<a name="ln-2076"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">read_failure</span> <span class="p">)</span>
<a name="ln-2077"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;A failure occurred in a READ statement.&quot;</span>
<a name="ln-2078"></a>            <span class="k">case</span><span class="p">(</span> <span class="n">write_failure</span> <span class="p">)</span>
<a name="ln-2079"></a>                <span class="n">error</span> <span class="k">stop</span> <span class="s2">&quot;A failure occurred on a WRITE statement.&quot;</span>
<a name="ln-2080"></a>            <span class="k">end select</span>
<a name="ln-2081"></a><span class="k">        end if</span>
<a name="ln-2082"></a><span class="k">    end subroutine </span><span class="n">error_handler</span>
<a name="ln-2083"></a>
<a name="ln-2084"></a>
<a name="ln-2085"></a><span class="k">end module </span><span class="n">stdlib_bitsets</span>
</pre></div>

    </section>
    </div>
  </div>

  
    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-4"><p>&copy; 2021 <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
                                          <br /><small>c696dcb</small></p></div>
        <div class="col-xs-6 col-md-4 col-md-push-4">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/cmacmackin/ford">FORD</a>
             on 2021-01-18 20:34  
          </p>
        </div>
        <div class="col-xs-12 col-md-4 col-md-pull-4"><p class="text-center"> Fortran-lang/stdlib was developed by fortran-lang/stdlib contributors</p></div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>