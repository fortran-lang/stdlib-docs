<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="A community driven standard library for (modern) Fortran">
    <meta name="author" content="fortran-lang/stdlib contributors" >
    <link rel="icon" href="../../favicon.png">

    <title>Hash maps &ndash; Fortran-lang/stdlib</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../../css/pygments.css" rel="stylesheet">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/local.css" rel="stylesheet">
      <link  href="../../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../../index.html">Fortran-lang/stdlib </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../index.html">Contributing and specs</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../../lists/types.html">Derived Types</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
  <div class="row">
    <h1>Hash maps</h1>
    <div class="container p-2 mb-4 bg-light border rounded-3">
      <div class="row align-items-center justify-content-between">
        <div class="col">
          <ul class="list-inline" style="margin-bottom:0px; display:inline">
          </ul>
        </div>
        <div class="col">
          <nav aria-label="breadcrumb">
            <ol class="breadcrumb justify-content-end mb-0">
                <li class="breadcrumb-item"><a href='../index.html'>Contributing and specs</a></li>
                <li class="breadcrumb-item"><a href='index.html'>Specifications (specs)</a></li>
              <li class="breadcrumb-item active" aria-current="page">Hash maps</li>
            </ol>
          </nav>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
      <div class="col-3">
        <div class="card card-body bg-light" id="sidebar-toc">
          <ul class="nav flex-column align-items">
            <li class="nav-item">
              <a class="nav-link" href="../index.html">Contributing and specs</a>
            </li>
          </ul>
          <hr>
          <nav class="nav nav-pills flex-column">
              <a class="nav-link" href="../License.html">Fortran stdlib License (MIT)</a>
              <a class="nav-link" href="../changelog.html">Changelog</a>
              <a class="nav-link" href="../contributing/index.html">Contributing</a>
                <nav class="nav nav-pills flex-column">
                                <a class="nav-link" href="../contributing/CodeOfConduct.html">Contributor Code of Conduct</a>
              <a class="nav-link" href="../contributing/StyleGuide.html">Style Guide</a>
              <a class="nav-link" href="../contributing/Workflow.html">Workflow for Contributors</a>

                </nav>
              <a class="nav-link" href="index.html">Specifications (specs)</a>
                <nav class="nav nav-pills flex-column">
                                <a class="nav-link" href="stdlib_ansi.html">terminal colors</a>
              <a class="nav-link" href="stdlib_array.html">array</a>
              <a class="nav-link" href="stdlib_ascii.html">ascii</a>
              <a class="nav-link" href="stdlib_bitsets.html">bitsets</a>
              <a class="nav-link" href="stdlib_constants.html">constants</a>
              <a class="nav-link" href="stdlib_error.html">error</a>
              <a class="nav-link" href="stdlib_hash_procedures.html">hash</a>
              <a class="nav-link active disabled" href="stdlib_hashmaps.html">Hash maps</a>
              <a class="nav-link" href="stdlib_io.html">io</a>
              <a class="nav-link" href="stdlib_kinds.html">kinds</a>
              <a class="nav-link" href="stdlib_linalg.html">linalg</a>
              <a class="nav-link" href="stdlib_linalg_state_type.html">linalg_state_type</a>
              <a class="nav-link" href="stdlib_logger.html">logger</a>
              <a class="nav-link" href="stdlib_math.html">math</a>
              <a class="nav-link" href="stdlib_optval.html">optval</a>
              <a class="nav-link" href="stdlib_quadrature.html">quadrature</a>
              <a class="nav-link" href="stdlib_random.html">random</a>
              <a class="nav-link" href="stdlib_selection.html">selection</a>
              <a class="nav-link" href="stdlib_sorting.html">sorting</a>
              <a class="nav-link" href="stdlib_specialfunctions.html">specialfunctions</a>
              <a class="nav-link" href="stdlib_specialfunctions_gamma.html">specialfunctions_gamma</a>
              <a class="nav-link" href="stdlib_stats.html">stats</a>
              <a class="nav-link" href="stdlib_stats_distribution_exponential.html">stats_distribution_exponential</a>
              <a class="nav-link" href="stdlib_stats_distribution_normal.html">stats_distribution_normal</a>
              <a class="nav-link" href="stdlib_stats_distribution_uniform.html">stats_distribution_uniform</a>
              <a class="nav-link" href="stdlib_str2num.html">str2num</a>
              <a class="nav-link" href="stdlib_string_type.html">string_type</a>
              <a class="nav-link" href="stdlib_stringlist_type.html">stringlist_type</a>
              <a class="nav-link" href="stdlib_strings.html">strings</a>
              <a class="nav-link" href="stdlib_version.html">version</a>

                </nav>
          </nav>
        </div>
      </div>

    <div class="col-9" id='text'>
      <h1 id="the-stdlib_hashmap_wrappers-and-stdlib_hashmaps-modules">The <code>stdlib_hashmap_wrappers</code>, and <code>stdlib_hashmaps</code> modules</h1>
<div class="toc">
<ul>
<li><a href="#the-stdlib_hashmap_wrappers-and-stdlib_hashmaps-modules">The stdlib_hashmap_wrappers, and stdlib_hashmaps modules</a><ul>
<li><a href="#overview-of-hash-maps">Overview of hash maps</a></li>
<li><a href="#licensing">Licensing</a></li>
<li><a href="#the-hash-map-modules">The hash map modules</a></li>
<li><a href="#the-stdlib_hashmap_wrappers-module">The stdlib_hashmap_wrappers module</a><ul>
<li><a href="#the-stdlib_hashmap_wrapperss-constant-int_hash">The stdlib_hashmap_wrappers's constant, int_hash</a></li>
<li><a href="#the-stdlib_hashmap_wrappers-modules-derived-types">The stdlib_hashmap_wrappers' module's derived types</a></li>
<li><a href="#table-of-stdlib_hashmap_wrappers-procedures">Table of stdlib_hashmap_wrappers procedures</a></li>
<li><a href="#specifications-of-the-stdlib_hashmap_wrappers-procedures">Specifications of the stdlib_hashmap_wrappers procedures</a><ul>
<li><a href="#copy_key-returns-a-copy-of-the-key">copy_key - Returns a copy of the key</a><ul>
<li><a href="#status">Status</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#class">Class</a></li>
<li><a href="#arguments">Arguments</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#copy_other-returns-a-copy-of-the-other-data">copy_other - Returns a copy of the other data</a><ul>
<li><a href="#status_1">Status</a></li>
<li><a href="#description_1">Description</a></li>
<li><a href="#syntax_1">Syntax</a></li>
<li><a href="#class_1">Class</a></li>
<li><a href="#arguments_1">Arguments</a></li>
<li><a href="#example_1">Example</a></li>
</ul>
</li>
<li><a href="#fibonacci_hash-maps-an-integer-to-a-smaller-number-of-bits">fibonacci_hash - maps an integer to a smaller number of bits</a><ul>
<li><a href="#status_2">Status</a></li>
<li><a href="#description_2">Description</a></li>
</ul>
</li>
<li><a href="#fnv_1_hasher-calculates-a-hash-code-from-a-key">fnv_1_hasher- calculates a hash code from a key</a><ul>
<li><a href="#status_3">Status</a></li>
<li><a href="#description_3">Description</a></li>
<li><a href="#syntax_2">Syntax</a></li>
<li><a href="#class_2">Class</a></li>
<li><a href="#argument">Argument</a></li>
<li><a href="#result-character">Result character</a></li>
<li><a href="#result-value">Result value</a></li>
<li><a href="#note">Note</a></li>
<li><a href="#example_2">Example</a></li>
</ul>
</li>
<li><a href="#fnv_1a_hasher-calculates-a-hash-code-from-a-key">fnv_1a_hasher- calculates a hash code from a key</a><ul>
<li><a href="#status_4">Status</a></li>
<li><a href="#description_4">Description</a></li>
<li><a href="#syntax_3">Syntax</a></li>
<li><a href="#class_3">Class</a></li>
<li><a href="#argument_1">Argument</a></li>
<li><a href="#result-character_1">Result character</a></li>
<li><a href="#result-value_1">Result value</a></li>
<li><a href="#note_1">Note</a></li>
<li><a href="#example_3">Example</a></li>
</ul>
</li>
<li><a href="#free_key-frees-the-memory-associated-with-a-key">free_key - frees the memory associated with a key</a><ul>
<li><a href="#status_5">Status</a></li>
<li><a href="#description_5">Description</a></li>
<li><a href="#syntax_4">Syntax</a></li>
<li><a href="#class_4">Class</a></li>
<li><a href="#argument_2">Argument</a></li>
<li><a href="#example_4">Example</a></li>
</ul>
</li>
<li><a href="#free_other-frees-the-memory-associated-with-other-data">free_other - frees the memory associated with other data</a><ul>
<li><a href="#status_6">Status</a></li>
<li><a href="#description_6">Description</a></li>
<li><a href="#syntax_5">Syntax</a></li>
<li><a href="#class_5">Class</a></li>
<li><a href="#argument_3">Argument</a></li>
<li><a href="#example_5">Example</a></li>
</ul>
</li>
<li><a href="#get-extracts-the-data-from-a-derived-type">get - extracts the data from a derived type</a><ul>
<li><a href="#status_7">Status</a></li>
<li><a href="#description_7">Description</a></li>
<li><a href="#syntax_6">Syntax</a></li>
<li><a href="#class_6">Class</a></li>
<li><a href="#argument_4">Argument</a></li>
<li><a href="#example_6">Example</a></li>
</ul>
</li>
<li><a href="#hasher_fun-serves-as-a-function-prototype">hasher_fun- serves as a function prototype.</a><ul>
<li><a href="#status_8">Status</a></li>
<li><a href="#description_8">Description</a></li>
<li><a href="#syntax_7">Syntax</a></li>
<li><a href="#class_7">Class</a></li>
<li><a href="#argument_5">Argument</a></li>
<li><a href="#result-character_2">Result character</a></li>
<li><a href="#result-value_2">Result value</a></li>
<li><a href="#note_2">Note</a></li>
<li><a href="#example_7">Example</a></li>
</ul>
</li>
<li><a href="#operator-compares-two-keys-for-equality">operator(==) - Compares two keys for equality</a><ul>
<li><a href="#status_9">Status</a></li>
<li><a href="#description_9">Description</a></li>
<li><a href="#syntax_8">Syntax</a></li>
<li><a href="#class_8">Class</a></li>
<li><a href="#arguments_2">Arguments</a></li>
<li><a href="#result-character_3">Result character</a></li>
<li><a href="#result-value_3">Result value</a></li>
<li><a href="#example_8">Example</a></li>
</ul>
</li>
<li><a href="#seeded_nmhash32_hasher-calculates-a-hash-code-from-a-key">seeded_nmhash32_hasher- calculates a hash code from a key</a><ul>
<li><a href="#status_10">Status</a></li>
<li><a href="#description_10">Description</a></li>
<li><a href="#syntax_9">Syntax</a></li>
<li><a href="#class_9">Class</a></li>
<li><a href="#argument_6">Argument</a></li>
<li><a href="#result-character_4">Result character</a></li>
<li><a href="#result-value_4">Result value</a></li>
<li><a href="#note_3">Note</a></li>
<li><a href="#example_9">Example</a></li>
</ul>
</li>
<li><a href="#seeded_nmhash32x_hasher-calculates-a-hash-code-from-a-key">seeded_nmhash32x_hasher- calculates a hash code from a key</a><ul>
<li><a href="#status_11">Status</a></li>
<li><a href="#description_11">Description</a></li>
<li><a href="#syntax_10">Syntax</a></li>
<li><a href="#class_10">Class</a></li>
<li><a href="#argument_7">Argument</a></li>
<li><a href="#result-character_5">Result character</a></li>
<li><a href="#result-value_5">Result value</a></li>
<li><a href="#note_4">Note</a></li>
<li><a href="#example_10">Example</a></li>
</ul>
</li>
<li><a href="#seeded_water_hasher-calculates-a-hash-code-from-a-key">seeded_water_hasher- calculates a hash code from a key</a><ul>
<li><a href="#status_12">Status</a></li>
<li><a href="#description_12">Description</a></li>
<li><a href="#syntax_11">Syntax</a></li>
<li><a href="#class_11">Class</a></li>
<li><a href="#argument_8">Argument</a></li>
<li><a href="#result-character_6">Result character</a></li>
<li><a href="#result-value_6">Result value</a></li>
<li><a href="#note_5">Note</a></li>
<li><a href="#example_11">Example</a></li>
</ul>
</li>
<li><a href="#set-places-the-data-in-a-derived-type">set - places the data in a derived type</a><ul>
<li><a href="#status_13">Status</a></li>
<li><a href="#description_13">Description</a></li>
<li><a href="#syntax_12">Syntax</a></li>
<li><a href="#class_12">Class</a></li>
<li><a href="#argument_9">Argument</a></li>
<li><a href="#note_6">Note</a></li>
<li><a href="#example_12">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-stdlib_hashmaps-module">The stdlib_hashmaps module</a><ul>
<li><a href="#the-stdlib_hashmaps-modules-public-constants">The stdlib_hashmaps module's public constants</a></li>
<li><a href="#the-stdlib_hashmaps-modules-derived-types">The stdlib_hashmaps module's derived types</a><ul>
<li><a href="#the-hashmap_type-abstract-type">The hashmap_type abstract type</a></li>
<li><a href="#the-chaining_map_entry_type-derived-type">The chaining_map_entry_type derived type</a></li>
<li><a href="#the-chaining_map_entry_ptr-derived-type">The chaining_map_entry_ptr derived type</a></li>
<li><a href="#the-chaining_map_entry_pool-derived-type">The chaining_map_entry_pool derived type</a></li>
<li><a href="#the-chaining_hashmap_type-derived-type">The chaining_hashmap_type derived type</a></li>
<li><a href="#the-open_map_entry_type-derived-type">The open_map_entry_type derived type</a></li>
<li><a href="#the-open_map_entry_ptr-derived-type">The open_map_entry_ptr derived type</a></li>
<li><a href="#the-open_hashmap_type-derived-type">The open_hashmap_type derived type</a></li>
</ul>
</li>
<li><a href="#table-of-stdlib_hashmap-procedures">Table of stdlib_hashmap procedures</a></li>
<li><a href="#specifications-of-the-stdlib_hashmaps-procedures">Specifications of the stdlib_hashmaps procedures</a><ul>
<li><a href="#calls-returns-the-number-of-calls-on-the-hash-map">calls - Returns the number of calls on the hash map</a><ul>
<li><a href="#status_14">Status</a></li>
<li><a href="#description_14">Description</a></li>
<li><a href="#syntax_13">Syntax</a></li>
<li><a href="#class_13">Class</a></li>
<li><a href="#argument_10">Argument</a></li>
<li><a href="#result-character_7">Result character</a></li>
<li><a href="#result-value_7">Result value</a></li>
<li><a href="#example_13">Example</a></li>
</ul>
</li>
<li><a href="#entries-returns-the-number-of-entries-in-the-hash-map">entries - Returns the number of entries in the hash map</a><ul>
<li><a href="#status_15">Status</a></li>
<li><a href="#description_15">Description</a></li>
<li><a href="#syntax_14">Syntax</a></li>
<li><a href="#class_14">Class</a></li>
<li><a href="#argument_11">Argument</a></li>
<li><a href="#result-character_8">Result character</a></li>
<li><a href="#result-value_8">Result value</a></li>
<li><a href="#example_14">Example</a></li>
</ul>
</li>
<li><a href="#get_all_keys-returns-all-the-keys-contained-in-a-map">get_all_keys - Returns all the keys contained in a map</a><ul>
<li><a href="#status_16">Status</a></li>
<li><a href="#description_16">Description</a></li>
<li><a href="#syntax_15">Syntax</a></li>
<li><a href="#class_15">Class</a></li>
<li><a href="#arguments_3">Arguments</a></li>
<li><a href="#example_15">Example</a></li>
</ul>
</li>
<li><a href="#get_other_data-returns-other-data-associated-with-the-key">get_other_data - Returns other data associated with the key</a><ul>
<li><a href="#status_17">Status</a></li>
<li><a href="#description_17">Description</a></li>
<li><a href="#syntax_16">Syntax</a></li>
<li><a href="#class_16">Class</a></li>
<li><a href="#arguments_4">Arguments</a></li>
<li><a href="#example_16">Example</a></li>
</ul>
</li>
<li><a href="#init-initializes-a-hash-map">init - initializes a hash map</a><ul>
<li><a href="#status_18">Status</a></li>
<li><a href="#description_18">Description</a></li>
<li><a href="#syntax_17">Syntax</a></li>
<li><a href="#class_17">Class</a></li>
<li><a href="#arguments_5">Arguments</a></li>
<li><a href="#example_17">Example</a></li>
</ul>
</li>
<li><a href="#key_test-indicates-whether-key-is-present">key_test - indicates whether key is present</a><ul>
<li><a href="#status_19">Status</a></li>
<li><a href="#description_19">Description</a></li>
<li><a href="#syntax_18">Syntax</a></li>
<li><a href="#class_18">Class</a></li>
<li><a href="#arguments_6">Arguments</a></li>
<li><a href="#example_18">Example</a></li>
</ul>
</li>
<li><a href="#loading-returns-the-ratio-of-entries-to-slots">loading - Returns the ratio of entries to slots</a><ul>
<li><a href="#status_20">Status</a></li>
<li><a href="#description_20">Description</a></li>
<li><a href="#syntax_19">Syntax</a></li>
<li><a href="#class_19">Class</a></li>
<li><a href="#argument_12">Argument</a></li>
<li><a href="#result-character_9">Result character</a></li>
<li><a href="#result-value_9">Result value</a></li>
<li><a href="#example_19">Example</a></li>
</ul>
</li>
<li><a href="#map_entry-inserts-an-entry-into-the-hash-map">map_entry - inserts an entry into the hash map</a><ul>
<li><a href="#status_21">Status</a></li>
<li><a href="#description_21">Description</a></li>
<li><a href="#syntax_20">Syntax</a></li>
<li><a href="#class_20">Class</a></li>
<li><a href="#arguments_7">Arguments</a></li>
<li><a href="#example_20">Example</a></li>
</ul>
</li>
<li><a href="#map_probes-returns-the-number-of-hash-map-probes">map_probes - returns the number of hash map probes</a><ul>
<li><a href="#status_22">Status</a></li>
<li><a href="#description_22">Description</a></li>
<li><a href="#syntax_21">Syntax</a></li>
<li><a href="#class_21">Class</a></li>
<li><a href="#argument_13">Argument</a></li>
<li><a href="#result-character_10">Result character</a></li>
<li><a href="#result-value_10">Result value</a></li>
<li><a href="#example_21">Example</a></li>
</ul>
</li>
<li><a href="#num_slots-returns-the-number-of-hash-map-slots">num_slots - returns the number of hash map slots.</a><ul>
<li><a href="#status_23">Status</a></li>
<li><a href="#description_23">Description</a></li>
<li><a href="#syntax_22">Syntax</a></li>
<li><a href="#class_22">Class</a></li>
<li><a href="#argument_14">Argument</a></li>
<li><a href="#result-character_11">Result character</a></li>
<li><a href="#result-value_11">Result value</a></li>
<li><a href="#example_22">Example</a></li>
</ul>
</li>
<li><a href="#rehash-changes-the-hashing-function">rehash - changes the hashing function</a><ul>
<li><a href="#status_24">Status</a></li>
<li><a href="#description_24">Description</a></li>
<li><a href="#syntax_23">Syntax</a></li>
<li><a href="#class_23">Class</a></li>
<li><a href="#arguments_8">Arguments</a></li>
<li><a href="#example_23">Example</a></li>
</ul>
</li>
<li><a href="#remove-removes-an-entry-from-the-hash-map">remove - removes an entry from the hash map</a><ul>
<li><a href="#status_25">Status</a></li>
<li><a href="#description_25">Description</a></li>
<li><a href="#syntax_24">Syntax</a></li>
<li><a href="#class_24">Class</a></li>
<li><a href="#arguments_9">Arguments</a></li>
<li><a href="#example_24">Example</a></li>
</ul>
</li>
<li><a href="#set_other_data-replaces-the-other-data-for-an-entry">set_other_data - replaces the other data for an entry</a><ul>
<li><a href="#status_26">Status</a></li>
<li><a href="#description_26">Description</a></li>
<li><a href="#syntax_25">Syntax</a></li>
<li><a href="#class_25">Class</a></li>
<li><a href="#arguments_10">Arguments</a></li>
<li><a href="#example_25">Example</a></li>
</ul>
</li>
<li><a href="#slots_bits-returns-the-number-of-bits-used-to-address-the-hash-map-slots">slots_bits - returns the number of bits used to address the hash map slots</a><ul>
<li><a href="#status_27">Status</a></li>
<li><a href="#description_27">Description</a></li>
<li><a href="#syntax_26">Syntax</a></li>
<li><a href="#class_26">Class</a></li>
<li><a href="#argument_15">Argument</a></li>
<li><a href="#result-character_12">Result character</a></li>
<li><a href="#result-value_12">Result value</a></li>
<li><a href="#example_26">Example</a></li>
</ul>
</li>
<li><a href="#total_depth-returns-the-total-depth-of-the-hash-map-entries">total_depth - returns the total depth of the hash map entries</a><ul>
<li><a href="#status_28">Status</a></li>
<li><a href="#description_28">Description</a></li>
<li><a href="#syntax_27">Syntax</a></li>
<li><a href="#class_27">Class</a></li>
<li><a href="#argument_16">Argument</a></li>
<li><a href="#result-character_13">Result character</a></li>
<li><a href="#result-value_13">Result value</a></li>
<li><a href="#example_27">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="overview-of-hash-maps">Overview of hash maps</h2>
<p>A hash map (hash table) is a data structure that maps <em>keys</em> to
<em>values</em>. It uses a hash function to compute a hash code from the <em>key</em>
that serves as an index into a linear array of <em>slots</em> (buckets) from
which the desired <em>value</em> can be extracted.
Each key ideally maps to a unique slot, but most hash functions are
imperfect and can map multiple keys to the same <em>slot</em> resulting in
collisions. Hash maps differ in how they deal with such collisions.
This document discusses the hash maps in the Fortran Standard Library.</p>
<h2 id="licensing">Licensing</h2>
<p>The Fortran Standard Library is distributed under the MIT License.
However components of the library should be evaluated as to whether
they are compatible with the MIT License.
The current hash maps were inspired by an
<a href="http://chasewoerner.org/src/hasht/">implementation</a> of David
Chase. While the code has been greatly modified from his
implementation, he has give permission for the unrestricted use of
his code.</p>
<h2 id="the-hash-map-modules">The hash map modules</h2>
<p>The Fortran Standard Library provides two modules for the
implementation of simple hash maps. These maps only accept hash
functions with a single argument, the key, and yield a 32 bit
hash code. The modules will need to be modified if it is desired to
use hash functions with a different API. The two modules are:
<code>stdlib_hashmap_wrappers</code>, and <code>stdlib_hashmaps</code> corresponding to the
files: <code>stdlib_hashmap_wrappers.f90</code>, and <code>stdlib_hashmaps.f90</code></p>
<p>The module <code>stdlib_hashmap_wrappers</code> provides types and procedures for
use by <code>stdlib_hashmaps</code>. It provides an
interface to the 32 bit hash functions of the Standard Library module,
<code>stdlib_hash_32bit</code>, and provides wrappers to some of the
hash functions so that they no longer need to be supplied seeds. It
also defines two data types used to store information in the hash
maps, the <code>key_type</code> and the <code>other_type</code>. The <code>key_type</code> is used to
define keys that, in turn, are used to identify the data entered into
a hash map. The <code>other_type</code> is intended to contain the other data
associated with the key.</p>
<p>The module <code>stdlib_hashmaps</code> defines the API for a parent datatype,
<code>hashmap_type</code> and two extensions of that hash map type:
<code>chaining_hashmap_type</code> and <code>open_hashmap_type</code>.</p>
<p>The <code>hashmap_type</code> defines the Application Programmers
Interface (API) for the procedures used by its two extensions. It
explicitly defines five non-overridable procedures. It also defines
the interfaces for eleven deferred procedures. It does not define the
finalization routines for the two extension types, or one routine
provided by the <code>open_hashmap_type</code>.</p>
<p>The <code>chaining_hashmap_type</code> uses separate chaining with linked
lists to deal with hash index collisions. In separate chaining the
colliding indices are handled by using linked lists with their roots
at the hash index. The <code>chaining_hashmap_type</code> procedures are
implemented in the module <code>stdlib_hashmap_chaining</code> corresponding
to the file, <code>stdlib_hashmap_chaining.f90</code>.</p>
<p>The <code>open_hashmap_type</code>
uses linear open addressing to deal with hash index collisions. In
linear open addressing the colliding indices are
handled by searching from the initial hash index in increasing
steps of one (modulo the hash map size) for an open map slot.
The <code>open_hashmap_type</code> procedures are implemented in the submodule
<code>stdlib_hashmap_open</code> corresponding to the file
<code>stdlib_hashmap_open.f90</code>.</p>
<p>The maps use powers of two for their slot sizes, so that the function,
<code>fibonacci_hash</code>, can 
be used to map the hash codes to indices in the map. This is
expected to be more efficient than prime number mapping using a
modulo operation, and reduces the requirement that the hash
function need to do a good job randomizing its lower order bits.
They do require a good randomizing hash method for good performance.
Both adjust the map size to reduce collisions, based on 
the ratio of the number of hash map probes to the number of subroutine 
calls.
Wile the maps make extensive use of pointers internally, a private
finalization subroutine avoids memory leaks.
The maps can take entry keys of type <code>key_type</code>, and other data of the
type <code>other_type</code>.
The maps allow the addition, removal, and lookup of entries, and the
inclusion of data in addition to the entry key.</p>
<h2 id="the-stdlib_hashmap_wrappers-module">The <code>stdlib_hashmap_wrappers</code> module</h2>
<p>The <code>stdlib_hashmap_wrappers</code> module provides data types to
represent keys and associated data stored in a module, but is also, a
wrapper for the <code>stdlib_hash_32bit</code> module. It allows
direct access to the <code>stdlib_hash_32bit</code> procedures:
<code>fibonacci_hash</code>, <code>fnv_1_hasher</code>, <code>fnv_1a_hasher</code>; and provides
wrapper functions, <code>seeded_nmhash32_hasher</code>,
<code>seeded_nmhash32x_hasher</code>, and <code>seeded_water_hasher</code> to the hash
functions: <code>nmhash32</code>, <code>nmhash32x</code>, and <code>water_hash</code>, respectively. It
defines an interface, <code>hasher_fun</code>, compatible with the hash functions
that take a <code>non-scalar key</code>. It defines one integer constant used
as a kind value,<code>int_hash</code>. It also defines two types, <code>key_type</code> and
<code>other_type</code>, and associated procedures, for storing and manipulating
keys and their associated data.</p>
<h3 id="the-stdlib_hashmap_wrapperss-constant-int_hash">The <code>stdlib_hashmap_wrappers</code>'s constant, <code>int_hash</code></h3>
<p>The constant <code>int_hash</code> is used to define the integer kind value for
the returned hash codes and variables used to access them. It
currently is imported from <code>stdlib_hash_32bit</code> where it has the
value, <code>int32</code>. </p>
<h3 id="the-stdlib_hashmap_wrappers-modules-derived-types">The <code>stdlib_hashmap_wrappers</code>' module's derived types</h3>
<p>The <code>stdlib_hashmap_wrappers</code> module defines two derived types:
<code>key_type</code>, and <code>other_type</code>. The <code>key_type</code> is intended to be used
for the search keys of hash tables.  The <code>other_type</code> is intended to
store additional data associated with a key. Both types are
opaque. Their current representations are as follows</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(:)</span>
<span class="w">    </span><span class="k">end type </span><span class="n">key_type</span>

<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">other_type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span>
<span class="k">    end type </span><span class="n">other_type</span>
</code></pre></div>

<p>The module also defines six procedures for those types: <code>copy_key</code>,
<code>copy_other</code>, <code>equal_keys</code>, <code>free_key</code>, <code>free_other</code>, <code>get</code>, and
<code>set</code>, and one operator, <code>==</code>,
for use by the hash maps to manipulate or inquire of components of
those types.</p>
<h3 id="table-of-stdlib_hashmap_wrappers-procedures">Table of <code>stdlib_hashmap_wrappers</code> procedures</h3>
<p>The  <code>stdlib_hashmap_wrappers</code> module provides procedures in
several categories: procedures to manipulate data of the <code>key_type</code>;
procedures to manipulate data of the <code>other_type</code>, and 32 bit hash
functions for keys. The procedures in each category are listed
below. It also provides an operator to compare two key type values for
equality. </p>
<p>Procedures to manipulate <code>key_type</code> data:</p>
<ul>
<li>
<p><code>copy_key( key_in, key_out )</code> - Copies the contents of the key,
  <code>key_in</code>, to contents of the key, <code>key_out</code>.</p>
</li>
<li>
<p><code>get( key, value )</code> - extracts the contents of <code>key</code> into <code>value</code>,
  an <code>int8</code> array, <code>int32</code> array, or character string.</p>
</li>
<li>
<p><code>free_key( key )</code> - frees the memory in <code>key</code>.</p>
</li>
<li>
<p><code>set( key, value )</code> - sets the content of <code>key</code> to <code>value</code>.<br>
  Supported key types are <code>int8</code> array, <code>int32</code> array, and character
  string.</p>
</li>
</ul>
<p>Procedures to manipulate <code>other_type</code> data:</p>
<ul>
<li>
<p><code>copy_other( other_in, other_out )</code> - Copies the contents of the
  other data, <code>other_in</code>, to the contents of the other data,
  <code>other_out</code>.</p>
</li>
<li>
<p><code>get( other, value )</code> - extracts the contents of <code>other</code> into the
  <code>class(*)</code> variable <code>value</code>.</p>
</li>
<li>
<p><code>set( other, value )</code> - sets the content of <code>other</code> to the <code>class(*)</code>
  variable <code>value</code>. </p>
</li>
<li>
<p><code>free_other( other )</code> - frees the memory in <code>other</code>.</p>
</li>
</ul>
<p>Procedures to hash keys to 32 bit integers:</p>
<ul>
<li>
<p><code>fnv_1_hasher( key )</code> - hashes a <code>key</code> using the FNV-1 algorithm.</p>
</li>
<li>
<p><code>fnv_1a_hasher( key )</code> - hashes a <code>key</code> using the FNV-1a algorithm.</p>
</li>
<li>
<p><code>seeded_nmhash32_hasher( key )</code> - hashes a <code>key</code> using the nmhash32
  algorithm.</p>
</li>
<li>
<p><code>seeded_nmhash32x_hasher( key )</code> - hashes a <code>key</code> using the nmhash32x
  algorithm.</p>
</li>
<li>
<p><code>seeded_water_hasher( key )</code> - hashes a <code>key</code> using the waterhash
  algorithm.</p>
</li>
</ul>
<p>Operator to compare two <code>key_type</code> values for equality</p>
<ul>
<li><code>key1 == key2</code> - compares <code>key1</code> with <code>key2</code> for equality</li>
</ul>
<h3 id="specifications-of-the-stdlib_hashmap_wrappers-procedures">Specifications of the <code>stdlib_hashmap_wrappers</code> procedures</h3>
<h4 id="copy_key-returns-a-copy-of-the-key"><code>copy_key</code> - Returns a copy of the key</h4>
<h5 id="status">Status</h5>
<p>Experimental</p>
<h5 id="description">Description</h5>
<p>Returns a copy of an input of type <code>key_type</code>.</p>
<h5 id="syntax">Syntax</h5>
<p><code>call</code> <a href="../../proc/copy_key.html">copy_key</a> <code>( old_key, new_key )</code></p>
<h5 id="class">Class</h5>
<p>Subroutine.</p>
<h5 id="arguments">Arguments</h5>
<p><code>old_key</code>: shall be a scalar expression of type <code>key_type</code>. It
is an <code>intent(in)</code> argument.</p>
<p><code>new_key</code>: shall be a scalar variable of type <code>key_type</code>. It
is an <code>intent(out)</code> argument.</p>
<h5 id="example">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_copy_key</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">copy_key</span><span class="p">,</span><span class="w"> </span><span class="n">operator</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span>
<span class="w">  </span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">copy_key</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;old_key == new_key = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">old_key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">new_key</span>
<span class="k">end program </span><span class="n">example_copy_key</span>
</code></pre></div>

<h4 id="copy_other-returns-a-copy-of-the-other-data"><code>copy_other</code> - Returns a copy of the other data</h4>
<h5 id="status_1">Status</h5>
<p>Experimental</p>
<h5 id="description_1">Description</h5>
<p>Returns a copy of an input of type <code>other_type</code>.</p>
<h5 id="syntax_1">Syntax</h5>
<p><code>call</code> <a href="../../proc/copy_other.html">copy_other</a> <code>( other_in, other_out )</code></p>
<h5 id="class_1">Class</h5>
<p>Subroutine.</p>
<h5 id="arguments_1">Arguments</h5>
<p><code>other_in</code>: shall be a scalar expression of type <code>other_type</code>. It
is an <code>intent(in)</code> argument.</p>
<p><code>other_out</code>: shall be a scalar variable of type <code>other_type</code>. It
is an <code>intent(out)</code> argument.</p>
<h5 id="example_1">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_copy_other</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">copy_other</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">other_in</span><span class="p">,</span><span class="w"> </span><span class="n">other_out</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">type </span><span class="n">dummy_type</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="w">  </span><span class="k">end type</span>
<span class="k">  type</span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dummy_val</span>
<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span>
<span class="w">    </span><span class="n">dummy_val</span><span class="p">%</span><span class="k">value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">end do</span>
<span class="k">  allocate</span><span class="w"> </span><span class="p">(</span><span class="n">other_in</span><span class="p">%</span><span class="k">value</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="o">=</span><span class="n">dummy_val</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">copy_other</span><span class="p">(</span><span class="n">other_in</span><span class="p">,</span><span class="w"> </span><span class="n">other_out</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">other_out</span><span class="p">%</span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;other_in == other_out = &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="k">all</span><span class="p">(</span><span class="n">dummy_val</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="p">%</span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">end select</span>
<span class="k">end program </span><span class="n">example_copy_other</span>
</code></pre></div>

<h4 id="fibonacci_hash-maps-an-integer-to-a-smaller-number-of-bits"><code>fibonacci_hash</code> - maps an integer to a smaller number of bits</h4>
<h5 id="status_2">Status</h5>
<p>Experimental</p>
<h5 id="description_2">Description</h5>
<p><code>fibonacci_hash</code> is just a re-export of the function of the same name
implemented in
<a href="https://stdlib.fortran-lang.org/page/spec/stdlib_hash_functions.html#fibonacci_hash-maps-an-integer-to-a-smaller-number-of-bits"><code>stdlib_hash_32bit</code></a>.
It reduces the value of a 32 bit integer to a smaller number of bits.</p>
<h4 id="fnv_1_hasher-calculates-a-hash-code-from-a-key"><code>fnv_1_hasher</code>- calculates a hash code from a key</h4>
<h5 id="status_3">Status</h5>
<p>Experimental</p>
<h5 id="description_3">Description</h5>
<p>Calculates a 32 bit hash code from an input of type <code>key_type</code>.</p>
<h5 id="syntax_2">Syntax</h5>
<p><code>code =</code> <a href="../../proc/fnv_1_hasher.html">fnv_1_hasher</a> <code>( key )</code></p>
<h5 id="class_2">Class</h5>
<p>Pure function</p>
<h5 id="argument">Argument</h5>
<p><code>key</code>: Shall be a scalar expression of type <code>key_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value">Result value</h5>
<p>The result is a hash code created using the FNV-1 algorithm.</p>
<h5 id="note">Note</h5>
<p><code>fnv_1_hasher</code> is an implementation of the original FNV-1 hash code of
Glenn Fowler, Landon Curt Noll, and Phong Vo.
This code is relatively fast on short keys, and is small enough that
it will often be retained in the instruction cache if hashing is
intermittent.
As a result it should give good performance for typical hash map
applications.
This code does not pass any of the SMHasher tests, but the resulting
degradation in performance due to its larger number of collisions is
expected to be minor compared to its faster hashing rate.</p>
<h5 id="example_2">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_fnv_1_hasher</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_fnv_1_hasher</span>
</code></pre></div>

<h4 id="fnv_1a_hasher-calculates-a-hash-code-from-a-key"><code>fnv_1a_hasher</code>- calculates a hash code from a key</h4>
<h5 id="status_4">Status</h5>
<p>Experimental</p>
<h5 id="description_4">Description</h5>
<p>Calculates a 32 bit hash code from an input of type <code>key_type</code>.</p>
<h5 id="syntax_3">Syntax</h5>
<p><code>code =</code> <a href="../../proc/fnv_1a_hasher.html">fnv_1a_hasher</a> <code>( key )</code></p>
<h5 id="class_3">Class</h5>
<p>Pure function</p>
<h5 id="argument_1">Argument</h5>
<p><code>key</code>: Shall be a scalar expression of type <code>key_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_1">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value_1">Result value</h5>
<p>The result is a hash code created using the FNV-1a algorithm.</p>
<h5 id="note_1">Note</h5>
<p><code>fnv_1a_hasher</code> is an implementation of the original FNV-1A hash code
of Glenn Fowler, Landon Curt Noll, and Phong Vo.
This code is relatively fast on short keys, and is small enough that
it will often be retained in the instruction cache if hashing is
intermittent.
As a result it should give good performance for typical hash map
applications.
This code does not pass any of the SMHasher tests, but the resulting
degradation in performance due to its larger number of collisions is
expected to be minor compared to its faster hashing rate.</p>
<h5 id="example_3">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_fnv_1a_hasher</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">fnv_1a_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fnv_1a_hasher</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_fnv_1a_hasher</span>
</code></pre></div>

<h4 id="free_key-frees-the-memory-associated-with-a-key"><code>free_key</code> - frees the memory associated with a key</h4>
<h5 id="status_5">Status</h5>
<p>Experimental</p>
<h5 id="description_5">Description</h5>
<p>Deallocates the memory associated with a variable of type
<code>key_type</code>.</p>
<h5 id="syntax_4">Syntax</h5>
<p><code>call</code> <a href="../../proc/free_key.html">free_key</a> <code>( key )</code></p>
<h5 id="class_4">Class</h5>
<p>Subroutine.</p>
<h5 id="argument_2">Argument</h5>
<p><code>key</code>: shall be a scalar variable of type <code>key_type</code>. It
is an <code>intent(out)</code> argument.</p>
<h5 id="example_4">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_free_key</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">copy_key</span><span class="p">,</span><span class="w"> </span><span class="n">free_key</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span>
<span class="w">  </span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">copy_key</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">free_key</span><span class="p">(</span><span class="n">old_key</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_free_key</span>
</code></pre></div>

<h4 id="free_other-frees-the-memory-associated-with-other-data"><code>free_other</code> - frees the memory associated with other data</h4>
<h5 id="status_6">Status</h5>
<p>Experimental</p>
<h5 id="description_6">Description</h5>
<p>Deallocates the memory associated with a variable of type
<code>other_type</code>.</p>
<h5 id="syntax_5">Syntax</h5>
<p><code>call</code> <a href="../../proc/free_other.html">free_other</a> <code>( other )</code></p>
<h5 id="class_5">Class</h5>
<p>Subroutine.</p>
<h5 id="argument_3">Argument</h5>
<p><code>other</code>: shall be a scalar variable of type <code>other_type</code>. It
is an <code>intent(out)</code> argument.</p>
<h5 id="example_5">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_free_other</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">copy_other</span><span class="p">,</span><span class="w"> </span><span class="n">free_other</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type </span><span class="n">dummy_type</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="w">  </span><span class="k">end type </span><span class="n">dummy_type</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dummy_val</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">other_in</span><span class="p">,</span><span class="w"> </span><span class="n">other_out</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span>
<span class="w">    </span><span class="n">dummy_val</span><span class="p">%</span><span class="k">value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">end do</span>
<span class="k">  allocate</span><span class="w"> </span><span class="p">(</span><span class="n">other_in</span><span class="p">%</span><span class="k">value</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="o">=</span><span class="n">dummy_val</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">copy_other</span><span class="p">(</span><span class="n">other_in</span><span class="p">,</span><span class="w"> </span><span class="n">other_out</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">free_other</span><span class="p">(</span><span class="n">other_out</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_free_other</span>
</code></pre></div>

<h4 id="get-extracts-the-data-from-a-derived-type"><code>get</code> - extracts the data from a derived type</h4>
<h5 id="status_7">Status</h5>
<p>Experimental</p>
<h5 id="description_7">Description</h5>
<p>Extracts the data from a <code>key_type</code> or <code>other_type</code> and stores it
in the variable <code>value</code>.</p>
<h5 id="syntax_6">Syntax</h5>
<p><code>call</code> <a href="../../interface/get.html">get</a> <code>( key, value )</code></p>
<p>or</p>
<p><code>call</code> <a href="../../interface/get.html">get</a> <code>( other, value )</code></p>
<h5 id="class_6">Class</h5>
<p>Subroutine.</p>
<h5 id="argument_4">Argument</h5>
<p><code>key</code>: shall be a scalar expression of type <code>key_type</code>. It
is an <code>intent(in)</code> argument.</p>
<p><code>other</code>: shall be a scalar expression of type <code>other_type</code>. It
is an <code>intent(in)</code> argument.</p>
<p><code>value</code>: if the the first argument is of <code>key_type</code>, <code>value</code> shall be
an allocatable default <code>character</code> string variable, or 
an allocatable vector variable of type <code>integer</code> and kind <code>int8</code> or 
<code>int32</code>, otherwise the first argument is of <code>other_type</code> and <code>value</code> 
shall be an allocatable of <code>class(*)</code>. It is an <code>intent(out)</code> argument.</p>
<h5 id="example_6">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_get</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">get</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(:),</span><span class="w"> </span><span class="k">result</span><span class="p">(:)</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">allocate</span><span class="w"> </span><span class="p">(</span><span class="k">value</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">15</span><span class="p">))</span>
<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span>
<span class="w">    </span><span class="k">value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">end do</span>
<span class="k">  call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RESULT == VALUE = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">all</span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_get</span>
</code></pre></div>

<h4 id="hasher_fun-serves-as-a-function-prototype"><code>hasher_fun</code>- serves as a function prototype.</h4>
<h5 id="status_8">Status</h5>
<p>Experimental</p>
<h5 id="description_8">Description</h5>
<p>Serves as a prototype for hashing functions with a single, <code>key</code>,
argument of type <code>key_type</code> returning an <code>int32</code> hash value.</p>
<h5 id="syntax_7">Syntax</h5>
<p><code>type(</code> <a href="../../interface/hasher_fun.html">hasher_fun</a> <code>), pointer :: fun_pointer</code></p>
<h5 id="class_7">Class</h5>
<p>Pure function prototype</p>
<h5 id="argument_5">Argument</h5>
<p><code>key</code>: Shall be a rank one array expression of type <code>integer(int8)</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_2">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value_2">Result value</h5>
<p>The result is a hash code.</p>
<h5 id="note_2">Note</h5>
<p><code>hasher_fun</code> is a prototype for defining dummy arguments and function
pointers intended for use as a hash function for the hash maps.</p>
<h5 id="example_7">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_hasher_fun</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1a_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">hasher_fun</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  procedure</span><span class="p">(</span><span class="n">hasher_fun</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hasher_pointer</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">hasher_pointer</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fnv_1a_hasher</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hasher_pointer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_hasher_fun</span>
</code></pre></div>

<h4 id="operator-compares-two-keys-for-equality"><code>operator(==)</code> - Compares two keys for equality</h4>
<h5 id="status_9">Status</h5>
<p>Experimental </p>
<h5 id="description_9">Description</h5>
<p>Returns <code>.true.</code> if two keys are equal, and <code>.false.</code> otherwise. </p>
<h5 id="syntax_8">Syntax</h5>
<p><code>test = key1 == key2</code></p>
<h5 id="class_8">Class</h5>
<p>Pure operator. </p>
<h5 id="arguments_2">Arguments</h5>
<p><code>key1</code>: shall be a scalar expression of type <code>key_type</code>. It 
is an <code>intent(in)</code> argument. </p>
<p><code>key2</code>: shall be a scalar expression of type <code>key_type</code>. It 
is an <code>intent(in)</code> argument. </p>
<h5 id="result-character_3">Result character</h5>
<p>The result is a value of type default <code>logical</code>. </p>
<h5 id="result-value_3">Result value</h5>
<p>The result is <code>.true.</code> if the keys are equal, otherwise <code>.falss.</code>. </p>
<h5 id="example_8">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_equal_keys</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">copy_key</span><span class="p">,</span><span class="w"> </span><span class="n">operator</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span>
<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span>
<span class="w">    </span><span class="k">value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">end do</span>
<span class="k">  call </span><span class="n">set</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">copy_key</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span><span class="w"> </span><span class="n">new_key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;old_key == new_key = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">old_key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">new_key</span>
<span class="k">end program </span><span class="n">example_equal_keys</span>
</code></pre></div>

<h4 id="seeded_nmhash32_hasher-calculates-a-hash-code-from-a-key"><code>seeded_nmhash32_hasher</code>- calculates a hash code from a key</h4>
<h5 id="status_10">Status</h5>
<p>Experimental</p>
<h5 id="description_10">Description</h5>
<p>Calculates a 32 bit hash code from an input of type <code>key_type</code>.</p>
<h5 id="syntax_9">Syntax</h5>
<p><code>code =</code> <a href="../../proc/seeded_nmhash32_hasher.html">seeded_nmhash32_hasher</a> <code>( key )</code></p>
<h5 id="class_9">Class</h5>
<p>Pure function</p>
<h5 id="argument_6">Argument</h5>
<p><code>key</code>: Shall be a scalar expression of type <code>key_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_4">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value_4">Result value</h5>
<p>The result is a hash code created using the <code>nmhash32</code> algorithm.</p>
<h5 id="note_3">Note</h5>
<p><code>seeded_nmhash32_hasher</code> is a wrapper to the <code>NMHASH32_HASH</code> of the
module <code>stdlib_hash_32bit</code>, which supplies a fixed seed
to the wrapped function. <code>NMHASH32</code> is an implementation of the
<code>nmhash32</code> hash code of James Z. M. Gao.
This code has good, but not great, performance on long keys, poorer
performance on short keys.
As a result it should give fair performance for typical hash map
applications.
This code passes the SMHasher tests.</p>
<h5 id="example_9">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_seeded_nmhash32_hasher</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">seeded_nmhash32_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seeded_nmhash32_hasher</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_seeded_nmhash32_hasher</span>
</code></pre></div>

<h4 id="seeded_nmhash32x_hasher-calculates-a-hash-code-from-a-key"><code>seeded_nmhash32x_hasher</code>- calculates a hash code from a key</h4>
<h5 id="status_11">Status</h5>
<p>Experimental</p>
<h5 id="description_11">Description</h5>
<p>Calculates a 32 bit hash code from an input of type <code>key_type</code>.</p>
<h5 id="syntax_10">Syntax</h5>
<p><code>code =</code> <a href="../../proc/seeded_nmhash32x_hasher.html">seeded_nmhash32x_hasher</a> <code>( key )</code></p>
<h5 id="class_10">Class</h5>
<p>Pure function</p>
<h5 id="argument_7">Argument</h5>
<p><code>key</code>: Shall be a scalar expression of type <code>key_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_5">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value_5">Result value</h5>
<p>The result is a hash code created using the <code>nmhash32x</code> algorithm.</p>
<h5 id="note_4">Note</h5>
<p><code>seeded_nmhash32x_hasher</code> is a wrapper to the <code>nmhash32x_hash</code> of the
module <code>stdlib_hash_32bit</code>, which supplies a fixed seed
to the wrapped function. <code>nmhash32x</code> is an implementation of the
<code>nmhash32x</code> hash code of James Z. M. Gao.
This code has good, but not great, performance on long keys, poorer
performance on short keys.
As a result it should give fair performance for typical hash map
applications.
This code passes the SMHasher tests.</p>
<h5 id="example_10">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_seeded_nmhash32x_hasher</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">seeded_nmhash32x_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seeded_nmhash32x_hasher</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_seeded_nmhash32x_hasher</span>
</code></pre></div>

<h4 id="seeded_water_hasher-calculates-a-hash-code-from-a-key"><code>seeded_water_hasher</code>- calculates a hash code from a key</h4>
<h5 id="status_12">Status</h5>
<p>Experimental</p>
<h5 id="description_12">Description</h5>
<p>Calculates a 32 bit hash code from an input of type <code>key_type</code>.</p>
<h5 id="syntax_11">Syntax</h5>
<p><code>code =</code> <a href="../../proc/seeded_water_hasher.html">seeded_water_hasher</a> <code>( key )</code></p>
<h5 id="class_11">Class</h5>
<p>Pure function</p>
<h5 id="argument_8">Argument</h5>
<p><code>key</code>: Shall be a scalar expression of type <code>key_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_6">Result character</h5>
<p>The result is a scalar integer of kind <code>int32</code>.</p>
<h5 id="result-value_6">Result value</h5>
<p>The result is a hash code created using the <code>waterhash</code> algorithm.</p>
<h5 id="note_5">Note</h5>
<p><code>seeded_water_hasher</code> is a wrapper to the <code>water_hash</code> of the
module <code>stdlib_hash_32bit</code>, which supplies a fixed seed
to the wrapped function. <code>water_hash</code> is an implementation of the
<code>waterhash</code> hash code of Tommy Ettinger.
This code has excellent performance on long keys, and good performance
on short keys.
As a result it should give reasonable performance for typical hash
table applications.
This code passes the SMHasher tests.</p>
<h5 id="example_11">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_seeded_water_hasher</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">seeded_water_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">array1</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hash</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">10_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">array1</span><span class="p">)</span>
<span class="w">  </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seeded_water_hasher</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span>
<span class="k">end program </span><span class="n">example_seeded_water_hasher</span>
</code></pre></div>

<h4 id="set-places-the-data-in-a-derived-type"><code>set</code> - places the data in a derived type</h4>
<h5 id="status_13">Status</h5>
<p>Experimental</p>
<h5 id="description_13">Description</h5>
<p>Places the data from <code>value</code> in a <code>key_type</code> or an <code>other_type</code>.</p>
<h5 id="syntax_12">Syntax</h5>
<p><code>call</code> <a href="../../interface/set.html">set</a> <code>( key, value )</code></p>
<p>or</p>
<p><code>call</code> <a href="../../interface/set.html">set</a> <code>( other, value )</code></p>
<h5 id="class_12">Class</h5>
<p>Subroutine.</p>
<h5 id="argument_9">Argument</h5>
<p><code>key</code>: shall be a scalar variable of type <code>key_type</code>. It
is an <code>intent(out)</code> argument.</p>
<p><code>other</code>: shall be a scalar variable of type <code>other_type</code>. It
is an <code>intent(out)</code> argument.</p>
<p><code>value</code>: if the first argument is <code>key</code>, <code>value</code> shall be a default
<code>character</code> string scalar expression, or a vector expression of type <code>integer</code>
and kind <code>int8</code> or <code>int32</code>, while for a first argument of type 
<code>other</code> <code>value</code> shall be of type <code>class(*)</code>. It is an <code>intent(in)</code> 
argument.</p>
<h5 id="note_6">Note</h5>
<p>Values of types other than a scalar default character or and
<code>int8</code> or <code>int32</code> vector can be used as the basis of a <code>key</code> by transferring the
value to an <code>int8</code> vector.</p>
<h5 id="example_12">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_set</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">    </span><span class="n">get</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">use </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(:),</span><span class="w"> </span><span class="k">result</span><span class="p">(:)</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">allocate</span><span class="w"> </span><span class="p">(</span><span class="k">value</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">15</span><span class="p">))</span>
<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span>
<span class="w">    </span><span class="k">value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="k">end do</span>
<span class="k">  call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RESULT == VALUE = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">all</span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_set</span>
</code></pre></div>

<h2 id="the-stdlib_hashmaps-module">The <code>stdlib_hashmaps</code> module</h2>
<p>The <code>stdlib_hashmaps</code> module defines three public data types,
associated procedures and constants that implement two simple hash map
types using separate chaining hashing and open addressing hashing. The
derived type <code>hashmap_type</code> is the parent type to its two
extensions: <code>chaining_hashmap_type</code> and <code>open_hashmap_type</code>.
The extension types provide 
procedures to manipulate the structure of a hash map object:
<code>init</code>, <code>map_entry</code>, <code>rehash</code>, <code>remove</code>, and
<code>set_other_data</code>. They also provide procedures to inquire about
entries in the hash map: <code>get_other_data</code>, and
<code>key_test</code>. Finally they provide procedures to inquire about the
overall structure and performance of the hash map object:<code>calls</code>,
<code>entries</code>, <code>get_other_data</code>, <code>loading</code>, <code>slots</code>, and
<code>total_depth</code>. The module also defines a number of public constants:
<code>probe_factor</code>, <code>load_factor</code>, <code>map_probe_factor</code>, <code>default_bits</code>,
<code>max_bits</code>, <code>int_calls</code>, <code>int_depth</code>, <code>int_index</code>,
<code>int_probes</code>, <code>success</code>, <code>alloc_fault</code>, and <code>array_size_error</code>.</p>
<p>Generic key interfaces for <code>key_test</code>, <code>map_entry</code>, <code>get_other_data</code>,
<code>remove</code>, and <code>set_other_data</code> are povided so that the supported types
of <code>int8</code> arrays, <code>int32</code> arrays and <code>character</code> scalars can be used in the
key field as well as the base <code>key</code> type.  So for <code>key_test</code>,
<code>key_key_test</code> specifies key type for the key field, <code>int8_key_test</code> is <code>int8</code>
for the key field and so on.  Procedures other than <code>key_key_test</code> will call
the <code>set</code> function to generate a key type and pass to <code>key_key_test</code>.         </p>
<h3 id="the-stdlib_hashmaps-modules-public-constants">The <code>stdlib_hashmaps</code> module's public constants</h3>
<p>The module defines several categories of public constants. Some are
used to parameterize the empirical slot expansion code. Others
parameterize the slots table size. Some are used to define
integer kind values for different applications. Finally, some are used
to report errors or success.</p>
<p>The constants <code>probe_factor</code>, and <code>map_probe_factor</code> are used to
parameterize the slot expansion code used to determine when in a
in a procedure call the number 
of slots need to be increased to decrease the search path for an
entry. The constant <code>probe_factor</code> is used to determine when
the ratio of the number of map probes to map calls is too large and 
the slots need expansion. The constant <code>map_probe_factor</code> is used to
determine when inserting a new entry the ratio of the number of map
probes to map calls is too large and the slots need expansion.</p>
<p>The constants <code>default_bits</code>, and
<code>max_bits</code> are used to parameterize the table's slots size. The
<code>default_bits</code> constant defines the default initial number of slots
with a current value of 6 resulting in an initial <code>2**6 == 64</code>
slots. This may optionally be overridden on hash map creation. The
<code>max_bits</code> parameter sets the maximum table size as <code>2**max_bits</code> with
a default value for <code>max_bits</code> of 30. The table will not work for a
slots size greater than <code>2**30</code>.</p>
<p>The constants <code>int_calls</code>, <code>int_depth</code>, <code>int_index</code>, and <code>int_probes</code>
are used to define integer kind values for various contexts. The
number of calls are reported and stored in entities of kind
<code>int_calls</code>. Currently <code>int_calls</code> has the value of <code>int64</code>. The
total depth, the number of inquiries needed to access all elements
of the table, is reported and stored in entities of kind
<code>int_depth</code>. Currently <code>int_depth</code> has the value of <code>int64</code>. The
number of entries in the table, is reported and stored in entities of
kind <code>int_index</code>. Currently <code>int_index</code> has the value of <code>int32</code>.
The number of probes, hash map enquiries, are reported and stored in
entities of kind <code>int_probes</code>. Currently <code>int_probes</code> has the value of
<code>int64</code>.</p>
<p>The constant <code>load_factor</code> is only used by the <code>open_hashmap_type</code>. It
specifies the maximum fraction of the available slots that may be
filled before expansion occurs. The current <code>load_factor = 0.5625</code> so
the current implementation of <code>open_hashmap_type</code> can only hold a
little more than <code>2**29</code> entries.</p>
<p>Finally the error codes <code>success</code>, <code>alloc_fault</code>, and
<code>array_size_error</code> are used to report the error status of certain
procedure calls. The <code>succes</code> code indicates that no problems were
found. The <code>alloc_fault</code> code indicates that a memory allocation
failed. Finally the <code>array_size_error</code> indicates that on table
creation <code>slots_bits</code> is less than <code>default_bits</code> or
greater than <code>max_bits</code>.</p>
<h3 id="the-stdlib_hashmaps-modules-derived-types">The <code>stdlib_hashmaps</code> module's derived types</h3>
<p>The <code>stdlib_hashmaps</code> module defines three public derived types and
seven private types used in the implementation of the public
types. The public types are the abstract <code>hashmap_type</code> and its
extensions: <code>chaining_hashmap_type</code> and <code>open_hashmap_type</code>. The three
private derived types, <code>chaining_map_entry_type</code>,
<code>chaining_map_entry_ptr</code>, and <code>chaining_map_entry_pool</code> are used in
the implementation of the <code>chaining_hashmap_type</code> public type. The
four private derived types, <code>open_map_entry_type</code>,
<code>open_map_entry_list</code>, <code>open_map_entry_ptr</code>, and <code>open_map_entry_pool</code>
are used in the implementation of the <code>open_hashmap_type</code> public
type. Each of these types are described below. </p>
<h4 id="the-hashmap_type-abstract-type">The <code>hashmap_type</code> abstract type</h4>
<p>The <code>hashmap_type</code> abstract type serves as the parent type for the two
types <code>chaining_hashmap_type</code> and <code>open_hashmap_type</code>. It defines
seven private components:</p>
<ul>
<li>
<p><code>call_count</code> - the number of procedure calls on the map;</p>
</li>
<li>
<p><code>nbits</code> - the number of bits used to address the slots; </p>
</li>
<li>
<p><code>num_entries</code> - the number of entries in the map;</p>
</li>
<li>
<p><code>num_free</code> - the number of entries in the free list of removed 
  entries;</p>
</li>
<li>
<p><code>probe_count</code> - the number of map probes since the last resizing or
  initialization;</p>
</li>
<li>
<p><code>total_probes</code> - the number of probes of the map up to the last
  resizing or initialization; and</p>
</li>
<li>
<p><code>hasher</code> - a pointer to the hash function used by the map.</p>
</li>
</ul>
<p>It also defines five non-overridable procedures:</p>
<ul>
<li>
<p><code>calls</code> - returns the number of procedure calls on the map;</p>
</li>
<li>
<p><code>entries</code> - returns the number of entries in the map;</p>
</li>
<li>
<p><code>map_probes</code> - returns the number of map probes since
  initialization;</p>
</li>
<li>
<p><code>num_slots</code> - returns the number of slots in the map; and</p>
</li>
<li>
<p><code>slots_bits</code> - returns the number of bits used to address the slots;</p>
</li>
</ul>
<p>and ten deferred procedures:</p>
<ul>
<li>
<p><code>get_all_keys</code> - gets all the keys contained in a map;</p>
</li>
<li>
<p><code>get_other_data</code> - gets the other map data associated with the key;</p>
</li>
<li>
<p><code>init</code> - initializes the hash map;</p>
</li>
<li>
<p><code>key_test</code> - returns a logical flag indicating whether the key is 
  defined in the map. </p>
</li>
<li>
<p><code>loading</code> - returns the ratio of the number of entries to the number
  of slots;</p>
</li>
<li>
<p><code>map_entry</code> - inserts a key and its other associated data into the
  map;</p>
</li>
<li>
<p><code>rehash</code> - rehashes the map with the provided hash function;</p>
</li>
<li>
<p><code>remove</code> - removes the entry associated wit the key;</p>
</li>
<li>
<p><code>set_other_data</code> - replaces the other data associated with the key;</p>
</li>
<li>
<p><code>total_depth</code> - returns the number of probes needed to address all
  the entries in the map;</p>
</li>
</ul>
<p>The type's definition is below:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hashmap_type</span>

<span class="w">        </span><span class="k">private</span>
<span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_calls</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">call_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_calls</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">probe_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_calls</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">total_probes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">num_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">num_free</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w">     </span><span class="kd">::</span><span class="w"> </span><span class="n">nbits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_bits</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">hasher_fun</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="p">,</span><span class="w"> </span><span class="k">nopass</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">hasher</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fnv_1_hasher</span>

<span class="w">    </span><span class="k">contains</span>

<span class="k">        procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">calls</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">entries</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map_probes</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">num_slots</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">slots_bits</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">get_all_keys</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">        </span><span class="kd">::</span><span class="w"> </span><span class="n">get_all_keys</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">init_map</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">            </span><span class="kd">::</span><span class="w"> </span><span class="n">init</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">loading</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">             </span><span class="kd">::</span><span class="w"> </span><span class="n">loading</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">rehash_map</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">          </span><span class="kd">::</span><span class="w"> </span><span class="n">rehash</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">total_depth</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">         </span><span class="kd">::</span><span class="w"> </span><span class="n">total_depth</span>

<span class="w">        </span><span class="c">!! Generic interfaces for key types.</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">key_key_test</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_key_test</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int8_key_test</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int32_key_test</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">char_key_test</span>

<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">key_map_entry</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_map_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int8_map_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int32_map_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">char_map_entry</span>

<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">key_get_other_data</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="n">key_get_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int8_get_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int32_get_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">char_get_other_data</span>

<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">key_remove_entry</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_remove_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int8_remove_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int32_remove_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">char_remove_entry</span>

<span class="w">        </span><span class="k">procedure</span><span class="p">(</span><span class="n">key_set_other_data</span><span class="p">),</span><span class="w"> </span><span class="k">deferred</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="n">key_set_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int8_set_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">int32_set_other_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="p">,</span><span class="w"> </span><span class="k">non_overridable</span><span class="p">,</span><span class="w"> </span><span class="k">pass</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">char_set_other_data</span>

<span class="w">        </span><span class="k">generic</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_test</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">key_key_test</span><span class="p">,</span><span class="w"> </span><span class="n">int8_key_test</span><span class="p">,</span><span class="w"> </span><span class="n">int32_key_test</span><span class="p">,</span><span class="w"> </span><span class="n">char_key_test</span>
<span class="w">        </span><span class="k">generic</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map_entry</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">key_map_entry</span><span class="p">,</span><span class="w"> </span><span class="n">int8_map_entry</span><span class="p">,</span><span class="w"> </span><span class="n">int32_map_entry</span><span class="p">,</span><span class="w"> </span><span class="n">char_map_entry</span>
<span class="w">        </span><span class="k">generic</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">get_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">key_get_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">int8_get_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">int32_get_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">char_get_other_data</span>
<span class="w">        </span><span class="k">generic</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">remove</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">key_remove_entry</span><span class="p">,</span><span class="w"> </span><span class="n">int8_remove_entry</span><span class="p">,</span><span class="w"> </span><span class="n">int32_remove_entry</span><span class="p">,</span><span class="w"> </span><span class="n">char_remove_entry</span>
<span class="w">        </span><span class="k">generic</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">set_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">key_set_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">int8_set_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">int32_set_other_data</span><span class="p">,</span><span class="w"> </span><span class="n">char_set_other_data</span>

<span class="w">    </span><span class="k">end type </span><span class="n">hashmap_type</span>
</code></pre></div>

<h4 id="the-chaining_map_entry_type-derived-type">The <code>chaining_map_entry_type</code> derived type</h4>
<p>Entities of the type <code>chaining_map_entry_type</code> are used to define
a linked list structure that stores the
key, its other data, the hash of the key, and the resulting index into
the inverse table. The type's definition is below:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">chaining_map_entry_type</span><span class="w">  </span><span class="c">! Chaining hash map entry type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_hash</span><span class="p">)</span><span class="w">   </span><span class="kd">::</span><span class="w"> </span><span class="n">hash_val</span><span class="w"> </span><span class="c">! Full hash value</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="c">! The entry&#39;s key</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="c">! Other entry data</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="nb">index</span><span class="w"> </span><span class="c">! Index into inverse table</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_type</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">            </span><span class="n">next</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span><span class="w"> </span><span class="c">! Next bucket</span>
<span class="w">    </span><span class="k">end type </span><span class="n">chaining_map_entry_type</span>
</code></pre></div>

<p>Currently the <code>int_hash</code> and <code>int_index</code> have the value of <code>int32</code>.</p>
<h4 id="the-chaining_map_entry_ptr-derived-type">The <code>chaining_map_entry_ptr</code> derived type</h4>
<p>The type <code>chaining_map_entry_ptr</code> is used to define the elements of
the hash map that are either empty or link to the linked lists
containing the elements of the table. The type's definition is below:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type </span><span class="n">chaining_map_entry_ptr</span><span class="w"> </span><span class="c">! Wrapper for a pointer to a chaining</span>
<span class="w">                                </span><span class="c">! map entry type object</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_type</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">target</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">    </span><span class="k">end type </span><span class="n">chaining_map_entry_ptr</span>
</code></pre></div>

<h4 id="the-chaining_map_entry_pool-derived-type">The <code>chaining_map_entry_pool</code> derived type</h4>
<p>The type <code>chaining_map_entry_pool</code> is used to implement a pool of
allocated <code>chaining_map_entry_type</code> elements to save on allocation
costs. The type's definition is below: </p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">chaining_map_entry_pool</span>
<span class="w">    </span><span class="c">! Type implementing a pool of allocated</span>
<span class="w">    </span><span class="c">! `chaining_map_entry_type` objects</span>
<span class="w">        </span><span class="k">private</span>
<span class="w">    </span><span class="c">! Index of next bucket</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w">                          </span><span class="kd">::</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_type</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">more_map_entries</span><span class="p">(:)</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_pool</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">lastpool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">    </span><span class="k">end type </span><span class="n">chaining_map_entry_pool</span>
</code></pre></div>

<h4 id="the-chaining_hashmap_type-derived-type">The <code>chaining_hashmap_type</code> derived type</h4>
<p>The <code>chaining_hashmap_type</code> derived type extends the <code>hashmap_type</code> to
implements a separate chaining hash map. In addition to the components
of the <code>hashmap_type</code> it provides the four components:</p>
<ul>
<li>
<p><code>cache</code> - a pool of <code>chaining_map_entry_pool</code> objects used to reduce
allocation costs;</p>
</li>
<li>
<p><code>free_list</code> - a free list of map entries;</p>
</li>
<li>
<p><code>inverse</code> - an array of <code>chaining_map_entry_ptr</code> bucket lists
(inverses) storing entries at fixed locations once
entered; and</p>
</li>
<li>
<p><code>slots</code> - an array of bucket lists serving as the hash map.</p>
</li>
</ul>
<p>It also implements all of the deferred procedures of the
<code>hashmap_type</code> and a finalizer for its maps. The type's definition is
as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="k">extends</span><span class="p">(</span><span class="n">hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        type</span><span class="p">(</span><span class="n">chaining_map_entry_pool</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_type</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">free_list</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_ptr</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">inverse</span><span class="p">(:)</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_map_entry_ptr</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">slots</span><span class="p">(:)</span>
<span class="w">    </span><span class="k">contains</span>
<span class="k">        procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">get_all_keys</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">get_all_chaining_keys</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_get_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">get_other_chaining_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">init_chaining_map</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">loading</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">chaining_loading</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_map_entry</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">map_chain_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">rehash</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">rehash_chaining_map</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_remove_entry</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">remove_chaining_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_set_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">set_other_chaining_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">total_depth</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">total_chaining_depth</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_key_test</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">chaining_key_test</span>
<span class="w">        </span><span class="k">final</span><span class="w">     </span><span class="kd">::</span><span class="w"> </span><span class="n">free_chaining_map</span>
<span class="w">    </span><span class="k">end type </span><span class="n">chaining_hashmap_type</span>
</code></pre></div>

<h4 id="the-open_map_entry_type-derived-type">The <code>open_map_entry_type</code> derived type</h4>
<p>Entities of the type <code>open_map_entry_type</code> are used to define
a linked list structure that stores the
key, its other data, the hash of the key, and the resulting index into
the inverse table. The type's definition is below:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">open_map_entry_type</span><span class="w">  </span><span class="c">! Open hash map entry type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_hash</span><span class="p">)</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="n">hash_val</span><span class="w"> </span><span class="c">! Full hash value</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">     </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="c">! The entry&#39;s key</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">   </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="c">! Other entry data</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">index</span><span class="w"> </span><span class="c">! Index into inverse table</span>
<span class="w">    </span><span class="k">end type </span><span class="n">open_map_entry_type</span>
</code></pre></div>

<p>Currently <code>int_hash</code> and <code>int_index</code> have the value of <code>int32</code>.</p>
<h4 id="the-open_map_entry_ptr-derived-type">The <code>open_map_entry_ptr</code> derived type</h4>
<p>The type <code>open_map_entry_ptr</code> is used to define the elements of
the hash map that are either empty or link to the linked lists
containing the elements of the table. The type's definition is below:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type </span><span class="n">open_map_entry_ptr</span><span class="w"> </span><span class="c">! Wrapper for a pointer to a open</span>
<span class="w">                            </span><span class="c">! map entry type object</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">open_map_entry_type</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">target</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">    </span><span class="k">end type </span><span class="n">open_map_entry_ptr</span>
</code></pre></div>

<h4 id="the-open_hashmap_type-derived-type">The <code>open_hashmap_type</code> derived type</h4>
<p>The <code>open_hashmap_type</code> derived type extends the <code>hashmap_type</code> to
implement an open addressing hash map. In addition to the components
of the <code>hashmap_type</code> it provides the four components:</p>
<ul>
<li>
<p><code>cache</code> - a pool of <code>open_map_entry_pool</code> objects used to reduce
allocation costs;</p>
</li>
<li>
<p><code>free_list</code> - a free list of map entries;</p>
</li>
<li>
<p><code>index_mask</code> - an <code>and</code> mask used in linear addressing;</p>
</li>
<li>
<p><code>inverse</code> - an array of <code>open_map_entry_ptr</code> bucket lists
(inverses) storing entries at fixed locations once
entered; and</p>
</li>
<li>
<p><code>slots</code> - an array of bucket lists serving as the hash map.</p>
</li>
</ul>
<p>It also implements all of the deferred procedures of the
<code>hashmap_type</code> and a finalizer for its maps. The type's definition is
as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="k">extends</span><span class="p">(</span><span class="n">hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">open_hashmap_type</span>
<span class="w">        </span><span class="k">private</span>
<span class="k">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">index_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2_int_index</span><span class="o">**</span><span class="n">default_bits</span><span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">open_map_entry_pool</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">open_map_entry_list</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">free_list</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">null</span><span class="p">()</span>
<span class="w">        </span><span class="k">type</span><span class="p">(</span><span class="n">open_map_entry_ptr</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="n">inverse</span><span class="p">(:)</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w">        </span><span class="kd">::</span><span class="w"> </span><span class="n">slots</span><span class="p">(:)</span>
<span class="w">    </span><span class="k">contains</span>
<span class="k">        procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">get_all_keys</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">get_all_open_keys</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_get_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">get_other_open_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">init_open_map</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">loading</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">open_loading</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_map_entry</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">map_open_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">rehash</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">rehash_open_map</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_remove_entry</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">remove_open_entry</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_set_other_data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">set_other_open_data</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">total_depth</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">total_open_depth</span>
<span class="w">        </span><span class="k">procedure</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key_key_test</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">open_key_test</span>
<span class="w">        </span><span class="k">final</span><span class="w">     </span><span class="kd">::</span><span class="w"> </span><span class="n">free_open_map</span>
<span class="w">    </span><span class="k">end type </span><span class="n">open_hashmap_type</span>
</code></pre></div>

<h3 id="table-of-stdlib_hashmap-procedures">Table of <code>stdlib_hashmap</code> procedures</h3>
<p>The <code>stdlib_hashmap</code> module provides procedures in
several categories: a procedure to initialize the map; a procedure to
modify the structure of a map; procedures to modify the content of a
map; procedures to report on the content of a map; and procedures
to report on the structure of the map. The procedures in each category
are listed below.</p>
<p>Procedure to initialize a chaining hash map:</p>
<ul>
<li><code>map % init( hasher[, slots_bits, status] )</code> - Routine
  to initialize a chaining hash map.</li>
</ul>
<p>Procedure to modify the structure of a map:</p>
<ul>
<li><code>map % rehash( hasher )</code> - Routine to change the hash function
  for a map.</li>
</ul>
<p>Procedures to modify the content of a map:</p>
<ul>
<li>
<p><code>map % map_entry( key, other, conflict )</code> - Inserts an entry into the
  hash map.</p>
</li>
<li>
<p><code>map % remove( key, existed )</code> - Remove the entry, if any,
  associated with the <code>key</code>.</p>
</li>
<li>
<p><code>map % set_other_data( key, other, exists )</code> - Change the other data
  associated with the entry.</p>
</li>
</ul>
<p>Procedures to report the content of a map:</p>
<ul>
<li>
<p><code>map % get_all_keys( all_keys )</code> - Returns all the keys
  contained in the map;</p>
</li>
<li>
<p><code>map % get_other_data( key, other, exists )</code> - Returns the other data
  associated with the <code>key</code>;</p>
</li>
<li>
<p><code>map % key_test( key, present)</code> - Returns a flag indicating whether
  the <code>key</code> is present in the map.</p>
</li>
</ul>
<p>Procedures to report on the structure of the map:</p>
<ul>
<li>
<p><code>map % calls()</code> - the number of subroutine calls on the hash map.</p>
</li>
<li>
<p><code>map % entries()</code>- the number of entries in a hash map.</p>
</li>
<li>
<p><code>map % loading()</code> - the number of entries relative to the number of
  slots in a hash map.</p>
</li>
<li>
<p><code>map % map_probes()</code> - the total number of table probes on a hash
  map.</p>
</li>
<li>
<p><code>map % slots()</code> - Returns the number of allocated slots in a hash
  map.</p>
</li>
<li>
<p><code>map % total_depth()</code> - Returns the total number of one's based
offsets of slot entries from their slot index</p>
</li>
</ul>
<h3 id="specifications-of-the-stdlib_hashmaps-procedures">Specifications of the <code>stdlib_hashmaps</code> procedures</h3>
<h4 id="calls-returns-the-number-of-calls-on-the-hash-map"><code>calls</code> - Returns the number of calls on the hash map</h4>
<h5 id="status_14">Status</h5>
<p>Experimental</p>
<h5 id="description_14">Description</h5>
<p>Returns the number of procedure calls on a hash map.</p>
<h5 id="syntax_13">Syntax</h5>
<p><code>value = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-calls">calls</a> <code>()</code></p>
<h5 id="class_13">Class</h5>
<p>Pure function</p>
<h5 id="argument_10">Argument</h5>
<p><code>map</code> (pass) - shall be an expression of class <code>hashmap_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_7">Result character</h5>
<p>The result will be an integer of kind <code>int_calls</code>.</p>
<h5 id="result-value_7">Result value</h5>
<p>The result will be the number of procedure calls on the hash map.</p>
<h5 id="example_13">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_calls</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_calls</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_calls</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">initial_calls</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">initial_calls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">calls</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;INITIAL_CALLS =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">initial_calls</span>
<span class="k">end program </span><span class="n">example_calls</span>
</code></pre></div>

<h4 id="entries-returns-the-number-of-entries-in-the-hash-map"><code>entries</code> - Returns the number of entries in the hash map</h4>
<h5 id="status_15">Status</h5>
<p>Experimental</p>
<h5 id="description_15">Description</h5>
<p>Returns the number of entries in a hash map.</p>
<h5 id="syntax_14">Syntax</h5>
<p><code>value = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-entries">entries</a> <code>()</code></p>
<h5 id="class_14">Class</h5>
<p>Pure function</p>
<h5 id="argument_11">Argument</h5>
<p><code>map</code> (pass)  - shall be an expression of class <code>hashmap_type</code>.
It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_8">Result character</h5>
<p>The result will be an integer of kind <code>int_index</code>.</p>
<h5 id="result-value_8">Result value</h5>
<p>The result will be the number of entries in the hash map.</p>
<h5 id="example_14">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_entries</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">open_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_index</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">open_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">initial_entries</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">initial_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">entries</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;INITIAL_ENTRIES =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">initial_entries</span>
<span class="k">end program </span><span class="n">example_entries</span>
</code></pre></div>

<h4 id="get_all_keys-returns-all-the-keys-contained-in-a-map"><code>get_all_keys</code> - Returns all the keys contained in a map</h4>
<h5 id="status_16">Status</h5>
<p>Experimental</p>
<h5 id="description_16">Description</h5>
<p>Returns all the keys contained in a map.</p>
<h5 id="syntax_15">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-get_all_keys">get_all_keys</a> <code>( all_keys )</code></p>
<h5 id="class_15">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_3">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
  <code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. It is an
  <code>intent(in)</code> argument. It will be 
  the hash map used to store and access the other data.</p>
<p><code>all_keys</code>: shall be a rank-1 allocatable array of type <code>key_type</code>. 
  It is an <code>intent(out)</code> argument.</p>
<h5 id="example_15">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_hashmaps_get_all_keys</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int32</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">get</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                                     </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">   </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>

<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">keys</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>

<span class="w">  </span><span class="kt">character</span><span class="p">(:),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">str</span>

<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>

<span class="w">  </span><span class="c">! adding key-value pairs to the map</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;initial key&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;value 1&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>

<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;second key&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;value 2&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>

<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;last key&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;value 3&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>

<span class="w">  </span><span class="c">! getting all the keys in the map</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">get_all_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="s1">&#39;(&quot;Number of keys in the hashmap = &quot;, I0)&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="w">  </span><span class="c">!Number of keys in the hashmap = 3</span>

<span class="w">  </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="w">    </span><span class="k">call </span><span class="n">get</span><span class="p">(</span><span class="w"> </span><span class="n">keys</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="p">)</span><span class="w">  </span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s1">&#39;(&quot;Value of key &quot;, I0, &quot; = &quot;, A)&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">str</span>
<span class="w">  </span><span class="k">end do</span>
<span class="w">  </span><span class="c">!Value of key 1 = initial key</span>
<span class="w">  </span><span class="c">!Value of key 2 = second key</span>
<span class="w">  </span><span class="c">!Value of key 3 = last key</span>

<span class="k">end program </span><span class="n">example_hashmaps_get_all_keys</span>
</code></pre></div>

<h4 id="get_other_data-returns-other-data-associated-with-the-key"><code>get_other_data</code> - Returns other data associated with the <code>key</code></h4>
<h5 id="status_17">Status</h5>
<p>Experimental</p>
<h5 id="description_17">Description</h5>
<p>Returns the other data associated with the <code>key</code>,</p>
<h5 id="syntax_16">Syntax</h5>
<p><code>value = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-get_other_data">get_other_data</a> <code>( key, other [, exists] )</code></p>
<h5 id="class_16">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_4">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
  <code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. It is an
  <code>intent(inout)</code> argument. It will be 
  the hash map used to store and access the other data.</p>
<p><code>key</code>: shall be a of type <code>key_type</code> scalar, <code>character</code> scalar, <code>int8</code> array
or <code>int32</code> array. It is an <code>intent(in)</code> argument.</p>
<p><code>other</code>: shall be a variable of type <code>other_data</code>.
  It is an <code>intent(out)</code> argument. It is the other data associated
  with the <code>key</code>.</p>
<p><code>exists</code> (optional): shall be a variable of type logical. It is an
<code>intent(out)</code> argument. If <code>.true.</code> an entry with the given <code>key</code>
exists in the map and <code>other</code> is defined. If <code>.false.</code> <code>other</code> is
undefined.</p>
<h5 id="example_16">Example</h5>
<p>The following is an example of the retrieval of other data
  associated with a <code>key</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_get_other_data</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int64</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_index</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="n">get</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">logical</span><span class="w">                     </span><span class="kd">::</span><span class="w"> </span><span class="n">conflict</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">              </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">            </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type </span><span class="n">dummy_type</span>
<span class="w">    </span><span class="kt">integer</span><span class="w">                   </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">end type </span><span class="n">dummy_type</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dummy</span>
<span class="w">  </span><span class="k">class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w">       </span><span class="kd">::</span><span class="w"> </span><span class="k">data</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int8</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w">  </span><span class="kd">::</span><span class="w"> </span><span class="n">key_array</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">integer</span><span class="w">                     </span><span class="kd">::</span><span class="w"> </span><span class="n">int_scalar</span>

<span class="w">  </span><span class="c">! Initialize hashmap</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>

<span class="w">  </span><span class="c">! Hashmap functions are setup to store scalar value types (other).  Use a dervied</span>
<span class="w">  </span><span class="c">! type wrapper to store arrays.</span>
<span class="w">  </span><span class="n">dummy</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">dummy</span><span class="p">)</span>

<span class="w">  </span><span class="c">! Explicitly set key type using set function</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="nb">not</span><span class="p">.</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">    call </span><span class="n">map</span><span class="p">%</span><span class="n">get_other_data</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">else</span>
<span class="k">    error stop</span><span class="w"> </span><span class="s1">&#39;Key is already present in the map.&#39;</span>
<span class="w">  </span><span class="k">end if</span>
<span class="k">  call </span><span class="n">get</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Other data % value = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">%</span><span class="k">value</span>
<span class="k">  class </span><span class="n">default</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Invalid data type in other&#39;</span>
<span class="w">  </span><span class="k">end select</span>

<span class="c">! Also can use map_entry and get_other_data generic key interfaces.   </span>
<span class="c">! This is an exmple with integer arrays.  </span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="nb">not</span><span class="p">.</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">    call </span><span class="n">map</span><span class="p">%</span><span class="n">get_other_data</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">else</span>
<span class="k">    error stop</span><span class="w"> </span><span class="s1">&#39;Key is already present in the map.&#39;</span>
<span class="w">  </span><span class="k">end if</span>
<span class="k">  call </span><span class="n">get</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Other data % value = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">%</span><span class="k">value</span>
<span class="k">  class </span><span class="n">default</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Invalid data type in other&#39;</span>
<span class="w">  </span><span class="k">end select</span>

<span class="w">  </span><span class="c">! Integer scalars need to be passed as an array.   </span>
<span class="w">  </span><span class="n">int_scalar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">int_scalar</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="nb">not</span><span class="p">.</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">    call </span><span class="n">map</span><span class="p">%</span><span class="n">get_other_data</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">int_scalar</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">else</span>
<span class="k">    error stop</span><span class="w"> </span><span class="s1">&#39;Key is already present in the map.&#39;</span>
<span class="w">  </span><span class="k">end if</span>
<span class="k">  call </span><span class="n">get</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Other data % value = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">%</span><span class="k">value</span>
<span class="k">  class </span><span class="n">default</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Invalid data type in other&#39;</span>
<span class="w">  </span><span class="k">end select</span>

<span class="w">  </span><span class="c">! Example using character type key interface</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="s1">&#39;key_string&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="nb">not</span><span class="p">.</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">    call </span><span class="n">map</span><span class="p">%</span><span class="n">get_other_data</span><span class="p">(</span><span class="w"> </span><span class="s1">&#39;key_string&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">else</span>
<span class="k">    error stop</span><span class="w"> </span><span class="s1">&#39;Key is already present in the map.&#39;</span>
<span class="w">  </span><span class="k">end if</span>
<span class="k">  call </span><span class="n">get</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Other data % value = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">%</span><span class="k">value</span>
<span class="k">  class </span><span class="n">default</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Invalid data type in other&#39;</span>
<span class="w">  </span><span class="k">end select</span>

<span class="c">! Transfer to int8 arrays to generate key for unsupported types.  </span>
<span class="w">  </span><span class="n">key_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">transfer</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int64</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int8</span><span class="p">]</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="n">key_array</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="nb">not</span><span class="p">.</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">    call </span><span class="n">map</span><span class="p">%</span><span class="n">get_other_data</span><span class="p">(</span><span class="w"> </span><span class="n">key_array</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">else</span>
<span class="k">    error stop</span><span class="w"> </span><span class="s1">&#39;Key is already present in the map.&#39;</span>
<span class="w">  </span><span class="k">end if</span>
<span class="k">  call </span><span class="n">get</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">select type</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="w">  </span><span class="k">type is</span><span class="w"> </span><span class="p">(</span><span class="n">dummy_type</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Other data % value = &#39;</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">%</span><span class="k">value</span>
<span class="k">  class </span><span class="n">default</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Invalid data type in other&#39;</span>
<span class="w">  </span><span class="k">end select</span>

<span class="k">end program </span><span class="n">example_get_other_data</span>
</code></pre></div>

<h4 id="init-initializes-a-hash-map"><code>init</code> - initializes a hash map</h4>
<h5 id="status_18">Status</h5>
<p>Experimental</p>
<h5 id="description_18">Description</h5>
<p>Initializes a <code>hashmap_type</code> object.</p>
<h5 id="syntax_17">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-init">init</a> <code>( hasher [, slots_bits, status ] )</code></p>
<h5 id="class_17">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_5">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
  <code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. It is an
  <code>intent(out)</code> argument. It will 
  be a hash map used to store and access the entries.</p>
<p><code>hasher</code>: shall be a procedure with interface <code>hash_fun</code>.
  It is an <code>intent(in)</code> argument. It is the procedure to be used to
  generate the hashes for the table from the keys of the entries.</p>
<p><code>slots_bits</code> (optional): shall be a scalar default integer 
  expression. It is an <code>intent(in)</code> argument. The initial number of
  slots in the table will be <code>2**slots_bits</code>.</p>
<ul>
<li>
<p><code>slots_bits</code> shall be a positive default integer less than
  <code>max_bits</code>, otherwise processing stops with an informative
  error code.</p>
</li>
<li>
<p>If <code>slots_bits</code> is absent then the effective value for <code>slots_bits</code>
  is <code>default_bits</code>.</p>
</li>
</ul>
<p><code>status</code> (optional): shall be a scalar integer variable of kind
<code>int32</code>. It is an <code>intent(out)</code> argument. On return if present it
shall have an error code value.</p>
<ul>
<li>
<p>If map was successfully initialized then <code>status</code> has the value
<code>success</code>.</p>
</li>
<li>
<p>If allocation of memory for the <code>map</code> arrays fails then <code>status</code>
has the value <code>alloc_fault</code>.</p>
</li>
<li>
<p>If <code>slot_bits &lt; 6</code> or <code>slots_bits &gt; max_bits</code> then <code>status</code>
  has the value of <code>array_size_error</code>.</p>
</li>
<li>
<p>If <code>status</code> is absent, but <code>status</code> would have a value other than
<code>success</code>, then processing stops with an informative stop code.</p>
</li>
</ul>
<h5 id="example_17">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_init</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">slots_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_init</span>
</code></pre></div>

<h4 id="key_test-indicates-whether-key-is-present"><code>key_test</code> - indicates whether <code>key</code> is present</h4>
<h5 id="status_19">Status</h5>
<p>Experimental</p>
<h5 id="description_19">Description</h5>
<p>Returns a logical flag indicating whether <code>key</code> is present for an
entry in the map.</p>
<h5 id="syntax_18">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-key_test">key_test</a> <code>( key, present )</code></p>
<h5 id="class_18">Class</h5>
<p>Subroutine.</p>
<h5 id="arguments_6">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
<code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. 
It is an <code>intent(inout)</code> argument. It is the hash map whose entries
are examined.</p>
<p><code>key</code>: shall be a of type <code>key_type</code> scalar, <code>character</code> scalar, <code>int8</code> array
or <code>int32</code> array. It is an <code>intent(in)</code> argument. It is a <code>key</code> whose 
presence in the <code>map</code> is being examined.</p>
<p><code>present</code> (optional): shall be a scalar variable of type default
<code>logical</code>. It is an intent(out) argument. It is a logical flag where
<code>.true.</code> indicates that an entry with that <code>key</code> is present in the
<code>map</code> and <code>.false.</code> indicates that no such entry is present.</p>
<h5 id="example_18">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_key_test</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="kt">logical</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">present</span>
<span class="nb">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">1_int8</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">key_test</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="nb">present</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial key of 10 present for empty map =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">present</span>
<span class="k">end program </span><span class="n">example_key_test</span>
</code></pre></div>

<h4 id="loading-returns-the-ratio-of-entries-to-slots"><code>loading</code> - Returns the ratio of entries to slots</h4>
<h5 id="status_20">Status</h5>
<p>Experimental</p>
<h5 id="description_20">Description</h5>
<p>Returns the ratio of the number of entries relative to the number of
slots in the hash map.</p>
<h5 id="syntax_19">Syntax</h5>
<p><code>value = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-loading">loading</a> <code>( )</code></p>
<h5 id="class_19">Class</h5>
<p>Pure function</p>
<h5 id="argument_12">Argument</h5>
<p><code>map</code> (pass) - shall be an expression of class <code>chaining_hashmap_type</code>
or <code>open_hashmap_type</code>. It is an <code>intent(in)</code> argument.</p>
<h5 id="result-character_9">Result character</h5>
<p>The result will be a default real.</p>
<h5 id="result-value_9">Result value</h5>
<p>The result will be the ratio of the number of entries relative to the
number of slots in the hash map.</p>
<h5 id="example_19">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_loading</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">open_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">open_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ratio</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">ratio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">loading</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial loading =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ratio</span>
<span class="k">end program </span><span class="n">example_loading</span>
</code></pre></div>

<h4 id="map_entry-inserts-an-entry-into-the-hash-map"><code>map_entry</code> - inserts an entry into the hash map</h4>
<h5 id="status_21">Status</h5>
<p>Experimental</p>
<h5 id="description_21">Description</h5>
<p>Inserts an entry into the hash map if it is not already present.</p>
<h5 id="syntax_20">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-map_entry">map_entry</a> <code>( key[, other, conflict ] )</code></p>
<h5 id="class_20">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_7">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
<code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. It
is an <code>intent(inout)</code> argument. It is the hash map to receive the
entry.</p>
<p><code>key</code>: shall be a of type <code>key_type</code> scalar, <code>character</code> scalar, <code>int8</code> array
or <code>int32</code> array. It is an <code>intent(in)</code> argument. It is the key for the entry
to be placed in the table.</p>
<p><code>other</code> (optional): shall be a scalar expression of type <code>other_type</code>.
  It is an <code>intent(in)</code> argument. If present it is the other data to be
  associated with the <code>key</code>.</p>
<p><code>conflict</code> (optional): shall be a scalar variable of type
<code>logical</code>. It is an <code>intent(out)</code> argument. If present, a <code>.true.</code>
value indicates that an entry with the value of <code>key</code> already exists
and the entry was not entered into the map, a <code>.false.</code> value indicates
that <code>key</code> was not present in the map and the entry was added to the
map. </p>
<ul>
<li>If <code>key</code> is already present in <code>map</code> then the presence of <code>other</code> 
is ignored.</li>
</ul>
<h5 id="example_20">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_map_entry</span>
<span class="w">  </span><span class="k">use</span><span class="p">,</span><span class="w"> </span><span class="k">intrinsic</span><span class="kd">::</span><span class="w"> </span><span class="n">iso_fortran_env</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int64</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="kt">logical</span><span class="w">             </span><span class="kd">::</span><span class="w"> </span><span class="n">conflict</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>
<span class="w">  </span><span class="kt">integer</span><span class="w">             </span><span class="kd">::</span><span class="w"> </span><span class="n">int_scalar</span>

<span class="w">  </span><span class="c">! Initialize hashmap with 2^10 slots.</span>
<span class="w">  </span><span class="c">! Hashmap will dynamically increase size if needed.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">slots_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="c">! Initialize other type with data to store.</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>

<span class="w">  </span><span class="c">! Explicitly set key using set function</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>

<span class="w">  </span><span class="c">! Using map_entry int32 array interface</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>

<span class="w">  </span><span class="c">! Integer scalars need to be passed as an array.</span>
<span class="w">  </span><span class="n">int_scalar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">int_scalar</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>

<span class="w">  </span><span class="c">! Using map_entry character interface</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="s1">&#39;key_string&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>

<span class="w">  </span><span class="c">! Transfer unsupported key types to int8 arrays.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="nb">transfer</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">1_int64</span><span class="p">,</span><span class="w"> </span><span class="mi">2_int64</span><span class="p">,</span><span class="w"> </span><span class="mi">3_int64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int8</span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>

<span class="c">! Keys can be mapped alone without a corresponding value (other).</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="n">conflict</span><span class="o">=</span><span class="n">conflict</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CONFLICT = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">conflict</span>
<span class="k">end program </span><span class="n">example_map_entry</span>
</code></pre></div>

<h4 id="map_probes-returns-the-number-of-hash-map-probes"><code>map_probes</code> - returns the number of hash map probes</h4>
<h5 id="status_22">Status</h5>
<p>Experimental</p>
<h5 id="description_22">Description</h5>
<p>Returns the total number of table probes on the hash map.</p>
<h5 id="syntax_21">Syntax</h5>
<p><code>result = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-map_probes">map_probes</a> <code>( )</code></p>
<h5 id="class_21">Class</h5>
<p>Pure function</p>
<h5 id="argument_13">Argument</h5>
<p><code>map</code> (pass): shall be a scalar expression of class
<code>hashmap_type</code>. It is an <code>intent(in)</code>
argument. It is the hash map of interest.</p>
<h5 id="result-character_10">Result character</h5>
<p>The result is a scalar integer of kind <code>int_probes</code>.</p>
<h5 id="result-value_10">Result value</h5>
<p>The result is the number of probes of <code>map</code> since initialization or
rehashing. </p>
<h5 id="example_21">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_probes</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nprobes</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">nprobes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">map_probes</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial probes =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nprobes</span>
<span class="k">end program </span><span class="n">example_probes</span>
</code></pre></div>

<h4 id="num_slots-returns-the-number-of-hash-map-slots"><code>num_slots</code> - returns the number of hash map slots.</h4>
<h5 id="status_23">Status</h5>
<p>Experimental</p>
<h5 id="description_23">Description</h5>
<p>Returns the total number of slots on a hash map</p>
<h5 id="syntax_22">Syntax</h5>
<p><code>result = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-num_slots">num_slots</a> <code>( )</code></p>
<h5 id="class_22">Class</h5>
<p>Pure function</p>
<h5 id="argument_14">Argument</h5>
<p><code>map</code>: shall be a scalar expression of class
<code>hashmap_type</code>. It is an <code>intent(in)</code> argument. It is the
hash map of interest.</p>
<h5 id="result-character_11">Result character</h5>
<p>The result is a scalar integer of kind <code>int_index</code>.</p>
<h5 id="result-value_11">Result value</h5>
<p>The result is the number of slots in <code>map</code>.</p>
<h5 id="example_22">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_num_slots</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_index</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_index</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">initial_slots</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">initial_slots</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">num_slots</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial slots =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">initial_slots</span>
<span class="k">end program </span><span class="n">example_num_slots</span>
</code></pre></div>

<h4 id="rehash-changes-the-hashing-function"><code>rehash</code> - changes the hashing function</h4>
<h5 id="status_24">Status</h5>
<p>Experimental</p>
<h5 id="description_24">Description</h5>
<p>Changes the hashing function for the map entries to that of <code>hasher</code>.</p>
<h5 id="syntax_23">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-rehash">rehash</a> <code>( hasher )</code></p>
<h5 id="class_23">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_8">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
<code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>.
It is an <code>intent(inout)</code> argument. It is the hash map whose hashing 
method is to be changed.</p>
<p><code>hasher</code>: shall be a function of interface <code>hasher_fun</code>.
It is the hash method to be used by <code>map</code>.</p>
<h5 id="example_23">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_rehash</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">open_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">fnv_1a_hasher</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                                     </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">open_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>
<span class="w">  </span><span class="k">class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dummy</span>
<span class="w">  </span><span class="k">allocate</span><span class="w"> </span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="o">=</span><span class="s1">&#39;a dummy value&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">slots_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">5_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">7_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">4_int8</span><span class="p">,</span><span class="w"> </span><span class="mi">13_int8</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">dummy</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">rehash</span><span class="p">(</span><span class="n">fnv_1a_hasher</span><span class="p">)</span>
<span class="k">end program </span><span class="n">example_rehash</span>
</code></pre></div>

<h4 id="remove-removes-an-entry-from-the-hash-map"><code>remove</code> - removes an entry from the hash map</h4>
<h5 id="status_25">Status</h5>
<p>Experimental</p>
<h5 id="description_25">Description</h5>
<p>Removes an entry from the hash map, <code>map</code>.</p>
<h5 id="syntax_24">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-remove">remove</a> <code>( key[, existed ])</code></p>
<h5 id="class_24">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_9">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
<code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. 
It is an <code>intent(inout)</code> argument. It is the hash map with the element 
to be removed.</p>
<p><code>key</code>: shall be a of type <code>key_type</code> scalar, <code>character</code> scalar, <code>int8</code> array
or <code>int32</code> array. It is an <code>intent(in)</code> argument. It is the <code>key</code> identifying 
the entry to be removed.</p>
<p><code>existed</code> (optional): shall be a scalar variable of type default
logical. It is an <code>intent(out)</code> argument. If present with the value
<code>.true.</code> the entry existed in the map before removal, if <code>.false.</code> the
entry was not present to be removed and the map is unchanged. If
absent, the procedure returns with no entry with the given key.</p>
<h5 id="example_24">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_remove</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span><span class="p">,</span><span class="w"> </span><span class="n">int64</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">open_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_index</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                                     </span><span class="n">fnv_1a_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">open_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>
<span class="w">  </span><span class="kt">logical</span><span class="w">             </span><span class="kd">::</span><span class="w"> </span><span class="n">existed</span>
<span class="w">  </span><span class="kt">integer</span><span class="w">             </span><span class="kd">::</span><span class="w"> </span><span class="n">int_scalar</span>

<span class="w">  </span><span class="c">! Initialize hashmap with 2^10 slots.</span>
<span class="w">  </span><span class="c">! Hashmap will dynamically increase size if needed.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">slots_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="w">  </span><span class="c">! Initialize other type with data to store.</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">)</span>

<span class="w">  </span><span class="c">! Explicitly set key type using set function</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Removed key existed = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span>

<span class="w">  </span><span class="c">! Using map_entry and remove int32 generic interface.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">remove</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">existed</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Removed key existed = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span>

<span class="w">  </span><span class="c">! Integer scalars need to be passed as an array.</span>
<span class="w">  </span><span class="n">int_scalar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">int_scalar</span><span class="p">],</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">remove</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">int_scalar</span><span class="p">],</span><span class="w"> </span><span class="n">existed</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Removed key existed = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span>

<span class="w">  </span><span class="c">! Using map_entry and remove character generic interface.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="s1">&#39;key_string&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;key_string&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Removed key existed = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span>

<span class="w">  </span><span class="c">! Use transfer to int8 arrays for unsupported key types.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="w"> </span><span class="nb">transfer</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">1_int64</span><span class="p">,</span><span class="w"> </span><span class="mi">2_int64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int8</span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">remove</span><span class="p">(</span><span class="w"> </span><span class="nb">transfer</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="mi">1_int64</span><span class="p">,</span><span class="mi">2_int64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0_int8</span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">existed</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Removed key existed = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">existed</span>
<span class="k">end program </span><span class="n">example_remove</span>
</code></pre></div>

<h4 id="set_other_data-replaces-the-other-data-for-an-entry"><code>set_other_data</code> - replaces the other data for an entry</h4>
<h5 id="status_26">Status</h5>
<p>Experimental</p>
<h5 id="description_26">Description</h5>
<p>Replaces the other data in the map for the entry with the key value,
<code>key</code>.</p>
<h5 id="syntax_25">Syntax</h5>
<p><code>call map %</code> <a href="../../type/hashmap_type.html#boundprocedure-set_other_data">set_other_data</a> <code>( key, other[, exists] )</code></p>
<h5 id="class_25">Class</h5>
<p>Subroutine</p>
<h5 id="arguments_10">Arguments</h5>
<p><code>map</code> (pass): shall be a scalar variable of class
<code>chaining_hashmap_type</code> or <code>open_hashmap_type</code>. It
is an <code>intent(inout)</code> argument. It will be a hash map used to store
and access the entry's data.</p>
<p><code>key</code>: shall be a of type <code>key_type</code> scalar, <code>character</code> scalar, <code>int8</code> array
or <code>int32</code> array. It is an <code>intent(in)</code> argument. It is the <code>key</code> to the 
entry whose <code>other</code> data is to be replaced.</p>
<p><code>other</code>: shall be a scalar expression of type <code>other_type</code>.
It is an <code>intent(in)</code> argument. It is the data to be stored as
the other data for the entry with the key value, <code>key</code>.</p>
<p><code>exists</code> (optional): shall be a scalar variable of type default
logical. It is an <code>intent(out)</code> argument. If present with the value
<code>.true.</code> an entry with that <code>key</code> existed in the map and its <code>other</code>
data was replaced, otherwise if <code>exists</code> is <code>.false.</code> the entry did
not exist and nothing was done.</p>
<h5 id="example_25">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_set_other_data</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_kinds</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">int8</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">open_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                                     </span><span class="n">fnv_1a_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">key_type</span><span class="p">,</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  </span><span class="kt">logical</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">exists</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">open_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w">      </span><span class="kd">::</span><span class="w"> </span><span class="n">key</span>
<span class="w">  </span><span class="k">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)</span><span class="w">    </span><span class="kd">::</span><span class="w"> </span><span class="n">other</span>

<span class="w">  </span><span class="c">! Initialize hashmap with 2^10 slots.</span>
<span class="w">  </span><span class="c">! Hashmap will dynamically increase size if needed.</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">,</span><span class="w"> </span><span class="n">slots_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">])</span>
<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;A value&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>

<span class="w">  </span><span class="k">call </span><span class="n">set</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Another value&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">set_other_data</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="n">exists</span><span class="p">)</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;The entry to have its other data replaced exists = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">exists</span>

<span class="k">end program </span><span class="n">example_set_other_data</span>
</code></pre></div>

<h4 id="slots_bits-returns-the-number-of-bits-used-to-address-the-hash-map-slots"><code>slots_bits</code> - returns the number of bits used to address the hash map slots</h4>
<h5 id="status_27">Status</h5>
<p>Experimental</p>
<h5 id="description_27">Description</h5>
<p>Returns the total number of bits used to address the hash map slots.</p>
<h5 id="syntax_26">Syntax</h5>
<p><code>result = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-slots_bits~2">slots_bits</a> <code>( )</code></p>
<h5 id="class_26">Class</h5>
<p>Pure function</p>
<h5 id="argument_15">Argument</h5>
<p><code>map</code> (pass): shall be a scalar expression of class
<code>hashmap_type</code>. It is an <code>intent(in)</code> argument. It is the
hash map of interest.</p>
<h5 id="result-character_12">Result character</h5>
<p>The result is a scalar integer of kind <code>int_index</code>.</p>
<h5 id="result-value_12">Result value</h5>
<p>The result is the number of bits used in addressing the slots in <code>map</code>.</p>
<h5 id="example_26">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_slots_bits</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">bits</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">slots_bits</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial slot bits =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bits</span>
<span class="k">end program </span><span class="n">example_slots_bits</span>
</code></pre></div>

<h4 id="total_depth-returns-the-total-depth-of-the-hash-map-entries"><code>total_depth</code> - returns the total depth of the hash map entries</h4>
<h5 id="status_28">Status</h5>
<p>Experimental</p>
<h5 id="description_28">Description</h5>
<p>Returns the total number of one's based offsets of slot entries from
their slot index for a hash map</p>
<h5 id="syntax_27">Syntax</h5>
<p><code>result = map %</code> <a href="../../type/hashmap_type.html#boundprocedure-total_depth~2">total_depth</a> <code>( )</code></p>
<h5 id="class_27">Class</h5>
<p>Pure function</p>
<h5 id="argument_16">Argument</h5>
<p><code>map</code> (pass): shall be a scalar expression of class
<code>hashmap_type</code>. It is an <code>intent(in)</code> argument. It is the
hash map of interest.</p>
<h5 id="result-character_13">Result character</h5>
<p>The result is a scalar integer of kind <code>int_depth</code>.</p>
<h5 id="result-value_13">Result value</h5>
<p>The result is the total number of one's based offsets of slot entries
from their slot index the map.</p>
<h5 id="example_27">Example</h5>
<div class="codehilite"><pre><span></span><code><span class="k">program </span><span class="n">example_total_depth</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmaps</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">chaining_hashmap_type</span><span class="p">,</span><span class="w"> </span><span class="n">int_depth</span>
<span class="w">  </span><span class="k">use </span><span class="n">stdlib_hashmap_wrappers</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="p">:</span><span class="w"> </span><span class="n">fnv_1_hasher</span>
<span class="w">  </span><span class="k">implicit none</span>
<span class="k">  type</span><span class="p">(</span><span class="n">chaining_hashmap_type</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">map</span>
<span class="w">  </span><span class="kt">integer</span><span class="p">(</span><span class="n">int_depth</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">initial_depth</span>
<span class="w">  </span><span class="k">call </span><span class="n">map</span><span class="p">%</span><span class="n">init</span><span class="p">(</span><span class="n">fnv_1_hasher</span><span class="p">)</span>
<span class="w">  </span><span class="n">initial_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">%</span><span class="n">total_depth</span><span class="p">()</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Initial total depth =  &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">initial_depth</span>
<span class="k">end program </span><span class="n">example_total_depth</span>
</code></pre></div>
    </div>
  </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>Fortran-lang/stdlib was developed by fortran-lang/stdlib contributors<br>&copy; 2024 <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
<br /><small>1d27d273</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2024-08-21 19:15              </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../../tipuesearch/tipuesearch_content.js"></script>
          <script src="../../tipuesearch/tipuesearch_set.js"></script>
          <script src="../../tipuesearch/tipuesearch.js"></script>

  </body>
</html>